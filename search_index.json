[
["index.html", "The Bioconductor 2018 Workshop Compilation 1 Introduction 1.1 For Everyone 1.2 For Workshop Authors 1.3 Deadlines for Bioc2018", " The Bioconductor 2018 Workshop Compilation 1 Introduction Author: Martin Morgan1. Last modified: 22 May, 2018. The most recently compiled version of the book is available at https://bioconductor.github.io/BiocWorkshops/. 1.1 For Everyone This book contains workshops used in R / Bioconductor training. The workshops are divided into 3 sections: Learn (100-series chapters) contains material for beginning users of R and Bioconductor. The Bioconductor-related material is relevant even for experienced R users who are new to Bioconductor. Use (200-series chapters) contains workshops emphasizing use of Bioconductor for common tasks, e.g., bulk RNA-seq differential expression, ChIP-seq, single-cell analysis, gene set enrichment, and annotation. Develop (500-series chapters) contains workshops to help expert users hone their skills and contribute their domain-specific knowledge to the Bioconductor community. 1.2 For Workshop Authors To contribute a new workshop, open a BiocWorkshops issue asking to be added as a collaborator. 1.2.1 DESCRIPTION Update the DESCRIPTION file adding packages utilized in your workshop to the Imports field. Please be kind and don’t remove anyone elses packages from the DESCRIPTION as this is a shared file for all workshops. Also don’t add your packages to the Depends field. 1.2.2 Classifying your workshop Follow the numbering scheme above to classify your workshop by preceding your title with “Bioconductor 1xx:”, “Bioconductor 2xx:”, or “Bioconductor 5xx:”. Final workshop numbers will be determined by an editor. 1.2.3 Bookdown Write your workshop as a stand-alone markdown document, using your workshop syllabus already posted here as a starting point. We are using bookdown (‘knit-then-merge’ strategy) to compile the workshops and produce a book that will be available through Continuous Integration at https://bioconductor.github.io/BiocWorkshops/. You do not need to build the complete book yourself, it is sufficient to ensure that your own workshop compiles successfully. You can 1) compile draft versions using a standard “knit” procedure to compile your chapter, and 2) follow these bookdown procedures to see how your chapter will look in the finished product. Install the bookdown package package from CRAN, as well as pandoc. Render your chapter with the preview= option to render_book(), e.g., Rscript -e &quot;bookdown::render_book( \\ &#39;xxx_Your_Workshop.Rmd&#39;, &#39;bookdown::gitbook&#39;, preview=TRUE \\ )&quot; As this is a shared space for all workshop contributors, in order to use the above command in the BiocWorkshops directory, the index has to be built at least once, which can be time consuming depending on how many workshops have already been submitted. Rscript -e &quot;bookdown::render_book( \\ &#39;index.Rmd&#39;, &#39;bookdown::gitbook&#39;)&quot; To avoid having to build all workshops but still be able to preview your individual workshop we recommend creating a soft link to your .Rmd file. We recommend having the file in the BiocWorkshop/ and the soft link in any other directory on your system. By default, this will generate an html file in _book/ wherever this command is run. mkdir tmp cd tmp/ ln -s ../xxx_Your_Workshop.Rmd Rscript -e &quot;bookdown::render_book( \\ &#39;xxx_Your_Workshop.Rmd&#39;, &#39;bookdown::gitbook&#39;, preview=TRUE \\ )&quot; Push only your .Rmd file to the BiocWorkshop repository; the book will be rebuilt manually or automatically. Eventually the output will be available for end-users at https://bioconductor.github.io/BiocWorkshops .The master branch will not contain the built version of the book. Switching to the gh-pages branch will show built output. 1.3 Deadlines for Bioc2018 Please be aware of the following deadlines for the Bioconductor 2018 Conference in Toronto Fri June 29: draft workshop materials submitted to this Bioconductor GitHub bookdown site Fri July 6: feedback period completes Weds July 18: workshops must pass checks without errors or warnings (All materials will be checked by Continuous Integration) Thurs / Fri July 26-27: Bioc2018 Roswell Park Comprehensive Cancer Center, Buffalo, NY↩ "],
["rna-seq-data-analysis-with-deseq2.html", "2 RNA-seq data analysis with DESeq2 2.1 Overview 2.2 Preparing data for DESeq2 2.3 Importing into R with tximport 2.4 Exploratory data analysis 2.5 Differential expression analysis 2.6 AnnotationHub 2.7 Building reports 2.8 Integration with ZINB-WaVE", " 2 RNA-seq data analysis with DESeq2 Authors: Michael I. Love2, Simon Anders3, Wolfgang Huber4 Last modified: 25 June, 2018. 2.1 Overview 2.1.1 Description In this workshop, we will give a quick overview of the most useful functions in the DESeq2 package, and a basic RNA-seq analysis. We will cover: how to quantify transcript expression from FASTQ files using Salmon, import quantification from Salmon with tximport and tximeta, generate plots for quality control and exploratory data analysis EDA (also using MultiQC), perform differential expression (DE) (also using apeglm), overlap with other experimental data (using AnnotationHub), and build reports (using ReportingTools and Glimma). We will give a short example of integration of DESeq2 with the zinbwave package for single-cell RNA-seq differential expression. The workshop is designed to be a lab with plenty of time for questions throughout the lab. 2.1.2 Pre-requisites Basic knowledge of R syntax Non-essential background reading: DESeq2 paper: https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4302049/ tximport paper: https://f1000research.com/articles/4-1521/v2 apeglm paper: https://www.biorxiv.org/content/early/2018/04/17/303255 2.1.3 Participation Students will participate by following along an Rmarkdown document, and asking questions throughout the workshop. 2.1.4 R / Bioconductor packages used DESeq2 tximport apeglm AnnotationHub ReportingTools Glimma splatter zinbwave 2.1.5 Time outline Activity Time Overview of packages 20m Quantification and import 20m EDA and DE 20m Downstream analysis &amp; reports 20m ZINB-WaVE integration 20m Additional questions 20m 2.1.6 Workshop goals and objectives Learning goals Visually assess quality of RNA-seq data Perform basic differential analysis of RNA-seq data Compare RNA-seq results with other experimental data Learning objectives Quantify transcript expression from FASTQ files Import quantification into R/Bioconductor Perform quality control and exploratory data analysis Perform differential expression Overlap with other experimental data Build dynamic reports Integrate DESeq2 and zinbwave for single-cell RNA-seq data 2.2 Preparing data for DESeq2 2.2.1 Experimental data The data used in this workflow is stored in the airway package that summarizes an RNA-seq experiment wherein airway smooth muscle cells were treated with dexamethasone, a synthetic glucocorticoid steroid with anti-inflammatory effects (Himes et al. 2014). Glucocorticoids are used, for example, by people with asthma to reduce inflammation of the airways. In the experiment, four primary human airway smooth muscle cell lines were treated with 1 micromolar dexamethasone for 18 hours. For each of the four cell lines, we have a treated and an untreated sample. For more description of the experiment see the PubMed entry 24926665 and for raw data see the GEO entry GSE52778. We will show how to import RNA-seq quantification data using an alternative dataset (the tximportData package which is used in the tximport vignette). Afterward we will load counts for the airway dataset, which were counted using summarizeOverlaps from the GenomicAlignments package. As described below, we recommend the tximport pipeline for producing count matrices, but we do not yet have a Bioconductor package containing the necessary quantification files for the airway dataset. 2.2.2 Modeling count data As input, the count-based statistical methods, such as DESeq2 (Love, Huber, and Anders 2014), edgeR (Robinson, McCarthy, and Smyth 2009), limma with the voom method (Law et al. 2014), DSS (Wu, Wang, and Wu 2013), EBSeq (Leng et al. 2013) and baySeq (Hardcastle and Kelly 2010), expect input data as obtained, e.g., from RNA-seq or another high-throughput sequencing experiment, in the form of a matrix of counts. The value in the i-th row and the j-th column of the matrix tells how many reads (or fragments, for paired-end RNA-seq) have been assigned to gene i in sample j. Analogously, for other types of assays, the rows of the matrix might correspond e.g., to binding regions (with ChIP-Seq), species of bacteria (with metagenomic datasets), or peptide sequences (with quantitative mass spectrometry). The values in the matrix should be counts of sequencing reads/fragments. This is important for the statistical models used by DESeq2 and edgeR to hold, as only counts allow assessing the measurement precision correctly. It is important to not provide counts that were pre-normalized for sequencing depth (also called library size), as the statistical model is most powerful when applied to un-normalized counts and is designed to account for library size differences internally. 2.2.3 Transcript abundances In this workflow, we will show how to use transcript abundances as quantified by the Salmon (Patro et al. 2017) software package. Salmon and other methods, such as Sailfish (Patro, Mount, and Kingsford 2014), kallisto (Bray et al. 2016), or RSEM (Bo Li and Dewey 2011), estimate the relative abundances of all (known, annotated) transcripts without aligning reads. Because estimating the abundance of the transcripts involves an inference step, the counts are estimated. Most methods either use a statistical framework called Estimation-Maximization or Bayesian techniques to estimate the abundances and counts. Following quantification, we will use the tximport (Soneson, Love, and Robinson 2015) package for assembling estimated count and offset matrices for use with Bioconductor differential gene expression packages. The advantages of using the transcript abundance quantifiers in conjunction with tximport to produce gene-level count matrices and normalizing offsets, are: this approach corrects for any potential changes in gene length across samples (e.g. from differential isoform usage) (Trapnell et al. 2013) some of these methods are substantially faster and require less memory and less disk usage compared to alignment-based methods it is possible to avoid discarding those fragments that can align to multiple genes with homologous sequence (Robert and Watson 2015). Note that transcript abundance quantifiers skip the generation of large files which store read alignments (SAM or BAM files), instead producing smaller files which store estimated abundances, counts and effective lengths per transcript. For more details, see the manuscript describing this approach (Soneson, Love, and Robinson 2015) and the tximport package vignette for software details. A full tutorial on how to use the Salmon software for quantifying transcript abundance can be found here. 2.2.4 Salmon quantification We begin by providing Salmon with the sequence of all of the reference transcripts, which we will call the reference transcriptome. We recommend to use the GENCODE human transcripts, which can be downloaded from the GENCODE website. On the command line, creating the transcriptome index looks like: salmon index -i gencode.v99_salmon_0.10.0 -t gencode.v99.transcripts.fa.gz The 0.10.0 refers to the version of Salmon that was used, and is useful to put into the index name. To quantify an individual sample, sample_01, the following command can be used: salmon quant -i gencode.v99_salmon_0.10.0 -p 6 --libType A \\ --gcBias --biasSpeedSamp 5 \\ -1 sample_01_1.fastq.gz -2 sample_01_2.fastq.gz \\ -o sample_01 In simple English, this command says to “quantify a sample using this transcriptome index, with 6 threads, using automatic library type detection, using GC bias correction (the bias speed part is now longer needed with current versions of Salmon), here are the first and second read, and use this output directory.” The output directory will be created if it doesn’t exist, though if earlier parts of the path do not exist, it will give an error. A single sample of human RNA-seq usually takes ~5 minutes with the GC bias correction. Rather than writing the above command on the command line multiple times for each sample, it is possible to loop over files using a bash loop, or more advanced workflow management systems such as Snakemake (Köster and Rahmann 2012) or Nextflow (Di Tommaso et al. 2017). 2.3 Importing into R with tximport 2.3.1 Specifying file locations Following quantification, we can use tximport to import the data into R and perform statistical analysis using Bioconductor packages. Normally, we would simply point tximport to the quant.sf files on our machine. However, because we are distributing these files as part of an R package, we have to do some extra steps, to figure out where the R package, and so the files, are located on your machine. We will show how to import Salmon quantification files using the data in the tximportData package. The quantified samples are six samples from the GEUVADIS Project (Lappalainen et al. 2013). The output directories from the above Salmon quantification calls has been stored in the extdata directory of the tximportData package. The R function system.file can be used to find out where on your computer the files from a package have been installed. Here we ask for the full path to the extdata directory, where R packages store external data, that is part of the tximportData package. library(&quot;tximportData&quot;) dir &lt;- system.file(&quot;extdata&quot;, package=&quot;tximportData&quot;) list.files(dir) #&gt; [1] &quot;cufflinks&quot; &quot;derivedTxome&quot; #&gt; [3] &quot;kallisto&quot; &quot;kallisto_boot&quot; #&gt; [5] &quot;rsem&quot; &quot;sailfish&quot; #&gt; [7] &quot;salmon&quot; &quot;salmon_gibbs&quot; #&gt; [9] &quot;samples_extended.txt&quot; &quot;samples.txt&quot; #&gt; [11] &quot;tx2gene.csv&quot; &quot;tx2gene.gencode.v27.csv&quot; The Salmon quantification directories are in the salmon directory. list.files(file.path(dir,&quot;salmon&quot;)) #&gt; [1] &quot;ERR188021&quot; &quot;ERR188088&quot; &quot;ERR188288&quot; &quot;ERR188297&quot; &quot;ERR188329&quot; &quot;ERR188356&quot; The identifiers used here are the ERR identifiers from the European Nucleotide Archive. We need to create a named vector pointing to the quantification files. We will create a vector of filenames first by reading in a table that contains the sample IDs, and then combining this with dir and &quot;quant.sf.gz&quot;. (We gzipped the quantification files to make the data package smaller, this is not a problem for R functions that we use to import the files.) samples &lt;- read.table(file.path(dir,&quot;samples.txt&quot;), header=TRUE) samples #&gt; pop center assay sample experiment run #&gt; 1 TSI UNIGE NA20503.1.M_111124_5 ERS185497 ERX163094 ERR188297 #&gt; 2 TSI UNIGE NA20504.1.M_111124_7 ERS185242 ERX162972 ERR188088 #&gt; 3 TSI UNIGE NA20505.1.M_111124_6 ERS185048 ERX163009 ERR188329 #&gt; 4 TSI UNIGE NA20507.1.M_111124_7 ERS185412 ERX163158 ERR188288 #&gt; 5 TSI UNIGE NA20508.1.M_111124_2 ERS185362 ERX163159 ERR188021 #&gt; 6 TSI UNIGE NA20514.1.M_111124_4 ERS185217 ERX163062 ERR188356 files &lt;- file.path(dir, &quot;salmon&quot;, samples$run, &quot;quant.sf.gz&quot;) names(files) &lt;- paste0(&quot;sample&quot;,1:6) all(file.exists(files)) #&gt; [1] TRUE 2.3.2 Mapping transcripts to genes Transcripts need to be associated with gene IDs for gene-level summarization. We therefore will construct a data.frame called tx2gene with two columns: 1) transcript ID and 2) gene ID. The column names do not matter but this column order must be used. The transcript ID must be the same one used in the abundance files. This can most easily be accomplished by downloading the GTF file at the same time that the transcriptome FASTA is downloaded, and generating tx2gene from the GTF file using Bioconductor’s TxDb infrastructure. Generating a TxDb from a GTF file can be easily accomplished with the makeTxDbFromGFF function. This step requires a few minutes of waiting, and a large file. We therefore skip this step, but show the code that is used to create the tx2gene table, assuming the correct TxDb object has been created. Creating the tx2gene data.frame can be accomplished by calling the select function from the AnnotationDbi package on a TxDb object. The following code could be used to construct such a table: library(&quot;TxDb.Hsapiens.UCSC.hg38.knownGene&quot;) #&gt; Loading required package: GenomicFeatures #&gt; Loading required package: BiocGenerics #&gt; Loading required package: parallel #&gt; #&gt; Attaching package: &#39;BiocGenerics&#39; #&gt; The following objects are masked from &#39;package:parallel&#39;: #&gt; #&gt; clusterApply, clusterApplyLB, clusterCall, clusterEvalQ, #&gt; clusterExport, clusterMap, parApply, parCapply, parLapply, #&gt; parLapplyLB, parRapply, parSapply, parSapplyLB #&gt; The following objects are masked from &#39;package:stats&#39;: #&gt; #&gt; IQR, mad, sd, var, xtabs #&gt; The following objects are masked from &#39;package:base&#39;: #&gt; #&gt; anyDuplicated, append, as.data.frame, basename, cbind, #&gt; colMeans, colnames, colSums, dirname, do.call, duplicated, #&gt; eval, evalq, Filter, Find, get, grep, grepl, intersect, #&gt; is.unsorted, lapply, lengths, Map, mapply, match, mget, order, #&gt; paste, pmax, pmax.int, pmin, pmin.int, Position, rank, rbind, #&gt; Reduce, rowMeans, rownames, rowSums, sapply, setdiff, sort, #&gt; table, tapply, union, unique, unsplit, which, which.max, #&gt; which.min #&gt; Loading required package: S4Vectors #&gt; Loading required package: stats4 #&gt; #&gt; Attaching package: &#39;S4Vectors&#39; #&gt; The following object is masked from &#39;package:base&#39;: #&gt; #&gt; expand.grid #&gt; Loading required package: IRanges #&gt; Loading required package: GenomeInfoDb #&gt; Loading required package: GenomicRanges #&gt; Loading required package: AnnotationDbi #&gt; Loading required package: Biobase #&gt; Welcome to Bioconductor #&gt; #&gt; Vignettes contain introductory material; view with #&gt; &#39;browseVignettes()&#39;. To cite Bioconductor, see #&gt; &#39;citation(&quot;Biobase&quot;)&#39;, and for packages &#39;citation(&quot;pkgname&quot;)&#39;. txdb &lt;- TxDb.Hsapiens.UCSC.hg38.knownGene k &lt;- keys(txdb, keytype=&quot;TXNAME&quot;) tx2gene &lt;- select(txdb, k, &quot;GENEID&quot;, &quot;TXNAME&quot;) #&gt; &#39;select()&#39; returned 1:1 mapping between keys and columns In this case, we’ve used the Gencode v27 CHR transcripts to build our Salmon index, and we used makeTxDbFromGFF and code similar to the chunk above to build the tx2gene table. We then read in a pre-constructed tx2gene table: library(&quot;readr&quot;) tx2gene &lt;- read_csv(file.path(dir, &quot;tx2gene.gencode.v27.csv&quot;)) #&gt; Parsed with column specification: #&gt; cols( #&gt; TXNAME = col_character(), #&gt; GENEID = col_character() #&gt; ) head(tx2gene) #&gt; # A tibble: 6 x 2 #&gt; TXNAME GENEID #&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 ENST00000456328.2 ENSG00000223972.5 #&gt; 2 ENST00000450305.2 ENSG00000223972.5 #&gt; 3 ENST00000473358.1 ENSG00000243485.5 #&gt; 4 ENST00000469289.1 ENSG00000243485.5 #&gt; 5 ENST00000607096.1 ENSG00000284332.1 #&gt; 6 ENST00000606857.1 ENSG00000268020.3 2.3.3 tximport command Finally the following line of code imports Salmon transcript quantifications into R, collapsing to the gene level using the information in tx2gene. library(&quot;tximport&quot;) library(&quot;jsonlite&quot;) library(&quot;readr&quot;) txi &lt;- tximport(files, type=&quot;salmon&quot;, tx2gene=tx2gene) #&gt; reading in files with read_tsv #&gt; 1 2 3 4 5 6 #&gt; summarizing abundance #&gt; summarizing counts #&gt; summarizing length The txi object is simply a list of matrices (and one character vector): names(txi) #&gt; [1] &quot;abundance&quot; &quot;counts&quot; &quot;length&quot; #&gt; [4] &quot;countsFromAbundance&quot; txi$counts[1:3,1:3] #&gt; sample1 sample2 sample3 #&gt; ENSG00000000003.14 2.58012 2.000 27.09648 #&gt; ENSG00000000005.5 0.00000 0.000 0.00000 #&gt; ENSG00000000419.12 1056.99960 1337.997 1452.99497 txi$length[1:3,1:3] #&gt; sample1 sample2 sample3 #&gt; ENSG00000000003.14 3621.7000 735.4220 2201.6223 #&gt; ENSG00000000005.5 195.6667 195.6667 195.6667 #&gt; ENSG00000000419.12 871.5077 905.0540 845.7278 txi$abundance[1:3,1:3] #&gt; sample1 sample2 sample3 #&gt; ENSG00000000003.14 0.0354884 0.119404 0.411491 #&gt; ENSG00000000005.5 0.0000000 0.000000 0.000000 #&gt; ENSG00000000419.12 60.4173800 64.909276 57.441353 txi$countsFromAbundance #&gt; [1] &quot;no&quot; If we were continuing with the GEUVADIS samples, we would then create a DESeqDataSet with the following line of code. Because there are no differences among the samples (same population and same sequencing batch), we specify a design formula of ~1, meaning we can only fit an intercept term – so we cannot perform differential expression analysis with these samples. library(&quot;DESeq2&quot;) #&gt; Loading required package: SummarizedExperiment #&gt; Loading required package: DelayedArray #&gt; Loading required package: matrixStats #&gt; #&gt; Attaching package: &#39;matrixStats&#39; #&gt; The following objects are masked from &#39;package:Biobase&#39;: #&gt; #&gt; anyMissing, rowMedians #&gt; Loading required package: BiocParallel #&gt; #&gt; Attaching package: &#39;DelayedArray&#39; #&gt; The following objects are masked from &#39;package:matrixStats&#39;: #&gt; #&gt; colMaxs, colMins, colRanges, rowMaxs, rowMins, rowRanges #&gt; The following objects are masked from &#39;package:base&#39;: #&gt; #&gt; aperm, apply dds &lt;- DESeqDataSetFromTximport(txi, samples, ~1) #&gt; using counts and average transcript lengths from tximport dds$center #&gt; [1] UNIGE UNIGE UNIGE UNIGE UNIGE UNIGE #&gt; Levels: UNIGE dds$pop #&gt; [1] TSI TSI TSI TSI TSI TSI #&gt; Levels: TSI 2.4 Exploratory data analysis 2.4.1 Simple EDA We will now switch over to the airway experiment, counts of which are already prepared in a SummarizedExperiment object. In this case, the object that we load is the output of the summarizeOverlaps function in the GenomicAlignments package, and the exact code used to produce this object can be seen by typing vignette(&quot;airway&quot;) into the R session, to pull up the airway software vignette. There are multiple ways to produce a count table and import it into DESeq2, and these are summarized in this section of the RNA-seq gene-level workflow. library(&quot;airway&quot;) data(&quot;airway&quot;) We want to specify that untrt is the reference level for the dex variable: airway$dex &lt;- relevel(airway$dex, &quot;untrt&quot;) airway$dex #&gt; [1] untrt trt untrt trt untrt trt untrt trt #&gt; Levels: untrt trt We can quickly check the millions of fragments that uniquely aligned to the genes (the second argument of round tells how many decimal points to keep). round( colSums(assay(airway)) / 1e6, 1 ) #&gt; SRR1039508 SRR1039509 SRR1039512 SRR1039513 SRR1039516 SRR1039517 #&gt; 20.6 18.8 25.3 15.2 24.4 30.8 #&gt; SRR1039520 SRR1039521 #&gt; 19.1 21.2 We can inspect the information about the samples, by pulling out the colData slot of the SummarizedExperiment: colData(airway) #&gt; DataFrame with 8 rows and 9 columns #&gt; SampleName cell dex albut Run avgLength #&gt; &lt;factor&gt; &lt;factor&gt; &lt;factor&gt; &lt;factor&gt; &lt;factor&gt; &lt;integer&gt; #&gt; SRR1039508 GSM1275862 N61311 untrt untrt SRR1039508 126 #&gt; SRR1039509 GSM1275863 N61311 trt untrt SRR1039509 126 #&gt; SRR1039512 GSM1275866 N052611 untrt untrt SRR1039512 126 #&gt; SRR1039513 GSM1275867 N052611 trt untrt SRR1039513 87 #&gt; SRR1039516 GSM1275870 N080611 untrt untrt SRR1039516 120 #&gt; SRR1039517 GSM1275871 N080611 trt untrt SRR1039517 126 #&gt; SRR1039520 GSM1275874 N061011 untrt untrt SRR1039520 101 #&gt; SRR1039521 GSM1275875 N061011 trt untrt SRR1039521 98 #&gt; Experiment Sample BioSample #&gt; &lt;factor&gt; &lt;factor&gt; &lt;factor&gt; #&gt; SRR1039508 SRX384345 SRS508568 SAMN02422669 #&gt; SRR1039509 SRX384346 SRS508567 SAMN02422675 #&gt; SRR1039512 SRX384349 SRS508571 SAMN02422678 #&gt; SRR1039513 SRX384350 SRS508572 SAMN02422670 #&gt; SRR1039516 SRX384353 SRS508575 SAMN02422682 #&gt; SRR1039517 SRX384354 SRS508576 SAMN02422673 #&gt; SRR1039520 SRX384357 SRS508579 SAMN02422683 #&gt; SRR1039521 SRX384358 SRS508580 SAMN02422677 table(airway$cell) #&gt; #&gt; N052611 N061011 N080611 N61311 #&gt; 2 2 2 2 table(airway$dex) #&gt; #&gt; untrt trt #&gt; 4 4 If we had not already loaded DESeq2, we would do this, and then create a DESeqDataSet. We want to control for the cell line, while testing for differences across dexamethasone treatment, so we use a design of ~ cell + dex: library(&quot;DESeq2&quot;) dds &lt;- DESeqDataSet(airway, design = ~ cell + dex) We will perform a minimal filtering to reduce the size of the dataset. We do not need to retain genes if they do not have a count of 5 or more for 4 or more samples as these genes will have no statistical power to detect differences, and no information to compute distances between samples. keep &lt;- rowSums(counts(dds) &gt;= 5) &gt;= 4 table(keep) #&gt; keep #&gt; FALSE TRUE #&gt; 46070 18032 dds &lt;- dds[keep,] Some very basic exploratory analysis is to examine a boxplot of the counts for each sample. We will take the logarithm so that large counts do not dominate the boxplot: boxplot(log10(counts(dds)+1)) The main function in DESeq2 involves computation of size factors which normalize for differences in sequencing depth among samples. We can also compute these size factors manually, so that the normalized counts are available for plotting: dds &lt;- estimateSizeFactors(dds) boxplot(log10(counts(dds,normalized=TRUE)+1)) 2.4.2 Data transformation for EDA Taking the logarithm of counts plus a pseudocount of 1 is a common transformation, but it tends to inflate the sampling variance of low counts such that it is even larger than biological variation across groups of samples. In DESeq2 we therefore provide transformations which produce log-scale data such that the systematic trends have been removed. Our recommended transformation is the variance-stabilizing transformation, or VST, and it can be called with the vst function: vsd &lt;- vst(dds) class(vsd) #&gt; [1] &quot;DESeqTransform&quot; #&gt; attr(,&quot;package&quot;) #&gt; [1] &quot;DESeq2&quot; This function does not return a DESeqDataSet, because it does not return counts, but instead continuous values (on the log2 scale). We can access the transformed data with assay: assay(vsd)[1:3,1:3] #&gt; SRR1039508 SRR1039509 SRR1039512 #&gt; ENSG00000000003 9.456925 9.074623 9.608160 #&gt; ENSG00000000419 8.952752 9.262092 9.145782 #&gt; ENSG00000000457 8.193711 8.098664 8.032656 2.4.3 Principal components plot The VST data is appropriate for calculating distances between samples or for performing PCA. More information about PCA and distance calculation can be found in the RNA-seq gene-level workflow. In short, PCA plots allow us to visualize the most dominant axes of variation in our data, which is useful for both quality control, and to get a sense of how large the inter-sample differences are across and within conditions. Here we see that PC1 (the primary axis of variation in the data) separates the treated and untreated samples: plotPCA(vsd, &quot;dex&quot;) With some additional ggplot2 code, we can also indicate which samples belong to which cell line: library(&quot;ggplot2&quot;) pcaData &lt;- plotPCA(vsd, intgroup = c( &quot;dex&quot;, &quot;cell&quot;), returnData = TRUE) percentVar &lt;- round(100 * attr(pcaData, &quot;percentVar&quot;)) ggplot(pcaData, aes(x = PC1, y = PC2, color = dex, shape = cell)) + geom_point(size =3) + xlab(paste0(&quot;PC1: &quot;, percentVar[1], &quot;% variance&quot;)) + ylab(paste0(&quot;PC2: &quot;, percentVar[2], &quot;% variance&quot;)) + coord_fixed() Note that we do not recommend working with the transformed data for the primary differential expression analysis. Instead we will use the original counts and a generalized linear model (GLM) which takes into account the expected variance from either low or high counts. For statistical details, please refer to the DESeq2 methods paper (Love, Huber, and Anders 2014). 2.5 Differential expression analysis 2.5.1 Standard DE steps Differential expression analysis in DESeq2 is performed by calling the following two functions: dds &lt;- DESeq(dds) #&gt; using pre-existing size factors #&gt; estimating dispersions #&gt; gene-wise dispersion estimates #&gt; mean-dispersion relationship #&gt; final dispersion estimates #&gt; fitting model and testing res &lt;- results(dds) The results table res contains the results for each gene (in the same order as in the DESeqDataSet). If we want to see the top genes, we can order it like so: head(res[order(res$pvalue),]) #&gt; log2 fold change (MLE): dex trt vs untrt #&gt; Wald test p-value: dex trt vs untrt #&gt; DataFrame with 6 rows and 6 columns #&gt; baseMean log2FoldChange lfcSE #&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; #&gt; ENSG00000152583 997.522193389904 4.57431721934494 0.183934560931089 #&gt; ENSG00000165995 495.289924523775 3.29060376160862 0.132397954572965 #&gt; ENSG00000120129 3409.85238036378 2.94725094348016 0.122471899817052 #&gt; ENSG00000101347 12707.320121355 3.7664043884955 0.156934450326662 #&gt; ENSG00000189221 2342.17328482568 3.35311264853444 0.142537730315705 #&gt; ENSG00000211445 12292.1234547129 3.72983474166181 0.167361554620974 #&gt; stat pvalue #&gt; &lt;numeric&gt; &lt;numeric&gt; #&gt; ENSG00000152583 24.8692643524384 1.60060793892601e-136 #&gt; ENSG00000165995 24.853886695018 2.34741061794036e-136 #&gt; ENSG00000120129 24.0647115614501 5.85598005614604e-128 #&gt; ENSG00000101347 23.9998571419828 2.79035129961566e-127 #&gt; ENSG00000189221 23.5243864281245 2.2964743349727e-122 #&gt; ENSG00000211445 22.2860904352187 5.04142773173702e-110 #&gt; padj #&gt; &lt;numeric&gt; #&gt; ENSG00000152583 2.03426604150712e-132 #&gt; ENSG00000165995 2.03426604150712e-132 #&gt; ENSG00000120129 3.38319487777077e-124 #&gt; ENSG00000101347 1.20905921812347e-123 #&gt; ENSG00000189221 7.96049863474937e-119 #&gt; ENSG00000211445 1.45630042410777e-106 We can plot the counts for the top gene using plotCounts: plotCounts(dds, which.min(res$pvalue), &quot;dex&quot;) We can examine all the log2 fold changes (LFC) due to dexamethasone treatment over the mean of counts using plotMA: plotMA(res, ylim=c(-5,5)) Note that there are many large LFC which are not significant (grey points) on the left side of the MA-plot above. These obtain a large LFC because of the imprecision of log counts. For more informative visualization and more accurate ranking of genes by effect size (the log fold change may sometimes be referred to as an effect size), we recommend to use DESeq2’s functionality for shrinking LFCs. Our most recent methodological development is the apeglm shrinkage estimator, which is available in DESeq2’s lfcShrink function: library(&quot;apeglm&quot;) resultsNames(dds) #&gt; [1] &quot;Intercept&quot; &quot;cell_N061011_vs_N052611&quot; #&gt; [3] &quot;cell_N080611_vs_N052611&quot; &quot;cell_N61311_vs_N052611&quot; #&gt; [5] &quot;dex_trt_vs_untrt&quot; res2 &lt;- lfcShrink(dds, coef=&quot;dex_trt_vs_untrt&quot;, type=&quot;apeglm&quot;) #&gt; using &#39;apeglm&#39; for LFC shrinkage. If used in published research, please cite: #&gt; Zhu, A., Ibrahim, J.G., Love, M.I. (2018) Heavy-tailed prior distributions for #&gt; sequence count data: removing the noise and preserving large differences. #&gt; bioRxiv. https://doi.org/10.1101/303255 par(mfrow=c(1,2)) plotMA(res, ylim=c(-3,3), main=&quot;No shrinkage&quot;) plotMA(res2, ylim=c(-3,3), main=&quot;apeglm&quot;) 2.5.2 Minimum effect size If we don’t want to report as significant genes with small LFC, we can specify a minimum biologically meaningful effect size, by choosing an LFC and testing against this. We can either perform such a threshold test using the unshrunken LFCs or the LFCs provided by lfcShrink using the apeglm method: res.lfc &lt;- results(dds, lfcThreshold=1) res.lfc2 &lt;- lfcShrink(dds, coef=&quot;dex_trt_vs_untrt&quot;, type=&quot;apeglm&quot;, lfcThreshold=1) #&gt; using &#39;apeglm&#39; for LFC shrinkage. If used in published research, please cite: #&gt; Zhu, A., Ibrahim, J.G., Love, M.I. (2018) Heavy-tailed prior distributions for #&gt; sequence count data: removing the noise and preserving large differences. #&gt; bioRxiv. https://doi.org/10.1101/303255 #&gt; computing FSOS &#39;false sign or small&#39; s-values (T=1) Note that testing against an LFC threshold is not equivalent to testing against a null hypothesis of 0 and then filtering on LFC values. We prefer the former, as discussed in Love, Huber, and Anders (2014) and Zhu, Ibrahim, and Love (2018). The apeglm method provides s-values (Stephens 2016) when svalue=TRUE or when we supply a minimum effect size as above. These are analogous to q-values or adjusted p-values, in that the genes with s-values less than \\(\\alpha\\) should have an aggregate rate of false sign or being smaller in absolute value than our given LFC threshold, which is bounded by \\(\\alpha\\). par(mfrow=c(1,2)) plotMA(res.lfc, ylim=c(-5,5), main=&quot;No shrinkage, LFC test&quot;) plotMA(res.lfc2, ylim=c(-5,5), main=&quot;apeglm, LFC test&quot;, alpha=0.01) 2.6 AnnotationHub 2.6.1 Querying AnnotationHub We will use the AnnotationHub package to attach additional information to the results table. AnnotationHub provides an easy-to-use interface to more than 40,000 annotation records. A record may be peaks from a ChIP-seq experiment from ENCODE, the sequence of the human genome, a TxDb containing information about transcripts and genes, or an OrgDb containing general information about biological identifiers for a particular organism. library(&quot;AnnotationHub&quot;) #&gt; #&gt; Attaching package: &#39;AnnotationHub&#39; #&gt; The following object is masked from &#39;package:Biobase&#39;: #&gt; #&gt; cache ah &lt;- AnnotationHub() #&gt; updating metadata: #&gt; retrieving 1 resource #&gt; snapshotDate(): 2018-06-27 The following code chunk, un-evaluated here, launches a browser for navigating all the records available through AnnotationHub. display(ah) We can also query using keywords with the query function: query(ah, c(&quot;OrgDb&quot;,&quot;Homo sapiens&quot;)) #&gt; AnnotationHub with 1 record #&gt; # snapshotDate(): 2018-06-27 #&gt; # names(): AH61777 #&gt; # $dataprovider: ftp://ftp.ncbi.nlm.nih.gov/gene/DATA/ #&gt; # $species: Homo sapiens #&gt; # $rdataclass: OrgDb #&gt; # $rdatadateadded: 2018-04-19 #&gt; # $title: org.Hs.eg.db.sqlite #&gt; # $description: NCBI gene ID based annotations about Homo sapiens #&gt; # $taxonomyid: 9606 #&gt; # $genome: NCBI genomes #&gt; # $sourcetype: NCBI/ensembl #&gt; # $sourceurl: ftp://ftp.ncbi.nlm.nih.gov/gene/DATA/, ftp://ftp.ensembl.... #&gt; # $sourcesize: NA #&gt; # $tags: c(&quot;NCBI&quot;, &quot;Gene&quot;, &quot;Annotation&quot;) #&gt; # retrieve record with &#39;object[[&quot;AH61777&quot;]]&#39; To pull down a particular record we use double brackets and the name of the record: hs &lt;- ah[[&quot;AH61777&quot;]] #&gt; downloading 1 resources #&gt; retrieving 1 resource #&gt; loading from cache #&gt; &#39;/home/mramos//.AnnotationHub/68523&#39; hs #&gt; OrgDb object: #&gt; | DBSCHEMAVERSION: 2.1 #&gt; | Db type: OrgDb #&gt; | Supporting package: AnnotationDbi #&gt; | DBSCHEMA: HUMAN_DB #&gt; | ORGANISM: Homo sapiens #&gt; | SPECIES: Human #&gt; | EGSOURCEDATE: 2018-Apr4 #&gt; | EGSOURCENAME: Entrez Gene #&gt; | EGSOURCEURL: ftp://ftp.ncbi.nlm.nih.gov/gene/DATA #&gt; | CENTRALID: EG #&gt; | TAXID: 9606 #&gt; | GOSOURCENAME: Gene Ontology #&gt; | GOSOURCEURL: ftp://ftp.geneontology.org/pub/go/godatabase/archive/latest-lite/ #&gt; | GOSOURCEDATE: 2018-Mar28 #&gt; | GOEGSOURCEDATE: 2018-Apr4 #&gt; | GOEGSOURCENAME: Entrez Gene #&gt; | GOEGSOURCEURL: ftp://ftp.ncbi.nlm.nih.gov/gene/DATA #&gt; | KEGGSOURCENAME: KEGG GENOME #&gt; | KEGGSOURCEURL: ftp://ftp.genome.jp/pub/kegg/genomes #&gt; | KEGGSOURCEDATE: 2011-Mar15 #&gt; | GPSOURCENAME: UCSC Genome Bioinformatics (Homo sapiens) #&gt; | GPSOURCEURL: #&gt; | GPSOURCEDATE: 2018-Mar26 #&gt; | ENSOURCEDATE: 2017-Dec04 #&gt; | ENSOURCENAME: Ensembl #&gt; | ENSOURCEURL: ftp://ftp.ensembl.org/pub/current_fasta #&gt; | UPSOURCENAME: Uniprot #&gt; | UPSOURCEURL: http://www.UniProt.org/ #&gt; | UPSOURCEDATE: Mon Apr 9 20:58:54 2018 #&gt; #&gt; Please see: help(&#39;select&#39;) for usage information 2.6.2 Mapping IDs The rownames of the results table are Ensembl IDs, and most of these are entries in OrgDb (although thousands are not). columns(hs) #&gt; [1] &quot;ACCNUM&quot; &quot;ALIAS&quot; &quot;ENSEMBL&quot; &quot;ENSEMBLPROT&quot; #&gt; [5] &quot;ENSEMBLTRANS&quot; &quot;ENTREZID&quot; &quot;ENZYME&quot; &quot;EVIDENCE&quot; #&gt; [9] &quot;EVIDENCEALL&quot; &quot;GENENAME&quot; &quot;GO&quot; &quot;GOALL&quot; #&gt; [13] &quot;IPI&quot; &quot;MAP&quot; &quot;OMIM&quot; &quot;ONTOLOGY&quot; #&gt; [17] &quot;ONTOLOGYALL&quot; &quot;PATH&quot; &quot;PFAM&quot; &quot;PMID&quot; #&gt; [21] &quot;PROSITE&quot; &quot;REFSEQ&quot; &quot;SYMBOL&quot; &quot;UCSCKG&quot; #&gt; [25] &quot;UNIGENE&quot; &quot;UNIPROT&quot; table(rownames(res) %in% keys(hs, &quot;ENSEMBL&quot;)) #&gt; #&gt; FALSE TRUE #&gt; 3492 14540 We can use the mapIds function to add gene symbols, using ENSEMBL as the keytype, and requesting the column SYMBOL. res$symbol &lt;- mapIds(hs, rownames(res), column=&quot;SYMBOL&quot;, keytype=&quot;ENSEMBL&quot;) #&gt; &#39;select()&#39; returned 1:many mapping between keys and columns head(res) #&gt; log2 fold change (MLE): dex trt vs untrt #&gt; Wald test p-value: dex trt vs untrt #&gt; DataFrame with 6 rows and 7 columns #&gt; baseMean log2FoldChange lfcSE #&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; #&gt; ENSG00000000003 708.84032163709 -0.38188890052585 0.100800595908449 #&gt; ENSG00000000419 520.444343803335 0.206203578138288 0.111340654960802 #&gt; ENSG00000000457 237.237392013978 0.0373231179429298 0.140524882321204 #&gt; ENSG00000000460 57.9518862998956 -0.0907678445557818 0.276878121334175 #&gt; ENSG00000000971 5819.01711439455 0.425781621579506 0.0897314693828554 #&gt; ENSG00000001036 1282.59042750161 -0.241675199658759 0.0898743244338321 #&gt; stat pvalue padj #&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; #&gt; ENSG00000000003 -3.78855796519988 0.000151524241731238 0.00121584173966936 #&gt; ENSG00000000419 1.85200615364516 0.0640249392675146 0.184546856375281 #&gt; ENSG00000000457 0.265597930604338 0.790548879512378 0.903592643032674 #&gt; ENSG00000000460 -0.32782599115598 0.743043234238656 0.878207188857688 #&gt; ENSG00000000971 4.74506463014478 2.08439772491752e-06 2.5495258552061e-05 #&gt; ENSG00000001036 -2.68903495165281 0.00716589158352556 0.0334768821902062 #&gt; symbol #&gt; &lt;character&gt; #&gt; ENSG00000000003 TSPAN6 #&gt; ENSG00000000419 DPM1 #&gt; ENSG00000000457 SCYL3 #&gt; ENSG00000000460 C1orf112 #&gt; ENSG00000000971 CFH #&gt; ENSG00000001036 FUCA2 2.7 Building reports 2.7.1 ReportingTools There are many packages for building interactive reports from Bioconductor. Two of these are ReportingTools and Glimma, which both provide HTML reports that allow for collaborators to examine the top genes (or whatever features of interest) from a genomic analysis. The code for compiling a ReportingTools report is: library(&quot;ReportingTools&quot;) #&gt; Loading required package: knitr #&gt; #&gt; tmp &lt;- tempdir() # you would instead use a meaningful path here rep &lt;- HTMLReport(shortName=&quot;airway&quot;, title=&quot;Airway DGE&quot;, basePath=tmp, reportDirectory=&quot;report&quot;) publish(res, rep, dds, n=20, make.plots=TRUE, factor=dds$dex) finish(rep) #&gt; [1] &quot;/tmp/Rtmp6XF6Fj/report/airway.html&quot; This last line, un-evaluated would launch the report in a web browser: browseURL(file.path(tmp,&quot;report&quot;,&quot;airway.html&quot;)) 2.7.2 Glimma Another package which can generate interactive reports is Glimma. The glMDPlot constructs an interactive MA-plot where hovering over a gene in the MA-plot on the left side will display the counts for the samples on the right hand side. Clicking will bring up the gene’s information in a tooltip and in a list at the bottom of the screen. Hovering on a sample on the right hand side will give the sample ID in a tooltip. library(&quot;Glimma&quot;) status &lt;- as.numeric(res$padj &lt; .1) anno &lt;- data.frame(GeneID=rownames(res), symbol=res$symbol) glMDPlot(res2, status=status, counts=counts(dds,normalized=TRUE), groups=dds$dex, transform=FALSE, samples=colnames(dds), anno=anno, path=tmp, folder=&quot;glimma&quot;, launch=FALSE) This last line would launch the report in a web browser: browseURL(file.path(tmp,&quot;glimma&quot;,&quot;MD-Plot.html&quot;)) 2.8 Integration with ZINB-WaVE 2.8.1 Simulate with splatter In this last section, we show that DESeq2 can be integrated with another Bioconductor package zinbwave (Risso et al. 2018) in order to model and account for additional zeros (more than expected by the Negative Binomial model). This can be useful for single cell RNA-seq experiments. Here we use the splatter package to simulate single-cell RNA-seq data (Zappia, Phipson, and Oshlack 2017). We then use the methods defined in Van den Berge et al. (2018) to combine zinbwave observation weights with DESeq2 modeling of negative binomial counts. From Van den Berge et al. (2018): It is important to note that while methods such as ZINB-WaVE and ZINGER can successfully identify excess zeros, they cannot, however, readily discriminate between their underlying causes, i.e., between technical (e.g., dropout) and biological (e.g., bursting) zeros. The above note implies that the zero-inflation weighting approach outlined below can be used when the interesting signal is not in the zero component. That is, if you wanted to find biological differences in transcriptional bursting across groups of cells, the below approach would not help you find these differences. It instead helps to uncover differences in counts besides the zero component (whether those zeros be biological or technical). 2.8.2 Simulate single-cell count data with splatter The following chunks of code create a splatter simulation: library(&quot;splatter&quot;) #&gt; Loading required package: SingleCellExperiment params &lt;- newSplatParams() params &lt;- setParam(params, &quot;de.facLoc&quot;, 1) params &lt;- setParam(params, &quot;de.facScale&quot;, .25) params &lt;- setParam(params, &quot;dropout.type&quot;, &quot;experiment&quot;) params &lt;- setParam(params, &quot;dropout.mid&quot;, 3) set.seed(1) sim &lt;- splatSimulate(params, group.prob=c(.5,.5), method=&quot;groups&quot;) #&gt; Getting parameters... #&gt; Creating simulation object... #&gt; Simulating library sizes... #&gt; Simulating gene means... #&gt; Simulating group DE... #&gt; Simulating cell means... #&gt; Simulating BCV... #&gt; Simulating counts... #&gt; Simulating dropout (if needed)... #&gt; Done! We can plot the amount of dropouts over the true counts: plot(log10(rowMeans(assays(sim)[[&quot;TrueCounts&quot;]])), rowMeans(assays(sim)[[&quot;Dropout&quot;]])) We will store the true log2 fold change for comparison: rowData(sim)$log2FC &lt;- with(rowData(sim), log2(DEFacGroup2/DEFacGroup1)) The true dispersion for the Negative Binomial component, over the mean: rowData(sim)$trueDisp &lt;- rowMeans(assays(sim)[[&quot;BCV&quot;]])^2 gridlines &lt;- c(1e-2,1e-1,1); cols &lt;- c(&quot;blue&quot;,&quot;red&quot;,&quot;darkgreen&quot;) with(rowData(sim)[rowData(sim)$GeneMean&gt; 1,], plot(GeneMean, trueDisp, log=&quot;xy&quot;, xlim=c(1,300), ylim=c(.01,5))) abline(h=gridlines, col=cols) text(300, gridlines, labels=gridlines, col=cols, pos=3) 2.8.3 Model zeros with zinbwave The following code subsets the dataset and creates a condition variable that we will use to test for differential expression: library(zinbwave) keep &lt;- rowSums(counts(sim) &gt;= 5) &gt;= 25 table(keep) #&gt; keep #&gt; FALSE TRUE #&gt; 9025 975 zinb &lt;- sim[keep,] zinb$condition &lt;- factor(zinb$Group) We need to re-arrange the assays in the zinb object such that &quot;counts&quot; is the first assay: nms &lt;- c(&quot;counts&quot;, setdiff(assayNames(zinb), &quot;counts&quot;)) assays(zinb) &lt;- assays(zinb)[nms] Finally we fit the ZINB-WaVE model. See ?zinbwave and the zinbwave vignette for more details, including options on parallelization. It runs in less than a minute on this simulated dataset (with not so many cells). zinb &lt;- zinbwave(zinb, K=0, BPPARAM=SerialParam(), epsilon=1e12) 2.8.4 Model non-zeros with DESeq2 Now we import the zinb object using DESeqDataSet (which works because the SingleCellExperiment object builds on top of the SummarizedExperiment). All of the simulation information comes along in the metadata columns of the object. Van den Berge et al. (2018) and others have shown the LRT may perform better for null hypothesis testing, so we use the LRT. In order to use the Wald test, it is recommended to set useT=TRUE. zdds &lt;- DESeqDataSet(zinb, design=~condition) zdds &lt;- DESeq(zdds, test=&quot;LRT&quot;, reduced=~1, sfType=&quot;poscounts&quot;, minmu=1e-6, minRep=Inf) #&gt; estimating size factors #&gt; estimating dispersions #&gt; gene-wise dispersion estimates #&gt; mean-dispersion relationship #&gt; final dispersion estimates #&gt; fitting model and testing 2.8.5 Plot dispersion estimates It is recommended to plot the dispersion estimates for DESeq2 on single-cell data. As discussed in the DESeq2 paper, it becomes difficult to accurately estimate the dispersion when the counts are very small, because the Poisson component of the variance is dominant. Therefore we see some very low dispersion estimates here, although the trend is still accurately capturing the upper proportion. So here everything looks good. plotDispEsts(zdds) If the parametric trend fails to fit (there would be a warning in this case), one should check the dispersion plot as above. If it looks like the dispersion fit is being thrown off by the low count genes with low dispersion estimates at the bottom of the plot, there is a relatively easy solution: one can filter out more of the low count genes only for the dispersion estimation step, so that the trend still captures the upper portion. This is pretty easy to do in DESeq2, to filter genes solely for the dispersion trend estimation, but to use a larger set for the rest of the analysis. An example of how this can be done: keepForDispTrend &lt;- rowSums(counts(zdds) &gt;= 10) &gt;= 25 zdds2 &lt;- estimateDispersionsFit(zdds[keepForDispTrend,]) plotDispEsts(zdds2) One would then assign the dispersion function to the original dataset, re-estimate final dispersions, check plotDispEsts, and then either re-run the Wald or LRT function: dispersionFunction(zdds) &lt;- dispersionFunction(zdds2) zdds &lt;- estimateDispersionsMAP(zdds) #&gt; found already estimated dispersions, removing these zdds &lt;- nbinomLRT(zdds, reduced=~1, minmu=1e-6) #&gt; found results columns, replacing these 2.8.6 Evaluation against truth Compare dispersion on the non-zero-component counts to the true value used for simulation. with(mcols(zdds), plot(trueDisp, dispMAP, log=&quot;xy&quot;)) abline(0,1,col=&quot;red&quot;) Extract results table: zres &lt;- results(zdds, independentFiltering=FALSE) plot(mcols(zdds)$log2FC, zres$log2FoldChange, ylim=c(-4,4)); abline(0,1,col=&quot;red&quot;) Below we show that the “simple” LFC does not work - it over-estimates the true DE LFC because of the dropout zeros in the group with the smaller mean. It also has a lot of noise for the null genes. ncts &lt;- counts(zdds, normalized=TRUE) simple.lfc &lt;- log2(rowMeans(ncts[,zdds$condition == &quot;Group2&quot;])/ rowMeans(ncts[,zdds$condition == &quot;Group1&quot;])) plot(mcols(zdds)$log2FC, simple.lfc, ylim=c(-4,4)); abline(0,1,col=&quot;red&quot;) How well do we do in null hypothesis testing: tab &lt;- table(sig=zres$padj &lt; .05, DE.status=mcols(zdds)$log2FC != 0) tab #&gt; DE.status #&gt; sig FALSE TRUE #&gt; FALSE 727 22 #&gt; TRUE 8 218 round(prop.table(tab, 1), 3) #&gt; DE.status #&gt; sig FALSE TRUE #&gt; FALSE 0.971 0.029 #&gt; TRUE 0.035 0.965 UNC-Chapel Hill, NC, US↩ ZMBH Heidelberg, Germany↩ EMBL Heidelberg, Germany↩ "],
["cytoscape-automation-in-r-using-rcy3.html", "3 Cytoscape Automation in R using Rcy3 3.1 Overview 3.2 Background 3.3 Translating biological data into Cytoscape using RCy3 3.4 References", " 3 Cytoscape Automation in R using Rcy3 3.1 Overview 3.1.1 Instructor(s) name(s) and contact information Ruth Isserlin - ruth dot isserlin (at) utoronto (dot) ca Brendan Innes - brendan (dot) innes (at) mail (dot) utoronto (dot) ca Jeff Wong - jvwong (at) gmail (dot) com Gary Bader - gary (dot) bader (at) utoronto (dot) ca 3.1.2 Workshop Description Cytoscape(www.cytoscape.org) is one of the most popular applications for network analysis and visualization. In this workshop, we will demonstrate new capabilities to integrate Cytoscape into programmatic workflows and pipelines using R. We will begin with an overview of network biology themes and concepts, and then we will translate these into Cytoscape terms for practical applications. The bulk of the workshop will be a hands-on demonstration of accessing and controlling Cytoscape from R to perform a network analysis of tumor expression data. 3.1.3 Workshop prerequisites: Basic knowledge of R syntax Basic knowledge of Cytoscape software Familiarity with network biology concepts 3.1.4 Background: “How to visually interpret biological data using networks.” Merico D, Gfeller D, Bader GD. Nature Biotechnology 2009 Oct 27, 921-924 - http://baderlab.org/Publications?action=AttachFile&amp;do=view&amp;target=2009_Merico_Primer_NatBiotech_Oct.pdf “CyREST: Turbocharging Cytoscape Access for External Tools via a RESTful API”. Keiichiro Ono, Tanja Muetze, Georgi Kolishovski, Paul Shannon, Barry Demchak.F1000Res. 2015 Aug 5;4:478. - https://f1000research.com/articles/4-478/v1 3.1.5 Workshop Participation Participants are required to bring a laptop with Cytoscape, R, and RStudio installed. Installation instructions will be provided in the weeks preceding the workshop. The workshop will consist of a lecture and lab. 3.1.6 R / Bioconductor packages used RCy3 gProfileR RCurl EnrichmentBrowser 3.1.7 Time outline Activity Time Introduction 15m Driving Cytoscape from R 15m Creating, retrieving and manipulating networks 15m Summary 10m 3.1.8 Workshop goals and objectives Learning goals Know when and how to use Cytoscape in your research area Generalize network analysis methods to multiple problem domains Integrate Cytoscape into your bioinformatics pipelines Learning objectives Programmatic control over Cytoscape from R Publish, share and export networks 3.2 Background 3.2.1 Cytoscape Cytoscape(Shannon et al. 2003) is a freely available open-source, cross platform network analysis software. Cytoscape(Shannon et al. 2003) can visualize complex networks and help integrate them with any other data type. Cytoscape(Shannon et al. 2003) has an active developer and user base with more than 300 community created apps available from the (Cytoscape App Store)[apps.cytoscape.org]. Check out some of the tasks you can do with Cytoscape in our online tutorial guide - tutorials.cytoscape.org Figure 3.1: Available Cytoscape Apps 3.2.2 Overview of network biology themes and concepts 3.2.2.1 Why Networks? Networks are everywhere… Molecular Networks Cell-Cell communication Networks Computer networks Social Networks Internet Networks are powerful tools… Reduce complexity More efficient than tables Great for data integration Intuitive visualization Often data in our pipelines are represented as data.frames, tables, matrices, vectors or lists. Sometimes we represent this data as heatmaps, or plots in efforts to summarize the results visually. Network visualization offers an additional method that readily incorporates many different data types and variables into a single picture. Figure 3.2: Translating data to networks In order to translate your data into a network it is important to define the entities and their relationships. Entities and relationships can be anything. They can be user defined or they can be queried from a database. Examples of Networks and their associated entities: Protein - Protein interaction network - is a directed or undirected network where nodes in the network are proteins or genes and edges represent how those proteins interact. Gene - gene interaction network - nodes in the network are genes and edges can represent synthetic lethality i.e. two genes have a connection if deleting both of them cause a decrease in fitness. Coexpression network - nodes in the network are genes or proteins and edges represent the degree of co-expression the two genes have. Often the edges are associated with a correlation score (i.e. pearson correlation) and edges are filtered by a defined threshold. If no threshold is specified all genes will be connected to all other genes creating a hairball. Enrichment Map - nodes in the networks are groups of genes from pathways or functions (i.e. genesets) and edges represent pathway crosstalk ( genes in common). Social network - nodes in the network are individuals and edges are some sort of social interaction between two individuals, for example, friends on Facebook, linked in LinkedIN, … Copublication network - a specialization of the social network for research purposes. Nodes in the network are individuals and edges between any two individuals for those who have co-authored a publication together. 3.2.3 Networks as Tools Networks can be used for two main purposes but often go hand in hand. Analysis Topological properties - including number of nodes, number of edges, node degree, average clustering coefficients, shortest path lengths, density, and many more. Topological properties can help gain insights into the structure and organization of the resulting biological networks as well as help highlight specific node or regions of the network. Hubs and subnetworks - a hub is generally a highly connected node in a scale-free network. Removal of hubs cause rapid breakdown of the underlying network. Subnetworks are interconnected regions of the network and can be defined by any user defined parameter. Cluster, classify, and diffuse Data integration Visualization Data overlays Layouts and animation Exploratory analysis Context and interpretation 3.3 Translating biological data into Cytoscape using RCy3 Networks offer us a useful way to represent our biological data. But how do we seamlessly translate our data from R into Cytoscape? Figure 3.3: Different ways to communicate with Cytoscape There are multiple ways to communicate with Cytoscape programmatically. There are two main complementary portals,cyRest(Ono et al. 2015) and Commands, that form the foundation. cyRest transforms Cytoscape in to a REST (Representational State Transfer) enabled service where it essentially listens for events through a predefined port (by default port 1234). The cyRest functionality started as an app add in but has now been incorporated into the main release. Commands, on the other hand, offer a mechanism whereby app developers can expose their functionality to other apps or to user through the command interface. Prior to the implementation of cyRest many of the basic network functions were first available as commands so there is some overlap between the two different methods. 3.3 shows the different ways you can call Cytoscape. 3.3.1 Set up In order to create networks in Cytoscape from R you need: RCy3 - a biocondutor package if(!&quot;RCy3&quot; %in% installed.packages()){ install.packages(&quot;BiocManager&quot;) BiocManager::install(&quot;RCy3&quot;) } library(RCy3) Cytoscape - Download and install Cytoscape 3.6.1. or higher. Java 9 in not supported. Please make sure that Java 8 is installed. Install additional cytoscape apps that will be used in this workshop. If using cytoscape 3.6.1 or older the apps need to manually installed through the app manager in Cytoscape or through your web browser. (click on the method to see detailed instructions) Functional Enrichment Collection -a collection of apps to retrieve networks and pathways, integrate and explore the data, perform functional enrichment analysis, and interpret and display your results. EnrichmentMap Pipeline Collection - a collection of apps including EnrichmentMap, AutoAnnotate, WordCloud and clusterMaker2 used to visualize and analysis enrichment results. If you are using Cytoscape 3.7 or higher (Cytoscape 3.7 will be released in August 2018) then apps can be installed directly from R. #list of cytoscape apps to install installation_responses &lt;- c() #list of app to install cyto_app_toinstall &lt;- c(&quot;clustermaker2&quot;, &quot;enrichmentmap&quot;, &quot;autoannotate&quot;, &quot;wordcloud&quot;, &quot;stringapp&quot;, &quot;aMatReader&quot;) cytoscape_version &lt;- unlist(strsplit( cytoscapeVersionInfo()[&#39;cytoscapeVersion&#39;],split = &quot;\\\\.&quot;)) if(length(cytoscape_version) == 3 &amp;&amp; as.numeric(cytoscape_version[1]&gt;=3) &amp;&amp; as.numeric(cytoscape_version[2]&gt;=7)){ for(i in 1:length(cyto_app_toinstall)){ #check to see if the app is installed. Only install it if it hasn&#39;t been installed if(!grep(commandsGET(paste(&quot;apps status app=\\&quot;&quot;, cyto_app_toinstall[i],&quot;\\&quot;&quot;, sep=&quot;&quot;)), pattern = &quot;status: Installed&quot;)){ installation_response &lt;-commandsGET(paste(&quot;apps install app=\\&quot;&quot;, cyto_app_toinstall[i],&quot;\\&quot;&quot;, sep=&quot;&quot;)) installation_responses &lt;- c(installation_responses,installation_response) } else{ installation_responses &lt;- c(installation_responses,&quot;already installed&quot;) } } installation_summary &lt;- data.frame(name = cyto_app_toinstall, status = installation_responses) knitr::kable(list(installation_summary), booktabs = TRUE, caption = &#39;A Summary of automated app installation&#39; ) } Make sure that Cytoscape is open cytoscapePing () 3.3.2 Getting started 3.3.2.1 Confirm that Cytoscape is installed and opened cytoscapeVersionInfo () 3.3.2.2 Browse available functions, commands and arguments Depending on what apps you have installed there is different functionality available. To see all the functions available in RCy3 package help(package=RCy3) Open swagger docs for live instances of CyREST API. The CyREST API list all the functions available in a base distribution of cytoscape. The below command will launch the swagger documentation in a web browser. Functions are clustered into categories. Expanding individual categories will show all the option available. Further expanding an individual command will show detailed documentation for the function, input, outputs and allow you to try and run the function. Running the function will show the url used for the query and all returned responses. cyrestAPI() # CyREST API As mentioned above, there are two ways to interact with Cytoscape, through the Cyrest API or commands. To see the available commands in swagger similar to the Cyrest API. commandsAPI() # Commands API To get information about an individual command from the R environment you can also use the commandsHelp function. Simply specify what command you would like to get information on by adding its name to the command. For example “commandsHelp(”help string“)” commandsHelp(&quot;help&quot;) 3.3.3 Cytoscape Basics Create a Cytoscape network from some basic R objects nodes &lt;- data.frame(id=c(&quot;node 0&quot;,&quot;node 1&quot;,&quot;node 2&quot;,&quot;node 3&quot;), group=c(&quot;A&quot;,&quot;A&quot;,&quot;B&quot;,&quot;B&quot;), # categorical strings score=as.integer(c(20,10,15,5)), # integers stringsAsFactors=FALSE) edges &lt;- data.frame(source=c(&quot;node 0&quot;,&quot;node 0&quot;,&quot;node 0&quot;,&quot;node 2&quot;), target=c(&quot;node 1&quot;,&quot;node 2&quot;,&quot;node 3&quot;,&quot;node 3&quot;), interaction=c(&quot;inhibits&quot;,&quot;interacts&quot;,&quot;activates&quot;,&quot;interacts&quot;), # optional weight=c(5.1,3.0,5.2,9.9), # numeric stringsAsFactors=FALSE) Table 3.1: A table of example nodes and edges. id group score node 0 A 20 node 1 A 10 node 2 B 15 node 3 B 5 source target interaction weight node 0 node 1 inhibits 5.1 node 0 node 2 interacts 3.0 node 0 node 3 activates 5.2 node 2 node 3 interacts 9.9 createNetworkFromDataFrames(nodes,edges, title=&quot;my first network&quot;, collection=&quot;DataFrame Example&quot;) Remember. All networks we make are created in Cytoscape so get an image of the resulting network and include it in your current analysis if desired. initial_network_png_file_name &lt;- file.path(getwd(),&quot;230_Isserlin_RCy3_intro&quot;, &quot;images&quot;,&quot;initial_example_network.png&quot;) if(file.exists(initial_network_png_file_name)){ #cytoscape hangs waiting for user response if file alreayd exists. Remove it first file.remove(initial_network_png_file_name) } #export the network exportImage(initial_network_png_file_name, type = &quot;png&quot;) Figure 3.4: Example network created from dataframe 3.3.4 Example Data Set We downloaded gene expression data from the Ovarian Serous Cystadenocarcinoma project of The Cancer Genome Atlas (TCGA)(International Cancer Genome et al. 2010), http://cancergenome.nih.gov via the Genomic Data Commons (GDC) portal(Grossman et al. 2016) on 2017-06-14 using TCGABiolinks R package(Colaprico et al. 2016). The data includes 300 samples available as RNA-seq data, with reads mapped to a reference genome using MapSplice(Wang et al. 2010) and read counts per transcript determined using the RSEM method(B. Li and Dewey 2011). RNA-seq data are labeled as ‘RNA-Seq V2’, see details at: https://wiki.nci.nih.gov/display/TCGA/RNASeq+Version+2). The RNA-SeqV2 data consists of raw counts similar to regular RNA-seq but RSEM (RNA-Seq by Expectation Maximization) data can be used with the edgeR method. The expression dataset of 300 tumours, with 79 classified as Immunoreactive, 72 classified as Mesenchymal, 69 classified as Differentiated, and 80 classified as Proliferative samples(class definitions were obtained from Verhaak et al.(Verhaak et al. 2013) Supplementary Table 1, third column). RNA-seq read counts were converted to CPM values and genes with CPM &gt; 1 in at least 50 of the samples are retained for further study (50 is the minimal sample size in the classes). The data was normalized and differential expression was calculated for each cancer class relative to the rest of the samples. There are two data files: 1. Expression matrix - containing the normalized expression for each gene across all 300 samples. 1. Gene ranks - containing the p-values, FDR and foldchange values for the 4 comparisons (mesenchymal vs rest, differential vs rest, proliferative vs rest and immunoreactive vs rest) RNASeq_expression_matrix &lt;- read.table( file.path(getwd(),&quot;230_Isserlin_RCy3_intro&quot;,&quot;data&quot;,&quot;TCGA_OV_RNAseq_expression.txt&quot;), header = TRUE, sep = &quot;\\t&quot;, quote=&quot;\\&quot;&quot;, stringsAsFactors = FALSE) RNASeq_gene_scores &lt;- read.table( file.path(getwd(),&quot;230_Isserlin_RCy3_intro&quot;,&quot;data&quot;,&quot;TCGA_OV_RNAseq_All_edgeR_scores.txt&quot;), header = TRUE, sep = &quot;\\t&quot;, quote=&quot;\\&quot;&quot;, stringsAsFactors = FALSE) 3.3.5 Finding Network Data How do I represent my data as a network? Unfortunately, there is not a simple answer. It depends on your biological question! Example use cases: Omics data - I have a fill in the blank (microarray, RNASeq, Proteomics, ATACseq, MicroRNA, GWAS …) dataset. I have normalized and scored my data. How do I overlay my data on existing interaction data? Coexpression data - I have a dataset that represents relationships. How do I represent it as a network. Omics data - I have a fill in the blank (microarray, RNASeq, Proteomics, ATACseq, MicroRNA, GWAS …) dataset. I have normalized and scored my data. I have run my data through a functional enrichment tool and now have a set of enriched terms associated with my dataset. How do I represent my functional enrichments as a network? 3.3.6 Use Case 1 - How are my top genes related? Omics data - I have a fill in the blank (microarray, RNASeq, Proteomics, ATACseq, MicroRNA, GWAS …) dataset. I have normalized and scored my data. How do I overlay my data on existing interaction data? There are endless amounts of databases storing interaction data. Figure 3.5: Info graphic of some of the available pathway databases Thankfully we don’t have to query each independent ally. In addition to many specialized (for example, for specific molecules, interaction type, or species) interaction databases there are also databases that collate these databases to create a broad resource that is easier to use. For example: StringApp - is a protein - protein and protein- chemical database that imports data from String(Szklarczyk et al. 2016) (which itself includes data from multiple species, coexpression, text-mining,existing databases, and genomic context), [STITCH] into a unified, queriable database. PSICQUIC(Aranda et al. 2011) - a REST-ful service that is the responsibility of the database provider to set up and maintain. PSICQUIC is an additional interface that allows users to search all available databases (that support this REST-ful service). The databases are required to represent their interaction data in Proteomic Standards Initiative - molecular interaction (PSI-MI) format. To see a list of all the available data source see here nDex(Pratt et al. 2017) - a network data exchange repository. GeneMANIA(Mostafavi et al. 2008) - contains multiple networks (shared domains, physical interactions, pathways, predicted, co-expression, genetic interactions and co-localized network). Given a set of genes GeneMANIA selects and weights networks that optimize the connectivity between the query genes. GeneMANIA will also return additional genes that are highly related to your query set. Get a subset of genes of interest from our scored data: top_mesenchymal_genes &lt;- RNASeq_gene_scores[which(RNASeq_gene_scores$FDR.mesen &lt; 0.05 &amp; RNASeq_gene_scores$logFC.mesen &gt; 2),] head(top_mesenchymal_genes) #&gt; Name geneid logFC.mesen logCPM.mesen LR.mesen PValue.mesen #&gt; 188 PRG4 10216 2.705305 2.6139056 95.58179 1.42e-22 #&gt; 252 PROK1 84432 2.543381 1.3255202 68.31067 1.40e-16 #&gt; 308 PRRX1 5396 2.077538 4.8570983 123.09925 1.33e-28 #&gt; 434 PTGFR 5737 2.075707 -0.1960881 73.24646 1.14e-17 #&gt; 438 PTGIS 5740 2.094198 5.8279714 165.11038 8.65e-38 #&gt; 1214 BARX1 56033 3.267472 1.7427387 166.30064 4.76e-38 #&gt; FDR.mesen logFC.diff logCPM.diff LR.diff PValue.diff FDR.diff #&gt; 188 7.34e-21 -1.2716521 2.6139056 14.107056 1.726950e-04 1.181751e-03 #&gt; 252 4.77e-15 0.7455119 1.3255202 5.105528 2.384972e-02 6.549953e-02 #&gt; 308 1.08e-26 -1.2367108 4.8570983 29.949104 4.440000e-08 1.250000e-06 #&gt; 434 4.30e-16 -0.4233297 -0.1960881 2.318523 1.278413e-01 2.368387e-01 #&gt; 438 1.20e-35 -0.4448761 5.8279714 5.696086 1.700278e-02 5.027140e-02 #&gt; 1214 6.82e-36 -2.4411370 1.7427387 52.224346 4.950000e-13 6.970000e-11 #&gt; Row.names.y logFC.immuno logCPM.immuno LR.immuno PValue.immuno #&gt; 188 PRG4|10216 -0.4980017 2.6139056 2.651951 0.103422901 #&gt; 252 PROK1|84432 -1.9692994 1.3255202 27.876348 0.000000129 #&gt; 308 PRRX1|5396 -0.4914091 4.8570983 5.773502 0.016269586 #&gt; 434 PTGFR|5737 -0.6737143 -0.1960881 6.289647 0.012144523 #&gt; 438 PTGIS|5740 -0.6138074 5.8279714 11.708780 0.000622059 #&gt; 1214 BARX1|56033 -0.6063633 1.7427387 4.577141 0.032401228 #&gt; FDR.immuno logFC.prolif logCPM.prolif LR.prolif PValue.prolif #&gt; 188 0.185548905 -0.9356510 2.6139056 8.9562066 0.0027652850 #&gt; 252 0.000001650 -1.3195933 1.3255202 13.7675841 0.0002068750 #&gt; 308 0.042062023 -0.3494185 4.8570983 2.9943819 0.0835537930 #&gt; 434 0.033197211 -0.9786631 -0.1960881 12.9112727 0.0003266090 #&gt; 438 0.002779895 -1.0355143 5.8279714 31.9162051 0.0000000161 #&gt; 1214 0.073565295 -0.2199714 1.7427387 0.6315171 0.4267993850 #&gt; FDR.prolif #&gt; 188 0.006372597 #&gt; 252 0.000622057 #&gt; 308 0.128528698 #&gt; 434 0.000932503 #&gt; 438 0.000000107 #&gt; 1214 0.510856262 We are going to query the String Database to get all interactions found for our set of top Mesenchymal genes. Reminder: to see the parameters required by the string function or to find the right string function you can use commandsHelp. commandsHelp(&quot;help string&quot;) commandsHelp(&quot;help string protein query&quot;) mesen_string_interaction_cmd &lt;- paste(&#39;string protein query taxonID=9606 limit=150 cutoff=0.9 query=&quot;&#39;,paste(top_mesenchymal_genes$Name, collapse=&quot;,&quot;),&#39;&quot;&#39;,sep=&quot;&quot;) commandsGET(mesen_string_interaction_cmd) Get a screenshot of the initial network initial_string_network_png_file_name &lt;- file.path(getwd(),&quot;230_Isserlin_RCy3_intro&quot;, &quot;images&quot;, &quot;initial_string_network.png&quot;) if(file.exists(initial_string_network_png_file_name)){ #cytoscape hangs waiting for user response if file alreayd exists. Remove it first response &lt;- file.remove(initial_string_network_png_file_name) } response &lt;- exportImage(initial_string_network_png_file_name, type = &quot;png&quot;) Figure 3.6: Initial network returned by String from our set of Mesenchymal query genes Layout the network layoutNetwork(&#39;force-directed&#39;) Check what other layout algorithms are available to try out getLayoutNames() Get the parameters for a specific layout getLayoutPropertyNames(layout.name=&#39;force-directed&#39;) Re-layout the network using the force directed layout but specify some of the parameters layoutNetwork(&#39;force-directed defaultSpringCoefficient=0.0000008 defaultSpringLength=70&#39;) Get a screenshot of the re-laid out network relayout_string_network_png_file_name &lt;- file.path(getwd(),&quot;230_Isserlin_RCy3_intro&quot;, &quot;images&quot;,&quot;relayout_string_network.png&quot;) if(file.exists(relayout_string_network_png_file_name)){ #cytoscape hangs waiting for user response if file alreayd exists. Remove it first response&lt;- file.remove(relayout_string_network_png_file_name) } response &lt;- exportImage(relayout_string_network_png_file_name, type = &quot;png&quot;) Figure 3.7: Initial network returned by String from our set of Mesenchymal query genes Overlay our expression data on the String network. To do this we will be using the loadTableData function from RCy3. It is important to make sure that that your identifiers types match up. You can check what is used by String by pulling in the column names of the node attribute table. getTableColumnNames(&#39;node&#39;) If you are unsure of what each column is and want to further verify the column to use you can also pull in the entire node attribute table. node_attribute_table_topmesen &lt;- getTableColumns(table=&quot;node&quot;) head(node_attribute_table_topmesen[,3:7]) The column “display name” contains HGNC gene names which are also found in our Ovarian Cancer dataset. To import our expression data we will match our dataset to the “display name” node attribute. ?loadTableData loadTableData(RNASeq_gene_scores,table.key.column = &quot;display name&quot;,data.key.column = &quot;Name&quot;) #default data.frame key is row.names Modify the Visual Style Create your own visual style to visualize your expression data on the String network. Start with a default style style.name = &quot;MesenchymalStyle&quot; defaults.list &lt;- list(NODE_SHAPE=&quot;ellipse&quot;, NODE_SIZE=60, NODE_FILL_COLOR=&quot;#AAAAAA&quot;, EDGE_TRANSPARENCY=120) node.label.map &lt;- mapVisualProperty(&#39;node label&#39;,&#39;display name&#39;,&#39;p&#39;) # p for passthrough; nothing else needed createVisualStyle(style.name, defaults.list, list(node.label.map)) setVisualStyle(style.name=style.name) Update your created style with a mapping for the Mesenchymal logFC expression. The first step is to grab the column data from Cytoscape (we can reuse the node_attribute table concept from above but we have to call the function again as we have since added our expression data) and pull out the min and max to define our data mapping range of values. Note: you could define the min and max based on the entire dataset or just the subset that is represented in Cytoscape currently. The two methods will give you different results. If you intend on comparing different networks created with the same dataset then it is best to calculate the min and max from the entire dataset as opposed to a subset. min.mesen.logfc = min(RNASeq_gene_scores$logFC.mesen,na.rm=TRUE) max.mesen.logfc = max(RNASeq_gene_scores$logFC.mesen,na.rm=TRUE) data.values = c(min.mesen.logfc,0,max.mesen.logfc) Next, we use the RColorBrewer package to help us pick good colors to pair with our data values. library(RColorBrewer) display.brewer.all(length(data.values), colorblindFriendly=TRUE, type=&quot;div&quot;) # div,qual,seq,all node.colors &lt;- c(rev(brewer.pal(length(data.values), &quot;RdBu&quot;))) Map the colors to our data value and update our visual style. setNodeColorMapping(&quot;logFC.mesen&quot;, data.values, node.colors, style.name=style.name) Remember, String includes your query proteins as well as other proteins that associate with your query proteins (including the strongest connection first). Not all of the proteins in this network are your top hits. How can we visualize which proteins are our top Mesenchymal hits? Add a different border color or change the node shape for our top hits. getNodeShapes() #select the Nodes of interest #selectNode(nodes = top_mesenchymal_genes$Name, by.col=&quot;display name&quot;) setNodeShapeBypass(node.names = top_mesenchymal_genes$Name, new.shapes = &quot;TRIANGLE&quot;) Change the size of the node to be correlated with the Mesenchymal p-value. setNodeSizeMapping(table.column = &#39;LR.mesen&#39;, table.column.values = c(min(RNASeq_gene_scores$LR.mesen), mean(RNASeq_gene_scores$LR.mesen), max(RNASeq_gene_scores$LR.mesen)), sizes = c(30, 60, 150),mapping.type = &quot;c&quot;, style.name = style.name) Get a screenshot of the resulting network mesen_string_network_png_file_name &lt;- file.path(getwd(),&quot;230_Isserlin_RCy3_intro&quot;, &quot;images&quot;,&quot;mesen_string_network.png&quot;) if(file.exists(mesen_string_network_png_file_name)){ #cytoscape hangs waiting for user response if file alreayd exists. Remove it first response&lt;- file.remove(mesen_string_network_png_file_name) } response &lt;- exportImage(mesen_string_network_png_file_name, type = &quot;png&quot;) Figure 3.8: Formatted String network from our set of Mesenchymal query genes. Annotated with our expressin data 3.3.7 Use Case 2 - Which genes have similar expression. Instead of querying existing resources look for correlations in your own dataset to find out which genes have similar expression. There are many tools that can analyze your data for correlation. A popular tool is Weighted Gene Correlation Network Analysis (WGCNA)(Langfelder and Horvath 2008) which takes expression data and calculates functional modules. As a simple example we can transform our expression dataset into a correlation matrix. Using the Cytoscape App, aMatReader(Settle et al. 2018), we transform our adjacency matrix into an interaction network. First we filter the correlation matrix to contain only the strongest connections (for example, only correlations greater than 0.9). RNASeq_expression &lt;- RNASeq_expression_matrix[,3:ncol(RNASeq_expression_matrix)] rownames(RNASeq_expression) &lt;- RNASeq_expression_matrix$Name RNAseq_correlation_matrix &lt;- cor(t(RNASeq_expression), method=&quot;pearson&quot;) #set the diagonal of matrix to zero - eliminate self-correlation RNAseq_correlation_matrix[ row(RNAseq_correlation_matrix) == col(RNAseq_correlation_matrix) ] &lt;- 0 # set all correlations that are less than 0.9 to zero RNAseq_correlation_matrix[which(RNAseq_correlation_matrix&lt;0.90)] &lt;- 0 #get rid of rows and columns that have no correlations with the above thresholds RNAseq_correlation_matrix &lt;- RNAseq_correlation_matrix[which(rowSums(RNAseq_correlation_matrix) != 0), which(colSums(RNAseq_correlation_matrix) !=0)] #write out the correlation file correlation_filename &lt;- file.path(getwd(), &quot;230_Isserlin_RCy3_intro&quot;, &quot;data&quot;, &quot;TCGA_OV_RNAseq_expression_correlation_matrix.txt&quot;) write.table( RNAseq_correlation_matrix, file = correlation_filename, col.names = TRUE, row.names = FALSE, sep = &quot;\\t&quot;, quote=FALSE) Use the CyRest call to access the aMatReader functionality. amat_url &lt;- &quot;aMatReader/v1/import&quot; amat_params = list(files = list(correlation_filename), delimiter = &quot;TAB&quot;, undirected = FALSE, ignoreZeros = TRUE, interactionName = &quot;correlated with&quot;, rowNames = FALSE ) response &lt;- cyrestPOST(operation = amat_url, body = amat_params, base.url = &quot;http://localhost:1234&quot;) current_network_id &lt;- response$data[&quot;suid&quot;] #relayout network layoutNetwork(&#39;cose&#39;, network = as.numeric(current_network_id)) renameNetwork(title = &quot;Coexpression_network_pear0_95&quot;, network = as.numeric(current_network_id)) Modify the visualization to see where each genes is predominantly expressed. Look at the 4 different p-values associated with each gene and color the nodes with the type associated with the lowest FDR. Load in the scoring data. Specify the cancer type where the genes has the lowest FDR value. nodes_in_network &lt;- rownames(RNAseq_correlation_matrix) #add an additional column to the gene scores table to indicate in which samples # the gene is significant node_class &lt;- vector(length = length(nodes_in_network),mode = &quot;character&quot;) for(i in 1:length(nodes_in_network)){ current_row &lt;- which(RNASeq_gene_scores$Name == nodes_in_network[i]) min_pvalue &lt;- min(RNASeq_gene_scores[current_row, grep(colnames(RNASeq_gene_scores), pattern = &quot;FDR&quot;)]) if(RNASeq_gene_scores$FDR.mesen[current_row] &lt;=min_pvalue){ node_class[i] &lt;- paste(node_class[i],&quot;mesen&quot;,sep = &quot; &quot;) } if(RNASeq_gene_scores$FDR.diff[current_row] &lt;=min_pvalue){ node_class[i] &lt;- paste(node_class[i],&quot;diff&quot;,sep = &quot; &quot;) } if(RNASeq_gene_scores$FDR.prolif[current_row] &lt;=min_pvalue){ node_class[i] &lt;- paste(node_class[i],&quot;prolif&quot;,sep = &quot; &quot;) } if(RNASeq_gene_scores$FDR.immuno[current_row] &lt;=min_pvalue){ node_class[i] &lt;- paste(node_class[i],&quot;immuno&quot;,sep = &quot; &quot;) } } node_class &lt;- trimws(node_class) node_class_df &lt;-data.frame(name=nodes_in_network, node_class,stringsAsFactors = FALSE) head(node_class_df) #&gt; name node_class #&gt; 1 ABCA6 mesen #&gt; 2 ABCA8 mesen #&gt; 3 ABI3 immuno #&gt; 4 ACAN prolif #&gt; 5 ACAP1 immuno #&gt; 6 ADAM12 mesen Map the new node attribute and the all the gene scores to the network. loadTableData(RNASeq_gene_scores,table.key.column = &quot;name&quot;,data.key.column = &quot;Name&quot;) #default data.frame key is row.names loadTableData(node_class_df,table.key.column = &quot;name&quot;,data.key.column = &quot;name&quot;) #default data.frame key is row.names Create a color mapping for the different cancer types. #create a new mapping with the different types unique_types &lt;- sort(unique(node_class)) coul = brewer.pal(4, &quot;Set1&quot;) # I can add more tones to this palette : coul = colorRampPalette(coul)(length(unique_types)) setNodeColorMapping(table.column = &quot;node_class&quot;,table.column.values = unique_types, colors = coul,mapping.type = &quot;d&quot;) correlation_network_png_file_name &lt;- file.path(getwd(),&quot;230_Isserlin_RCy3_intro&quot;, &quot;images&quot;,&quot;correlation_network.png&quot;) if(file.exists(correlation_network_png_file_name)){ #cytoscape hangs waiting for user response if file alreayd exists. Remove it first file.remove(correlation_network_png_file_name) } #export the network exportImage(correlation_network_png_file_name, type = &quot;png&quot;) (#fig:correlation_network2)Example correlation network created using aMatReader cluster the Network #make sure it is set to the right network setCurrentNetwork(network = getNetworkName(suid=as.numeric(current_network_id))) #cluster the network clustermaker_url &lt;- paste(&quot;cluster mcl network=SUID:&quot;,current_network_id, sep=&quot;&quot;) commandsGET(clustermaker_url) #get the clustering results default_node_table &lt;- getTableColumns(table= &quot;node&quot;,network = as.numeric(current_network_id)) head(default_node_table) Perform pathway Enrichment on one of the clusters using g:Profiler(Reimand et al. 2016). g:Profiler is an online functional enrichment web service that will take your gene list and return the set of enriched pathways. For automated analysis g:Profiler has created an R library to interact with it directly from R instead of using the web page. Create a function to call g:Profiler and convert the returned results into a generic enrichment map input file. tryCatch(expr = { library(&quot;gProfileR&quot;)}, error = function(e) { install.packages(&quot;gProfileR&quot;)}, finally = library(&quot;gProfileR&quot;)) #function to run gprofiler using the gprofiler library # # The function takes the returned gprofiler results and formats it to the generic EM input file # # function returns a data frame in the generic EM file format. runGprofiler &lt;- function(genes,current_organism = &quot;hsapiens&quot;, significant_only = F, set_size_max = 200, set_size_min = 3, filter_gs_size_min = 5 , exclude_iea = F){ gprofiler_results &lt;- gprofiler(genes , significant=significant_only,ordered_query = F, exclude_iea=exclude_iea,max_set_size = set_size_max, min_set_size = set_size_min, correction_method = &quot;fdr&quot;, organism = current_organism, src_filter = c(&quot;GO:BP&quot;,&quot;REAC&quot;)) #filter results gprofiler_results &lt;- gprofiler_results[which(gprofiler_results[,&#39;term.size&#39;] &gt;= 3 &amp; gprofiler_results[,&#39;overlap.size&#39;] &gt;= filter_gs_size_min ),] # gProfileR returns corrected p-values only. Set p-value to corrected p-value if(dim(gprofiler_results)[1] &gt; 0){ em_results &lt;- cbind(gprofiler_results[, c(&quot;term.id&quot;,&quot;term.name&quot;,&quot;p.value&quot;,&quot;p.value&quot;)], 1, gprofiler_results[,&quot;intersection&quot;]) colnames(em_results) &lt;- c(&quot;Name&quot;,&quot;Description&quot;, &quot;pvalue&quot;,&quot;qvalue&quot;,&quot;phenotype&quot;,&quot;genes&quot;) return(em_results) } else { return(&quot;no gprofiler results for supplied query&quot;) } } Run g:Profiler. g:Profiler will return a set of pathways and functions that are found to be enriched in our query set of genes. current_cluster &lt;- &quot;1&quot; #select all the nodes in cluster 1 selectednodes &lt;- selectNodes(current_cluster, by.col=&quot;__mclCluster&quot;) #create a subnetwork with cluster 1 subnetwork_suid &lt;- createSubnetwork(nodes=&quot;selected&quot;) renameNetwork(&quot;Cluster1_Subnetwork&quot;, network=as.numeric(subnetwork_suid)) subnetwork_node_table &lt;- getTableColumns(table= &quot;node&quot;,network = as.numeric(subnetwork_suid)) em_results &lt;- runGprofiler(subnetwork_node_table$name) #write out the g:Profiler results em_results_filename &lt;-file.path(getwd(), &quot;230_Isserlin_RCy3_intro&quot;, &quot;data&quot;,paste(&quot;gprofiler_cluster&quot;,current_cluster,&quot;enr_results.txt&quot;,sep=&quot;_&quot;)) write.table(em_results,em_results_filename,col.name=TRUE,sep=&quot;\\t&quot;,row.names=FALSE,quote=FALSE) head(em_results) Create an enrichment map with the returned g:Profiler results. An enrichment map is a different sort of network. Instead of nodes representing genes, nodes represent pathways or functions. Edges between these pathways or functions represent shared genes or pathway crosstalk. An enrichment map is a way to visualize your enrichment results to help reduce redundancy and uncover main themes. Pathways can also be explored in detail using the features available through the App in Cytoscape. em_command = paste(&#39;enrichmentmap build analysisType=&quot;generic&quot; &#39;, &#39;pvalue=&#39;,&quot;0.05&quot;, &#39;qvalue=&#39;,&quot;0.05&quot;, &#39;similaritycutoff=&#39;,&quot;0.25&quot;, &#39;coeffecients=&#39;,&quot;JACCARD&quot;, &#39;enrichmentsDataset1=&#39;,em_results_filename , sep=&quot; &quot;) #enrichment map command will return the suid of newly created network. em_network_suid &lt;- commandsRun(em_command) renameNetwork(&quot;Cluster1_enrichmentmap&quot;, network=as.numeric(em_network_suid)) Export image of resulting Enrichment map. cluster1em_png_file_name &lt;- file.path(getwd(),&quot;230_Isserlin_RCy3_intro&quot;, &quot;images&quot;,&quot;cluster1em.png&quot;) if(file.exists(cluster1em_png_file_name)){ #cytoscape hangs waiting for user response if file alreayd exists. Remove it first file.remove(cluster1em_png_file_name) } #export the network exportImage(cluster1em_png_file_name, type = &quot;png&quot;) (#fig:cluster1em_fig)Example Enrichment Map created when running an enrichment analysis using g:Profiler with the genes that are part of cluster 1 Annotate the Enrichment map to get the general themes that are found in the enrichment results of cluster 1 #get the column from the nodetable and node table nodetable_colnames &lt;- getTableColumnNames(table=&quot;node&quot;, network = as.numeric(em_network_suid)) descr_attrib &lt;- nodetable_colnames[grep(nodetable_colnames, pattern = &quot;_GS_DESCR&quot;)] #Autoannotate the network autoannotate_url &lt;- paste(&quot;autoannotate annotate-clusterBoosted labelColumn=&quot;, descr_attrib,&quot; maxWords=3 &quot;, sep=&quot;&quot;) current_name &lt;-commandsGET(autoannotate_url) Export image of resulting Annotated Enrichment map. cluster1em_annot_png_file_name &lt;- file.path(getwd(),&quot;230_Isserlin_RCy3_intro&quot;, &quot;images&quot;,&quot;cluster1em_annot.png&quot;) if(file.exists(cluster1em_annot_png_file_name)){ #cytoscape hangs waiting for user response if file alreayd exists. Remove it first file.remove(cluster1em_annot_png_file_name) } #export the network exportImage(cluster1em_annot_png_file_name, type = &quot;png&quot;) (#fig:cluster1em_annot_fig)Example Annotated Enrichment Map created when running an enrichment analysis using g:Profiler with the genes that are part of cluster 1 Dense networks small or large never look like network figures we so often see in journals. A lot of manual tweaking, reorganization and optimization is involved in getting that perfect figure ready network. The above network is what the network starts as. The below figure is what it can look like after a few minutes of manual reorganiazation. (individual clusters were selected from the auto annotate panel and separated from other clusters) (#fig:cluster1em_annot_man_fig)Example Annotated Enrichment Map created when running an enrichment analysis using g:Profiler with the genes that are part of cluster 1 after manual adjusting to generate a cleaner figure 3.3.8 Use Case 3 - Functional Enrichment of Omics set. Reducing our large OMICs expression set to a simple list of genes eliminates the majority of the signals present in the data. Thresholding will only highlight the strong signals neglecting the often more interesting subtle signals. In order to capitalize on the wealth of data present in the data we need to perform pathway enrichment analysis on the entire expression set. There are many tools in R or as standalone apps that perform this type of analysis. To demonstrate how you can use Cytoscape and RCy3 in your enrichment analysis pipeline we will use EnrichmentBrowser package (as demonstrated in detail in the workshop Functional enrichment analysis of high-throughput omics data) to perform pathway analysis. if(!&quot;EnrichmentBrowser&quot; %in% installed.packages()){ install.packages(&quot;BiocManager&quot;) BiocManager::install(&quot;EnrichmentBrowser&quot;) } suppressPackageStartupMessages(library(EnrichmentBrowser)) Download the latest pathway definition file from the Baderlab download site. Baderlab genesets are updated on a monthly basis. Detailed information about the sources can be found here. Only Human, Mouse and Rat gene set files are currently available on the Baderlab downloads site. If you are working with a species other than human (and it is either rat or mouse) change the gmt_url below to correct species. tryCatch(expr = { suppressPackageStartupMessages(library(&quot;RCurl&quot;))}, error = function(e) { install.packages(&quot;RCurl&quot;)}, finally = library(&quot;RCurl&quot;)) gmt_url = &quot;http://download.baderlab.org/EM_Genesets/current_release/Human/symbol/&quot; #list all the files on the server filenames = getURL(gmt_url) tc = textConnection(filenames) contents = suppressWarnings(readLines(tc)) close(tc) #get the gmt that has all the pathways and does not include terms inferred from electronic annotations(IEA) #start with gmt file that has pathways only rx = gregexpr(&quot;(?&lt;=&lt;a href=\\&quot;)(.*.GOBP_AllPathways_no_GO_iea.*.)(.gmt)(?=\\&quot;&gt;)&quot;, contents, perl = TRUE) gmt_file = unlist(regmatches(contents, rx)) dest_gmt_file &lt;- file.path(getwd(), &quot;230_Isserlin_RCy3_intro&quot;, &quot;data&quot;, gmt_file) download.file( paste(gmt_url,gmt_file,sep=&quot;&quot;), destfile=dest_gmt_file ) Load in the gmt file baderlab.gs &lt;- getGenesets(dest_gmt_file) baderlab.gs[1:2] #&gt; $`THIO-MOLYBDENUM COFACTOR BIOSYNTHESIS%HUMANCYC%PWY-5963` #&gt; [1] &quot;MOCOS&quot; #&gt; #&gt; $`PROLINE BIOSYNTHESIS I%HUMANCYC%PROSYN-PWY` #&gt; [1] &quot;PYCR2&quot; &quot;ALDH18A1&quot; &quot;PYCR1&quot; &quot;PYCRL&quot; Create the dataset required by EnrichmentBrowser tools #create the expression file - A tab separated text file containing expression values. Columns = samples/subjects; rows = features/probes/genes; NO headers, row or column names. expr &lt;- RNASeq_expression sumexpr_filename &lt;- file.path(getwd(), &quot;230_Isserlin_RCy3_intro&quot;,&quot;data&quot;,&quot;SummarizeExperiment_expression.txt&quot;) write.table( expr , file = sumexpr_filename , col.names = FALSE, row.names = FALSE, sep = &quot;\\t&quot;, quote=FALSE) rowData &lt;- RNASeq_gene_scores[,grep(colnames(RNASeq_gene_scores), pattern=&quot;mesen&quot;)] rowData &lt;- cbind(RNASeq_gene_scores$Name,rowData) colnames(rowData)[2] &lt;- &quot;FC&quot; colnames(rowData)[6] &lt;- &quot;ADJ.PVAL&quot; sumexpr_rdat_filename &lt;- file.path(getwd(), &quot;230_Isserlin_RCy3_intro&quot;,&quot;data&quot;,&quot;SummarizeExperiment_rdat.txt&quot;) write.table( rowData[,1] , file = sumexpr_rdat_filename , col.names = FALSE, row.names = FALSE, sep = &quot;\\t&quot;, quote=FALSE) #load in the data classification data # A tab separated text file containing annotation information for the samples in either *two or three* columns. NO headers, row or column names. The number of rows/samples in this file should match the number of columns/samples of the expression matrix. The 1st column is reserved for the sample IDs; The 2nd column is reserved for a *BINARY* group assignment. Use &#39;0&#39; and &#39;1&#39; for unaffected (controls) and affected (cases) sample class classDefinitions_RNASeq &lt;- read.table( file.path(getwd(), &quot;230_Isserlin_RCy3_intro&quot;,&quot;data&quot;,&quot;RNASeq_classdefinitions.txt&quot;), header = TRUE, sep = &quot;\\t&quot;, quote=&quot;\\&quot;&quot;, stringsAsFactors = FALSE) colData &lt;- data.frame(Sample = colnames(RNASeq_expression), GROUP = classDefinitions_RNASeq$SUBTYPE, stringsAsFactors = FALSE) rownames(colData) &lt;- colnames(RNASeq_expression) colData$GROUP[which(colData$GROUP != &quot;Mesenchymal&quot;)] &lt;- 0 colData$GROUP[which(colData$GROUP == &quot;Mesenchymal&quot;)] &lt;- 1 sumexpr_cdat_filename &lt;- file.path(getwd(), &quot;230_Isserlin_RCy3_intro&quot;,&quot;data&quot;,&quot;SummarizeExperiment_cdat.txt&quot;) write.table( colData , file = sumexpr_cdat_filename , col.names = FALSE, row.names = FALSE, sep = &quot;\\t&quot;, quote=FALSE) #create the Summarize Experiment object se_OV &lt;- readSE(assay.file = sumexpr_filename , cdat.file = sumexpr_cdat_filename, rdat.file = sumexpr_rdat_filename) Put our precomputed p-values and fold change values into the Summarized Experiment object so we can use our rankings for the analysis #set the Summarized Experiment to our computed p-values and FC rowData(se_OV) &lt;- rowData Run basic Over representation analysis (ORA) using our ranked genes and our gene set file downloaded from the Baderlab genesets. ora.all &lt;- sbea(method=&quot;ora&quot;, se=se_OV, gs=baderlab.gs, perm=0, alpha=0.05) gsRanking(ora.all) #&gt; DataFrame with 967 rows and 4 columns #&gt; GENE.SET #&gt; &lt;character&gt; #&gt; 1 EXTRACELLULAR MATRIX ORGANIZATION%GOBP%GO:0030198 #&gt; 2 HALLMARK_EPITHELIAL_MESENCHYMAL_TRANSITION%MSIGDB_C2%HALLMARK_EPITHELIAL_MESENCHYMAL_TRANSITION #&gt; 3 EXTRACELLULAR STRUCTURE ORGANIZATION%GOBP%GO:0043062 #&gt; 4 EXTRACELLULAR MATRIX ORGANIZATION%REACTOME%R-HSA-1474244.2 #&gt; 5 NABA_CORE_MATRISOME%MSIGDB_C2%NABA_CORE_MATRISOME #&gt; ... ... #&gt; 963 OVULATION CYCLE%GOBP%GO:0042698 #&gt; 964 NEGATIVE REGULATION OF TRANSPORT%GOBP%GO:0051051 #&gt; 965 PEPTIDYL-TYROSINE MODIFICATION%GOBP%GO:0018212 #&gt; 966 NEUTROPHIL DEGRANULATION%GOBP%GO:0043312 #&gt; 967 PROCESSING OF CAPPED INTRON-CONTAINING PRE-MRNA%REACTOME DATABASE ID RELEASE 65%72203 #&gt; NR.GENES NR.SIG.GENES P.VALUE #&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; #&gt; 1 195 147 6.42e-21 #&gt; 2 193 145 2.07e-20 #&gt; 3 223 160 5.43e-19 #&gt; 4 239 163 6.1e-16 #&gt; 5 215 145 1.03e-13 #&gt; ... ... ... ... #&gt; 963 13 9 0.0487 #&gt; 964 246 118 0.0488 #&gt; 965 76 40 0.049 #&gt; 966 416 194 0.0496 #&gt; 967 213 103 0.0499 Take the enrichment results and create a generic enrichment map input file so we can create an Enrichment map. Description of format of the generic input file can be found here and example generic enrichment map files can be found here #manually adjust p-values ora.all$res.tbl &lt;- cbind(ora.all$res.tbl, p.adjust(ora.all$res.tbl$P.VALUE, &quot;BH&quot;)) colnames(ora.all$res.tbl)[ncol(ora.all$res.tbl)] &lt;- &quot;Q.VALUE&quot; #create a generic enrichment map file em_results_mesen &lt;- data.frame(name = ora.all$res.tbl$GENE.SET,descr = ora.all$res.tbl$GENE.SET, pvalue=ora.all$res.tbl$P.VALUE, qvalue=ora.all$res.tbl$Q.VALUE, stringsAsFactors = FALSE) #write out the ora results em_results_mesen_filename &lt;-file.path(getwd(), &quot;230_Isserlin_RCy3_intro&quot;,&quot;data&quot;,&quot;mesen_ora_enr_results.txt&quot;) write.table(em_results_mesen,em_results_mesen_filename,col.name=TRUE,sep=&quot;\\t&quot;,row.names=FALSE,quote=FALSE) Create an enrichment map with the returned ORA results. em_command = paste(&#39;enrichmentmap build analysisType=&quot;generic&quot; &#39;, &quot;gmtFile=&quot;, dest_gmt_file, &#39;pvalue=&#39;,&quot;0.05&quot;, &#39;qvalue=&#39;,&quot;0.05&quot;, &#39;similaritycutoff=&#39;,&quot;0.25&quot;, &#39;coeffecients=&#39;,&quot;JACCARD&quot;, &#39;enrichmentsDataset1=&#39;,em_results_mesen_filename , sep=&quot; &quot;) #enrichment map command will return the suid of newly created network. em_mesen_network_suid &lt;- commandsRun(em_command) renameNetwork(&quot;Mesenchymal_ORA_enrichmentmap&quot;, network=as.numeric(em_mesen_network_suid)) Export image of resulting Enrichment map. mesenem_png_file_name &lt;- file.path(getwd(),&quot;230_Isserlin_RCy3_intro&quot;, &quot;images&quot;,&quot;mesenem.png&quot;) if(file.exists(mesenem_png_file_name)){ #cytoscape hangs waiting for user response if file alreayd exists. Remove it first file.remove(mesenem_png_file_name) } #export the network exportImage(mesenem_png_file_name, type = &quot;png&quot;) (#fig:mesenem_fig)Example Enrichment Map created when running an enrichment analysis using EnrichmentBrowser ORA with the genes differential in Mesenchymal OV Annotate the Enrichment map to get the general themes that are found in the enrichment results. Often for very busy networks annotating the networks doesn’t help to reduce the complexity but instead adds to it. To get rid of some of the pathway redundancy and density in the network create a summary of the underlying network. The summary network collapses each cluster to a summary node. Each summary node is annotated with a word tag (the top 3 words associated with the nodes of the cluster) that is computed using the Wordcloud app. #get the column from the nodetable and node table nodetable_colnames &lt;- getTableColumnNames(table=&quot;node&quot;, network = as.numeric(em_mesen_network_suid)) descr_attrib &lt;- nodetable_colnames[grep(nodetable_colnames, pattern = &quot;_GS_DESCR&quot;)] #Autoannotate the network autoannotate_url &lt;- paste(&quot;autoannotate annotate-clusterBoosted labelColumn=&quot;, descr_attrib,&quot; maxWords=3 &quot;, sep=&quot;&quot;) current_name &lt;-commandsGET(autoannotate_url) #create a summary network commandsGET(&quot;autoannotate summary network=&#39;current&#39;&quot;) #change the network name summary_network_suid &lt;- getNetworkSuid() renameNetwork(title = &quot;Mesen_ORA_summary_netowrk&quot;, network = as.numeric(summary_network_suid)) #get the summary node names summary_nodes &lt;- getTableColumns(table=&quot;node&quot;,columns=c(&quot;name&quot;)) #clear bypass style the summary network has clearNodePropertyBypass(node.names = summary_nodes$name,visual.property = &quot;NODE_SIZE&quot;) #relayout network layoutNetwork(&#39;cose&#39;, network = as.numeric(summary_network_suid)) Export image of resulting Summarized Annotated Enrichment map. mesenem_summary_png_file_name &lt;- file.path(getwd(),&quot;230_Isserlin_RCy3_intro&quot;,&quot;images&quot;,&quot;mesenem_summary_network.png&quot;) if(file.exists(mesenem_summary_png_file_name)){ #cytoscape hangs waiting for user response if file alreayd exists. Remove it first file.remove(mesenem_summary_png_file_name) } #export the network exportImage(mesenem_summary_png_file_name, type = &quot;png&quot;) (#fig:cmesenem_annot_fig)Example Annotated Enrichment Map created when running an enrichment analysis using EnrichmentBrowser ORA with the genes that differential in mesenchymal OV 3.4 References "],
["variant-functional-annotation-using-statepaintr-funcivar-motifbreakr.html", "4 Variant Functional Annotation using StatePaintR, FunciVar &amp; MotifBreakR 4.1 Instructor(s) name(s) and contact information 4.2 Workshop Description 4.3 Workshop goals and objectives", " 4 Variant Functional Annotation using StatePaintR, FunciVar &amp; MotifBreakR 4.1 Instructor(s) name(s) and contact information Simon G. Coetzee (scoetzee@gmail.com) Dennis J. Hazelett (dennis.hazelett@csmc.edu) 4.2 Workshop Description This workshop will entail lecture and live demo of StateHub/ StatePaintR and funciVar bioconductor packages. 4.2.1 Pre-requisites It is recommended that workshop participants have: * Basic concepts in epigenomics and GWAS * Intermediate R skills, familiarity with GRanges Relevant background reading for the workshop. StateHub/StatePaintR BioC2017 Workshop MotifBreakR 4.2.2 Workshop Participation Describe how students will be expected to participate in the workshop. 4.2.3 R / Bioconductor packages used StatePaintR FunciVar MotifBreakR 4.2.4 Time outline 1 hour Workshop: Activity Time StatePaintR 30m * intro and theory (10m) * Generate Decision Matrix (10m) * live demo (10m) FunciVar 15m * intro (10m) * live demo (5m) MotifBreakR 15m * intro &amp; demo (10m) * Shiny webapp demo (5m) 4.3 Workshop goals and objectives This workshop focuses on bioconductor based tools for non-coding variant annotation. I will present a high level overview of these concepts and the bioconductor tools our group uses to address them in silico. These tools can be used for germline or somatic variants, but as we will see, can also be used for any other type of feature represented as GRanges objects. 4.3.1 Key Concepts I will provide brief overview with examples of: Genome segmentation and Chromatin State Feature enrichment analysis Transcription factors and Motif Disruption 4.3.2 Learning objectives At the end of this workshop students will understand the basic inputs and outputs of all these analyses, as well as an intuitive understanding of the tools and where to find them: The StateHub website StatePaintR genome segmentation software Bioconductor FunciVar for variant annotation and enrichment MotifBreakR Transcription Factor motif disruption Bioconductor "],
["functional-enrichment-analysis-of-high-throughput-omics-data.html", "5 Functional enrichment analysis of high-throughput omics data 5.1 Instructor(s) name(s) and contact information 5.2 Workshop Description 5.3 Goals and objectives 5.4 Workshop 5.5 Where does it all come from? 5.6 Gene expression-based enrichment analysis 5.7 A primer on terminology, existing methods &amp; statistical theory 5.8 Data types 5.9 Differential expression analysis 5.10 Gene sets 5.11 GO/KEGG overrepresentation analysis 5.12 Functional class scoring &amp; permutation testing 5.13 Network-based enrichment analysis 5.14 Genomic region enrichment analysis", " 5 Functional enrichment analysis of high-throughput omics data 5.1 Instructor(s) name(s) and contact information Ludwig Geistlinger (Ludwig.Geistlinger@sph.cuny.edu) Levi Waldron CUNY School of Public Health 55 W 125th St, New York, NY 10027 5.2 Workshop Description This workshop gives an in-depth overview of existing methods for enrichment analysis of gene expression data with regard to functional gene sets, pathways, and networks. The workshop will help participants understand the distinctions between assumptions and hypotheses of existing methods as well as the differences in objectives and interpretation of results. It will provide code and hands-on practice of all necessary steps for differential expression analysis, gene set- and network-based enrichment analysis, and identification of enriched genomic regions and regulatory elements, along with visualization and exploration of results. 5.2.1 Pre-requisites Basic knowledge of R syntax Familiarity with the SummarizedExperiment class Familiarity with the GenomicRanges class Familiarity with high-throughput gene expression data as obtained with microarrays and RNA-seq Familiarity with the concept of differential expression analysis (with e.g. limma, edgeR, DESeq2) 5.2.2 Workshop Participation Execution of example code and hands-on practice 5.2.3 R / Bioconductor packages used EnrichmentBrowser regioneR airway ALL hgu95av2.db BSgenome.Hsapiens.UCSC.hg19.masked 5.2.4 Time outline Activity Time Background 30m Differential expression analysis 15m Gene set analysis 30m Gene network analysis 15m Genomic region analysis 15m 5.3 Goals and objectives Theory * Gene sets, pathways &amp; regulatory networks * Resources * Gene set analysis vs. gene set enrichment analysis * Underlying null: competitive vs. self-contained * Generations: ora, fcs &amp; topology-based Practice: * Data types: microarray vs. RNA-seq * Differential expression analysis * Defining gene sets according to GO and KEGG * GO/KEGG overrepresentation analysis * Functional class scoring &amp; permutation testing * Network-based enrichment analysis * Genomic region enrichment analysis 5.4 Workshop 5.5 Where does it all come from? Test whether known biological functions or processes are over-represented (= enriched) in an experimentally-derived gene list, e.g. a list of differentially expressed (DE) genes. See Goeman and Buehlmann, 2007 for a critical review. Example: Transcriptomic study, in which 12,671 genes have been tested for differential expression between two sample conditions and 529 genes were found DE. Among the DE genes, 28 are annotated to a specific functional gene set, which contains in total 170 genes. This setup corresponds to a 2x2 contingency table, deTable &lt;- matrix(c(28, 142, 501, 12000), nrow = 2, dimnames = list(c(&quot;DE&quot;, &quot;Not.DE&quot;), c(&quot;In.gene.set&quot;, &quot;Not.in.gene.set&quot;))) deTable #&gt; In.gene.set Not.in.gene.set #&gt; DE 28 501 #&gt; Not.DE 142 12000 where the overlap of 28 genes can be assessed based on the hypergeometric distribution. This corresponds to a one-sided version of Fisher’s exact test, yielding here a significant enrichment. fisher.test(deTable, alternative = &quot;greater&quot;) #&gt; #&gt; Fisher&#39;s Exact Test for Count Data #&gt; #&gt; data: deTable #&gt; p-value = 4.088e-10 #&gt; alternative hypothesis: true odds ratio is greater than 1 #&gt; 95 percent confidence interval: #&gt; 3.226736 Inf #&gt; sample estimates: #&gt; odds ratio #&gt; 4.721744 This basic principle is at the foundation of major public and commercial enrichment tools such as DAVID and Pathway Studio. Although gene set enrichment methods have been primarily developed and applied on transcriptomic data, they have recently been modified, extended and applied also in other fields of genomic and biomedical research. This includes novel approaches for functional enrichment analysis of proteomic and metabolomic data as well as genomic regions and disease phenotypes, Lavallee and Yates, 2016, Chagoyen et al., 2016, McLean et al., 2010, Ried et al., 2012. 5.6 Gene expression-based enrichment analysis The first part of the workshop is largely based on the EnrichmentBrowser package, which implements an analysis pipeline for high-throughput gene expression data as measured with microarrays and RNA-seq. In a workflow-like manner, the package brings together a selection of established Bioconductor packages for gene expression data analysis. It integrates a wide range of gene set enrichment analysis methods and facilitates combination and exploration of results across methods. suppressPackageStartupMessages(library(EnrichmentBrowser)) Further information can be found in the vignette and publication. 5.7 A primer on terminology, existing methods &amp; statistical theory Gene sets, pathways &amp; regulatory networks Gene sets are simple lists of usually functionally related genes without further specification of relationships between genes. Pathways can be interpreted as specific gene sets, typically representing a group of genes that work together in a biological process. Pathways are commonly divided in metabolic and signaling pathways. Metabolic pathways such as glycolysis represent biochemical substrate conversions by specific enzymes. Signaling pathways such as the MAPK signaling pathway describe signal transduction cascades from receptor proteins to transcription factors, resulting in activation or inhibition of specific target genes. Gene regulatory networks describe the interplay and effects of regulatory factors (such as transcription factors and microRNAs) on the expression of their target genes. Resources GO and KEGG annotations are most frequently used for the enrichment analysis of functional gene sets. Despite an increasing number of gene set and pathway databases, they are typically the first choice due to their long-standing curation and availability for a wide range of species. GO: The Gene Ontology (GO) consists of three major sub-ontologies that classify gene products according to molecular function (MF), biological process (BP) and cellular component (CC). Each ontology consists of GO terms that define MFs, BPs or CCs to which specific genes are annotated. The terms are organized in a directed acyclic graph, where edges between the terms represent relationships of different types. They relate the terms according to a parent-child scheme, i.e. parent terms denote more general entities, whereas child terms represent more specific entities. KEGG: The Kyoto Encyclopedia of Genes and Genomes (KEGG) is a collection of manually drawn pathway maps representing molecular interaction and reaction networks. These pathways cover a wide range of biochemical processes that can be divided in 7 broad categories: metabolism, genetic and environmental information processing, cellular processes, organismal systems, human diseases, and drug development. Metabolism and drug development pathways differ from pathways of the other 5 categories by illustrating reactions between chemical compounds. Pathways of the other 5 categories illustrate molecular interactions between genes and gene products. Gene set analysis vs. gene set enrichment analysis The two predominantly used enrichment methods are: Overrepresentation analysis (ORA), testing whether a gene set contains disproportional many genes of significant expression change, based on the procedure outlined in the first section Gene set enrichment analysis (GSEA), testing whether genes of a gene set accumulate at the top or bottom of the full gene vector ordered by direction and magnitude of expression change Subramanian et al., 2005 However, the term gene set enrichment analysis nowadays subsumes a general strategy implemented by a wide range of methods Huang et al., 2009. Those methods have in common the same goal, although approach and statistical model can vary substantially Goeman and Buehlmann, 2007, Khatri et al., 2012. To better distinguish from the specific method, some authors use the term gene set analysis to denote the general strategy. However, there is also a specific method from Efron and Tibshirani, 2007 of this name. Underlying null: competitive vs. self-contained Goeman and Buehlmann, 2007 classified existing enrichment methods into competitive and self-contained based on the underlying null hypothesis. Competitive null hypothesis: the genes in the set of interest are at most as often DE as the genes not in the set, Self-contained null hypothesis: no genes in the set of interest are DE. Although the authors argue that a self-contained null is closer to the actual question of interest, the vast majority of enrichment methods is competitive. Goeman and Buehlmann further raise several critical issues concerning the 2x2 ORA: rather arbitrary classification of genes in DE / not DE based on gene sampling, although sampling of subjects is appropriate unrealistic independence assumption between genes, resulting in highly anti-conservative p-values With regard to these statistical concerns, GSEA is considered superior: takes all measured genes into account subject sampling via permutation of class labels the incorporated permutation procedure implicitly accounts for correlations between genes However, the simplicity and general applicability of ORA is unmet by subsequent methods improving on these issues. For instance, GSEA requires the expression data as input, which is not available for gene lists derived from other experiment types. On the other hand, the involved sample permutation procedure has been proven inaccurate and time-consuming Efron and Tibshirani, 2007, Phipson and Smyth, 2010, Larson and Owen, 2015. Generations: ora, fcs &amp; topology-based Khatri et al., 2012 have taken a slightly different approach by classifying methods along the timeline of development into three generations: Generation: ORA methods based on the 2x2 contingency table test, Generation: functional class scoring (FCS) methods such as GSEA, which compute gene set (= functional class) scores by summarizing per-gene DE statistics, Generation: topology-based methods, explicitly taking into account interactions between genes as defined in signaling pathways and gene regulatory networks (Geistlinger et al., 2011 for an example). Although topology-based (also: network-based) methods appear to be most realistic, their straightforward application can be impaired by features that are not-detectable on the transcriptional level (such as protein-protein interactions) and insufficient network knowledge Geistlinger et al., 2013, Bayerlova et al., 2015. Given the individual benefits and limitations of existing methods, cautious interpretation of results is required to derive valid conclusions. Whereas no single method is best suited for all application scenarios, applying multiple methods can be beneficial. This has been shown to filter out spurious hits of individual methods, thereby reducing the outcome to gene sets accumulating evidence from different methods Geistlinger et al., 2016, Alhamdoosh et al., 2017. 5.8 Data types Although RNA-seq (read count data) has become the de facto standard for transcriptomic profiling, it is important to know that many methods for differential expression and gene set enrichment analysis have been originally developed for microarray data (intensity measurements). However, differences in data distribution assumptions (microarray: quasi-normal, RNA-seq: negative binomial) made adaptations in differential expression analysis and, to some extent, also in gene set enrichment analysis necessary. Thus, we consider two example datasets - a microarray and a RNA-seq dataset, and discuss similarities and differences of the respective analysis steps. For microarray data, we consider expression measurements of patients with acute lymphoblastic leukemia Chiaretti et al., 2004. A frequent chromosomal defect found among these patients is a translocation, in which parts of chromosome 9 and 22 swap places. This results in the oncogenic fusion gene BCR/ABL created by positioning the ABL1 gene on chromosome 9 to a part of the BCR gene on chromosome 22. We load the ALL dataset library(ALL) data(ALL) and select B-cell ALL patients with and without the BCR/ABL fusion, as described previously Gentleman et al., 2005. ind.bs &lt;- grep(&quot;^B&quot;, ALL$BT) ind.mut &lt;- which(ALL$mol.biol %in% c(&quot;BCR/ABL&quot;, &quot;NEG&quot;)) sset &lt;- intersect(ind.bs, ind.mut) all.eset &lt;- ALL[, sset] We can now access the expression values, which are intensity measurements on a log-scale for 12,625 probes (rows) across 79 patients (columns). dim(all.eset) #&gt; Features Samples #&gt; 12625 79 exprs(all.eset)[1:4,1:4] #&gt; 01005 01010 03002 04007 #&gt; 1000_at 7.597323 7.479445 7.567593 7.905312 #&gt; 1001_at 5.046194 4.932537 4.799294 4.844565 #&gt; 1002_f_at 3.900466 4.208155 3.886169 3.416923 #&gt; 1003_s_at 5.903856 6.169024 5.860459 5.687997 As we often have more than one probe per gene, we compute gene expression values as the average of the corresponding probe values. allSE &lt;- probe2gene(all.eset) #&gt; Loading required package: hgu95av2.db #&gt; Loading required package: AnnotationDbi #&gt; Loading required package: org.Hs.eg.db #&gt; #&gt; head(names(allSE)) #&gt; [1] &quot;5595&quot; &quot;7075&quot; &quot;1557&quot; &quot;643&quot; &quot;1843&quot; &quot;4319&quot; For RNA-seq data, we consider transcriptome profiles of four primary human airway smooth muscle cell lines in two conditions: control and treatment with dexamethasone Himes et al., 2014. We load the airway dataset library(airway) data(airway) For further analysis, we only keep genes that are annotated to an ENSEMBL gene ID. airSE &lt;- airway[grep(&quot;^ENSG&quot;, names(airway)), ] dim(airSE) #&gt; [1] 63677 8 assay(airSE)[1:4,1:4] #&gt; SRR1039508 SRR1039509 SRR1039512 SRR1039513 #&gt; ENSG00000000003 679 448 873 408 #&gt; ENSG00000000005 0 0 0 0 #&gt; ENSG00000000419 467 515 621 365 #&gt; ENSG00000000457 260 211 263 164 5.9 Differential expression analysis Normalization of high-throughput expression data is essential to make results within and between experiments comparable. Microarray (intensity measurements) and RNA-seq (read counts) data typically show distinct features that need to be normalized for. As this is beyond the scope of this workshop, we refer to limma for microarray normalization and EDASeq for RNA-seq normalization. See also EnrichmentBrowser::normalize, which wraps commonly used functionality for normalization. The EnrichmentBrowser incorporates established functionality from the limma package for differential expression analysis. This involves the voom transformation when applied to RNA-seq data. Alternatively, differential expression analysis for RNA-seq data can also be carried out based on the negative binomial distribution with edgeR and DESeq2. This can be performed using the function EnrichmentBrowser::deAna and assumes some standardized variable names: GROUP defines the sample groups being contrasted, BLOCK defines paired samples or sample blocks, as e.g. for batch effects. For more information on experimental design, see the limma user’s guide, chapter 9. For the ALL dataset, the GROUP variable indicates whether the BCR-ABL gene fusion is present (1) or not (0). allSE$GROUP &lt;- ifelse(allSE$mol.biol == &quot;BCR/ABL&quot;, 1, 0) table(allSE$GROUP) #&gt; #&gt; 0 1 #&gt; 42 37 For the airway dataset, it indicates whether the cell lines have been treated with dexamethasone (1) or not (0). airSE$GROUP &lt;- ifelse(colData(airway)$dex == &quot;trt&quot;, 1, 0) table(airSE$GROUP) #&gt; #&gt; 0 1 #&gt; 4 4 Paired samples, or in general sample batches/blocks, can be defined via a BLOCK column in the colData slot. For the airway dataset, the sample blocks correspond to the four different cell lines. airSE$BLOCK &lt;- airway$cell table(airSE$BLOCK) #&gt; #&gt; N052611 N061011 N080611 N61311 #&gt; 2 2 2 2 For microarray data, the EnrichmentBrowser::deAna function carries out differential expression analysis based on functionality from the limma package. Resulting log2 fold changes and t-test derived p-values for each gene are appended to the rowData slot. allSE &lt;- deAna(allSE) rowData(allSE, use.names=TRUE) #&gt; DataFrame with 9010 rows and 3 columns #&gt; FC ADJ.PVAL limma.STAT #&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; #&gt; 5595 0.0429698599842595 0.899246817310775 0.734679177472013 #&gt; 7075 0.0320835027449625 0.949001013642671 0.4546910829318 #&gt; 1557 -0.0439401425131442 0.818330132411339 -1.06578261967549 #&gt; 643 -0.0277543539240438 0.929148567589577 -0.567394394416651 #&gt; 1843 -0.427302534257363 0.566034751753148 -1.75050227190017 #&gt; ... ... ... ... #&gt; 6300 -0.026651766164237 0.922828548631225 -0.608608859328046 #&gt; 7297 -0.124257678078831 0.804578494190681 -1.11279493778184 #&gt; 2246 0.0522428857778935 0.748021044717352 1.27408420746691 #&gt; 7850 -0.00908229596065303 0.991826450687159 -0.102406339091096 #&gt; 1593 -0.00747713820802068 0.989532971314233 -0.145650256847251 Nominal p-values are already corrected for multiple testing (ADJ.PVAL) using the method from Benjamini and Hochberg implemented in stats::p.adjust. For RNA-seq data, the deAna function can be used to carry out differential expression analysis between the two groups either based on functionality from limma (that includes the voom transformation), or alternatively, the frequently used edgeR or DESeq2 package. Here, we use the analysis based on edgeR. airSE &lt;- deAna(airSE, de.method=&quot;edgeR&quot;) #&gt; Excluding 50740 genes not satisfying min.cpm threshold rowData(airSE, use.names=TRUE) #&gt; DataFrame with 12937 rows and 3 columns #&gt; FC ADJ.PVAL #&gt; &lt;numeric&gt; &lt;numeric&gt; #&gt; ENSG00000000003 -0.404945626610932 0.00213458295385943 #&gt; ENSG00000000419 0.182985434777532 0.0915691945172958 #&gt; ENSG00000000457 0.0143477674070903 0.922279475399443 #&gt; ENSG00000000460 -0.141173372957311 0.619013213521635 #&gt; ENSG00000000971 0.402240426474172 0.00403820532305827 #&gt; ... ... ... #&gt; ENSG00000273270 -0.129793853337261 0.495892935815041 #&gt; ENSG00000273290 0.505580471641003 0.00639218387702899 #&gt; ENSG00000273311 0.00161557580855148 0.996356136956657 #&gt; ENSG00000273329 -0.222817127090519 0.388294594068803 #&gt; ENSG00000273344 0.0151704005097403 0.962777106053257 #&gt; edgeR.STAT #&gt; &lt;numeric&gt; #&gt; ENSG00000000003 35.8743710016552 #&gt; ENSG00000000419 5.90960619951737 #&gt; ENSG00000000457 0.0233923316990905 #&gt; ENSG00000000460 0.492929955080604 #&gt; ENSG00000000971 27.8509962017407 #&gt; ... ... #&gt; ENSG00000273270 0.901598359265205 #&gt; ENSG00000273290 23.0905678847871 #&gt; ENSG00000273311 8.04821152029429e-05 #&gt; ENSG00000273329 1.42723325850597 #&gt; ENSG00000273344 0.00543503273765429 Exercise: Compare the number of differentially expressed genes as obtained on the airSE with limma/voom, edgeR, and DESeq2. 5.10 Gene sets We are now interested in whether pre-defined sets of genes that are known to work together, e.g. as defined in the Gene Ontology or the KEGG pathway annotation, are coordinately differentially expressed. The function getGenesets can be used to download gene sets from databases such as GO and KEGG. Here, we use the function to download all KEGG pathways for a chosen organism (here: ) as gene sets. kegg.gs &lt;- getGenesets(org=&quot;hsa&quot;, db=&quot;kegg&quot;) Analogously, the function getGenesets can be used to retrieve GO terms of a selected ontology (here: biological process, BP) as defined in the GO.db annotation package. go.gs &lt;- getGenesets(org=&quot;hsa&quot;, db=&quot;go&quot;, go.onto=&quot;BP&quot;, go.mode=&quot;GO.db&quot;) #&gt; If provided a file, the function getGenesets parses user-defined gene sets from GMT file format. Here, we use this functionality for reading a list of already downloaded KEGG gene sets for Homo sapiens containing NCBI Entrez Gene IDs. data.dir &lt;- system.file(&quot;extdata&quot;, package=&quot;EnrichmentBrowser&quot;) gmt.file &lt;- file.path(data.dir, &quot;hsa_kegg_gs.gmt&quot;) hsa.gs &lt;- getGenesets(gmt.file) hsa.gs[1:2] #&gt; $hsa05416_Viral_myocarditis #&gt; [1] &quot;100509457&quot; &quot;101060835&quot; &quot;1525&quot; &quot;1604&quot; &quot;1605&quot; #&gt; [6] &quot;1756&quot; &quot;1981&quot; &quot;1982&quot; &quot;25&quot; &quot;2534&quot; #&gt; [11] &quot;27&quot; &quot;3105&quot; &quot;3106&quot; &quot;3107&quot; &quot;3108&quot; #&gt; [16] &quot;3109&quot; &quot;3111&quot; &quot;3112&quot; &quot;3113&quot; &quot;3115&quot; #&gt; [21] &quot;3117&quot; &quot;3118&quot; &quot;3119&quot; &quot;3122&quot; &quot;3123&quot; #&gt; [26] &quot;3125&quot; &quot;3126&quot; &quot;3127&quot; &quot;3133&quot; &quot;3134&quot; #&gt; [31] &quot;3135&quot; &quot;3383&quot; &quot;3683&quot; &quot;3689&quot; &quot;3908&quot; #&gt; [36] &quot;4624&quot; &quot;4625&quot; &quot;54205&quot; &quot;5551&quot; &quot;5879&quot; #&gt; [41] &quot;5880&quot; &quot;5881&quot; &quot;595&quot; &quot;60&quot; &quot;637&quot; #&gt; [46] &quot;6442&quot; &quot;6443&quot; &quot;6444&quot; &quot;6445&quot; &quot;71&quot; #&gt; [51] &quot;836&quot; &quot;841&quot; &quot;842&quot; &quot;857&quot; &quot;8672&quot; #&gt; [56] &quot;940&quot; &quot;941&quot; &quot;942&quot; &quot;958&quot; &quot;959&quot; #&gt; #&gt; $`hsa04622_RIG-I-like_receptor_signaling_pathway` #&gt; [1] &quot;10010&quot; &quot;1147&quot; &quot;1432&quot; &quot;1540&quot; &quot;1654&quot; &quot;23586&quot; &quot;26007&quot; #&gt; [8] &quot;29110&quot; &quot;338376&quot; &quot;340061&quot; &quot;3439&quot; &quot;3440&quot; &quot;3441&quot; &quot;3442&quot; #&gt; [15] &quot;3443&quot; &quot;3444&quot; &quot;3445&quot; &quot;3446&quot; &quot;3447&quot; &quot;3448&quot; &quot;3449&quot; #&gt; [22] &quot;3451&quot; &quot;3452&quot; &quot;3456&quot; &quot;3467&quot; &quot;3551&quot; &quot;3576&quot; &quot;3592&quot; #&gt; [29] &quot;3593&quot; &quot;3627&quot; &quot;3661&quot; &quot;3665&quot; &quot;4214&quot; &quot;4790&quot; &quot;4792&quot; #&gt; [36] &quot;4793&quot; &quot;5300&quot; &quot;54941&quot; &quot;55593&quot; &quot;5599&quot; &quot;5600&quot; &quot;5601&quot; #&gt; [43] &quot;5602&quot; &quot;5603&quot; &quot;56832&quot; &quot;57506&quot; &quot;5970&quot; &quot;6300&quot; &quot;64135&quot; #&gt; [50] &quot;64343&quot; &quot;6885&quot; &quot;7124&quot; &quot;7186&quot; &quot;7187&quot; &quot;7189&quot; &quot;7706&quot; #&gt; [57] &quot;79132&quot; &quot;79671&quot; &quot;80143&quot; &quot;841&quot; &quot;843&quot; &quot;8517&quot; &quot;8717&quot; #&gt; [64] &quot;8737&quot; &quot;8772&quot; &quot;9140&quot; &quot;9474&quot; &quot;9636&quot; &quot;9641&quot; &quot;9755&quot; hsa.gs[1:2] #&gt; $hsa05416_Viral_myocarditis #&gt; [1] &quot;100509457&quot; &quot;101060835&quot; &quot;1525&quot; &quot;1604&quot; &quot;1605&quot; #&gt; [6] &quot;1756&quot; &quot;1981&quot; &quot;1982&quot; &quot;25&quot; &quot;2534&quot; #&gt; [11] &quot;27&quot; &quot;3105&quot; &quot;3106&quot; &quot;3107&quot; &quot;3108&quot; #&gt; [16] &quot;3109&quot; &quot;3111&quot; &quot;3112&quot; &quot;3113&quot; &quot;3115&quot; #&gt; [21] &quot;3117&quot; &quot;3118&quot; &quot;3119&quot; &quot;3122&quot; &quot;3123&quot; #&gt; [26] &quot;3125&quot; &quot;3126&quot; &quot;3127&quot; &quot;3133&quot; &quot;3134&quot; #&gt; [31] &quot;3135&quot; &quot;3383&quot; &quot;3683&quot; &quot;3689&quot; &quot;3908&quot; #&gt; [36] &quot;4624&quot; &quot;4625&quot; &quot;54205&quot; &quot;5551&quot; &quot;5879&quot; #&gt; [41] &quot;5880&quot; &quot;5881&quot; &quot;595&quot; &quot;60&quot; &quot;637&quot; #&gt; [46] &quot;6442&quot; &quot;6443&quot; &quot;6444&quot; &quot;6445&quot; &quot;71&quot; #&gt; [51] &quot;836&quot; &quot;841&quot; &quot;842&quot; &quot;857&quot; &quot;8672&quot; #&gt; [56] &quot;940&quot; &quot;941&quot; &quot;942&quot; &quot;958&quot; &quot;959&quot; #&gt; #&gt; $`hsa04622_RIG-I-like_receptor_signaling_pathway` #&gt; [1] &quot;10010&quot; &quot;1147&quot; &quot;1432&quot; &quot;1540&quot; &quot;1654&quot; &quot;23586&quot; &quot;26007&quot; #&gt; [8] &quot;29110&quot; &quot;338376&quot; &quot;340061&quot; &quot;3439&quot; &quot;3440&quot; &quot;3441&quot; &quot;3442&quot; #&gt; [15] &quot;3443&quot; &quot;3444&quot; &quot;3445&quot; &quot;3446&quot; &quot;3447&quot; &quot;3448&quot; &quot;3449&quot; #&gt; [22] &quot;3451&quot; &quot;3452&quot; &quot;3456&quot; &quot;3467&quot; &quot;3551&quot; &quot;3576&quot; &quot;3592&quot; #&gt; [29] &quot;3593&quot; &quot;3627&quot; &quot;3661&quot; &quot;3665&quot; &quot;4214&quot; &quot;4790&quot; &quot;4792&quot; #&gt; [36] &quot;4793&quot; &quot;5300&quot; &quot;54941&quot; &quot;55593&quot; &quot;5599&quot; &quot;5600&quot; &quot;5601&quot; #&gt; [43] &quot;5602&quot; &quot;5603&quot; &quot;56832&quot; &quot;57506&quot; &quot;5970&quot; &quot;6300&quot; &quot;64135&quot; #&gt; [50] &quot;64343&quot; &quot;6885&quot; &quot;7124&quot; &quot;7186&quot; &quot;7187&quot; &quot;7189&quot; &quot;7706&quot; #&gt; [57] &quot;79132&quot; &quot;79671&quot; &quot;80143&quot; &quot;841&quot; &quot;843&quot; &quot;8517&quot; &quot;8717&quot; #&gt; [64] &quot;8737&quot; &quot;8772&quot; &quot;9140&quot; &quot;9474&quot; &quot;9636&quot; &quot;9641&quot; &quot;9755&quot; See also the MSigDb for additional gene set collections. 5.11 GO/KEGG overrepresentation analysis A variety of gene set analysis methods have been proposed Khatri et al., 2012. The most basic, yet frequently used, method is the over-representation analysis (ORA) with gene sets defined according to GO or KEGG. As outlined in the first section, ORA tests the overlap between DE genes (typically DE p-value &lt; 0.05) and genes in a gene set based on the hypergeometric distribution. Here, we choose a significance level \\(\\alpha = 0.2\\) for demonstration. ora.all &lt;- sbea(method=&quot;ora&quot;, se=allSE, gs=hsa.gs, perm=0, alpha=0.2) gsRanking(ora.all) #&gt; DataFrame with 7 rows and 4 columns #&gt; GENE.SET #&gt; &lt;character&gt; #&gt; 1 hsa05202_Transcriptional_misregulation_in_cancer #&gt; 2 hsa05412_Arrhythmogenic_right_ventricular_cardiomyopathy_(ARVC) #&gt; 3 hsa05144_Malaria #&gt; 4 hsa04670_Leukocyte_transendothelial_migration #&gt; 5 hsa05100_Bacterial_invasion_of_epithelial_cells #&gt; 6 hsa04622_RIG-I-like_receptor_signaling_pathway #&gt; 7 hsa05130_Pathogenic_Escherichia_coli_infection #&gt; NR.GENES NR.SIG.GENES P.VALUE #&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; #&gt; 1 153 17 0.0351 #&gt; 2 63 8 0.0717 #&gt; 3 45 6 0.0932 #&gt; 4 94 10 0.122 #&gt; 5 64 7 0.162 #&gt; 6 54 6 0.178 #&gt; 7 43 5 0.184 Such a ranked list is the standard output of most existing enrichment tools. Using the eaBrowse function creates a HTML summary from which each gene set can be inspected in more detail. eaBrowse(ora.all) #&gt; Creating gene report ... #&gt; #&gt; Creating set view ... #&gt; Creating kegg view ... #&gt; Loading required package: pathview #&gt; Info: Downloading xml files for hsa05202, 1/1 pathways.. #&gt; Info: Downloading png files for hsa05202, 1/1 pathways.. #&gt; &#39;select()&#39; returned 1:1 mapping between keys and columns #&gt; Info: Working in directory /home/mramos/Source/github/BiocWorkshops #&gt; Info: Writing image file hsa05202.kpath.png #&gt; Warning in file.rename(from = pv.out, to = img.file): cannot rename file #&gt; &#39;/home/mramos/Source/github/BiocWorkshops/hsa05202.kpath.png&#39; to &#39;/home/ #&gt; mramos/.local/share/EnrichmentBrowser/results/reports/hsa05202_kpath.png&#39;, #&gt; reason &#39;Invalid cross-device link&#39; #&gt; Info: Downloading xml files for hsa05412, 1/1 pathways.. #&gt; Info: Downloading png files for hsa05412, 1/1 pathways.. #&gt; &#39;select()&#39; returned 1:1 mapping between keys and columns #&gt; Info: Working in directory /home/mramos/Source/github/BiocWorkshops #&gt; Info: Writing image file hsa05412.kpath.png #&gt; Warning in file.rename(from = pv.out, to = img.file): cannot rename file #&gt; &#39;/home/mramos/Source/github/BiocWorkshops/hsa05412.kpath.png&#39; to &#39;/home/ #&gt; mramos/.local/share/EnrichmentBrowser/results/reports/hsa05412_kpath.png&#39;, #&gt; reason &#39;Invalid cross-device link&#39; #&gt; Info: Downloading xml files for hsa05144, 1/1 pathways.. #&gt; Info: Downloading png files for hsa05144, 1/1 pathways.. #&gt; &#39;select()&#39; returned 1:1 mapping between keys and columns #&gt; Info: Working in directory /home/mramos/Source/github/BiocWorkshops #&gt; Info: Writing image file hsa05144.kpath.png #&gt; Warning in file.rename(from = pv.out, to = img.file): cannot rename file #&gt; &#39;/home/mramos/Source/github/BiocWorkshops/hsa05144.kpath.png&#39; to &#39;/home/ #&gt; mramos/.local/share/EnrichmentBrowser/results/reports/hsa05144_kpath.png&#39;, #&gt; reason &#39;Invalid cross-device link&#39; #&gt; Info: Downloading xml files for hsa04670, 1/1 pathways.. #&gt; Info: Downloading png files for hsa04670, 1/1 pathways.. #&gt; &#39;select()&#39; returned 1:1 mapping between keys and columns #&gt; Info: Working in directory /home/mramos/Source/github/BiocWorkshops #&gt; Info: Writing image file hsa04670.kpath.png #&gt; Warning in file.rename(from = pv.out, to = img.file): cannot rename file #&gt; &#39;/home/mramos/Source/github/BiocWorkshops/hsa04670.kpath.png&#39; to &#39;/home/ #&gt; mramos/.local/share/EnrichmentBrowser/results/reports/hsa04670_kpath.png&#39;, #&gt; reason &#39;Invalid cross-device link&#39; #&gt; Info: Downloading xml files for hsa05100, 1/1 pathways.. #&gt; Info: Downloading png files for hsa05100, 1/1 pathways.. #&gt; &#39;select()&#39; returned 1:1 mapping between keys and columns #&gt; Info: Working in directory /home/mramos/Source/github/BiocWorkshops #&gt; Info: Writing image file hsa05100.kpath.png #&gt; Info: some node width is different from others, and hence adjusted! #&gt; Warning in file.rename(from = pv.out, to = img.file): cannot rename file #&gt; &#39;/home/mramos/Source/github/BiocWorkshops/hsa05100.kpath.png&#39; to &#39;/home/ #&gt; mramos/.local/share/EnrichmentBrowser/results/reports/hsa05100_kpath.png&#39;, #&gt; reason &#39;Invalid cross-device link&#39; #&gt; Info: Downloading xml files for hsa04622, 1/1 pathways.. #&gt; Info: Downloading png files for hsa04622, 1/1 pathways.. #&gt; &#39;select()&#39; returned 1:1 mapping between keys and columns #&gt; Info: Working in directory /home/mramos/Source/github/BiocWorkshops #&gt; Info: Writing image file hsa04622.kpath.png #&gt; Warning in file.rename(from = pv.out, to = img.file): cannot rename file #&gt; &#39;/home/mramos/Source/github/BiocWorkshops/hsa04622.kpath.png&#39; to &#39;/home/ #&gt; mramos/.local/share/EnrichmentBrowser/results/reports/hsa04622_kpath.png&#39;, #&gt; reason &#39;Invalid cross-device link&#39; #&gt; Info: Downloading xml files for hsa05130, 1/1 pathways.. #&gt; Info: Downloading png files for hsa05130, 1/1 pathways.. #&gt; &#39;select()&#39; returned 1:1 mapping between keys and columns #&gt; Info: Working in directory /home/mramos/Source/github/BiocWorkshops #&gt; Info: Writing image file hsa05130.kpath.png #&gt; Warning in file.rename(from = pv.out, to = img.file): cannot rename file #&gt; &#39;/home/mramos/Source/github/BiocWorkshops/hsa05130.kpath.png&#39; to &#39;/home/ #&gt; mramos/.local/share/EnrichmentBrowser/results/reports/hsa05130_kpath.png&#39;, #&gt; reason &#39;Invalid cross-device link&#39; The resulting summary page includes for each significant gene set a gene report, which lists all genes of a set along with fold change and DE \\(p\\)-value (click on links in column NR.GENES), interactive overview plots such as heatmap and volcano plot (column SET.VIEW, supports mouse-over and click-on), for KEGG pathways: highlighting of differentially expressed genes on the pathway maps (column PATH.VIEW, supports mouse-over and click-on). As ORA works on the list of DE genes and not the actual expression values, it can be straightforward applied to RNA-seq data. However, as the gene sets here contain NCBI Entrez gene IDs and the airway dataset contains ENSEMBL gene ids, we first map the airway dataset to Entrez IDs. airSE &lt;- idMap(airSE, org=&quot;hsa&quot;, from=&quot;ENSEMBL&quot;, to=&quot;ENTREZID&quot;) #&gt; &#39;select()&#39; returned 1:many mapping between keys and columns #&gt; Excluded 1133 genes without a corresponding to.ID #&gt; Encountered 8 from.IDs with &gt;1 corresponding to.ID (a single to.ID was chosen for each of them) ora.air &lt;- sbea(method=&quot;ora&quot;, se=airSE, gs=hsa.gs, perm=0) gsRanking(ora.air) #&gt; DataFrame with 9 rows and 4 columns #&gt; GENE.SET #&gt; &lt;character&gt; #&gt; 1 hsa05206_MicroRNAs_in_cancer #&gt; 2 hsa05218_Melanoma #&gt; 3 hsa05214_Glioma #&gt; 4 hsa05131_Shigellosis #&gt; 5 hsa05410_Hypertrophic_cardiomyopathy_(HCM) #&gt; 6 hsa04670_Leukocyte_transendothelial_migration #&gt; 7 hsa05100_Bacterial_invasion_of_epithelial_cells #&gt; 8 hsa04514_Cell_adhesion_molecules_(CAMs) #&gt; 9 hsa05412_Arrhythmogenic_right_ventricular_cardiomyopathy_(ARVC) #&gt; NR.GENES NR.SIG.GENES P.VALUE #&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; #&gt; 1 118 68 0.000508 #&gt; 2 50 33 0.000662 #&gt; 3 48 30 0.00419 #&gt; 4 53 31 0.0142 #&gt; 5 53 31 0.0142 #&gt; 6 62 34 0.0353 #&gt; 7 60 33 0.036 #&gt; 8 60 33 0.036 #&gt; 9 48 27 0.0402 Note #1: Young et al., 2010, have reported biased results for ORA on RNA-seq data due to over-detection of differential expression for long and highly expressed transcripts. The goseq package and limma::goana implement possibilities to adjust ORA for gene length and abundance bias. Note #2: Independent of the expression data type under investigation, overlap between gene sets can result in redundant findings. This is well-documented for GO (parent-child structure, Rhee et al., 2008) and KEGG (pathway overlap/crosstalk, Donato et al., 2013). The topGO package (explicitly designed for GO) and mgsa (applicable to arbitrary gene set definitions) implement modifications of ORA to account for such redundancies. 5.12 Functional class scoring &amp; permutation testing A major limitation of ORA is that it restricts analysis to DE genes, excluding genes not satisfying the chosen significance threshold (typically the vast majority). This is resolved by gene set enrichment analysis (GSEA), which scores the tendency of gene set members to appear rather at the top or bottom of the ranked list of all measured genes Subramanian et al., 2005. The statistical significance of the enrichment score (ES) of a gene set is assessed via sample permutation, i.e. (1) sample labels (= group assignment) are shuffled, (2) per-gene DE statistics are recomputed, and (3) the enrichment score is recomputed. Repeating this procedure many times allows to determine the empirical distribution of the enrichment score and to compare the observed enrichment score against it. Here, we carry out GSEA with 1000 permutations. gsea.all &lt;- sbea(method=&quot;gsea&quot;, se=allSE, gs=hsa.gs, perm=1000) #&gt; Permutations: 1 -- 100 #&gt; Permutations: 101 -- 200 #&gt; Permutations: 201 -- 300 #&gt; Permutations: 301 -- 400 #&gt; Permutations: 401 -- 500 #&gt; Permutations: 501 -- 600 #&gt; Permutations: 601 -- 700 #&gt; Permutations: 701 -- 800 #&gt; Permutations: 801 -- 900 #&gt; Permutations: 901 -- 1000 #&gt; Processing ... gsRanking(gsea.all) #&gt; DataFrame with 20 rows and 4 columns #&gt; GENE.SET #&gt; &lt;character&gt; #&gt; 1 hsa05412_Arrhythmogenic_right_ventricular_cardiomyopathy_(ARVC) #&gt; 2 hsa04670_Leukocyte_transendothelial_migration #&gt; 3 hsa04520_Adherens_junction #&gt; 4 hsa04390_Hippo_signaling_pathway #&gt; 5 hsa05323_Rheumatoid_arthritis #&gt; ... ... #&gt; 16 hsa05217_Basal_cell_carcinoma #&gt; 17 hsa04210_Apoptosis #&gt; 18 hsa05130_Pathogenic_Escherichia_coli_infection #&gt; 19 hsa05410_Hypertrophic_cardiomyopathy_(HCM) #&gt; 20 hsa05131_Shigellosis #&gt; ES NES P.VALUE #&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; #&gt; 1 0.511 1.92 0 #&gt; 2 0.499 1.78 0 #&gt; 3 0.488 1.74 0 #&gt; 4 0.459 1.67 0 #&gt; 5 0.574 1.66 0.0019 #&gt; ... ... ... ... #&gt; 16 0.559 1.64 0.0248 #&gt; 17 0.424 1.44 0.0336 #&gt; 18 0.486 1.54 0.0347 #&gt; 19 0.386 1.45 0.0406 #&gt; 20 0.479 1.49 0.0436 As GSEA’s permutation procedure involves re-computation of per-gene DE statistics, adaptations are necessary for RNA-seq. The EnrichmentBrowser implements an accordingly adapted version of GSEA, which allows incorporation of limma/voom, edgeR, or DESeq2 for repeated DE re-computation within GSEA. However, this is computationally intensive (for limma/voom the least, for DESeq2 the most). Note the relatively long running times for only 100 permutations having used edgeR for DE analysis. gsea.air &lt;- sbea(method=&quot;gsea&quot;, se=airSE, gs=hsa.gs, perm=100) #&gt; 100 permutations completed While it might be in some cases necessary to apply permutation-based GSEA for RNA-seq data, there are also alternatives avoiding permutation. Among them is ROtAtion gene Set Testing (ROAST), which uses rotation instead of permutation Wu et al., 2010. roast.air &lt;- sbea(method=&quot;roast&quot;, se=airSE, gs=hsa.gs) gsRanking(roast.air) #&gt; DataFrame with 27 rows and 4 columns #&gt; GENE.SET NR.GENES DIR #&gt; &lt;character&gt; &lt;numeric&gt; &lt;numeric&gt; #&gt; 1 hsa05410_Hypertrophic_cardiomyopathy_(HCM) 53 1 #&gt; 2 hsa05134_Legionellosis 35 1 #&gt; 3 hsa05416_Viral_myocarditis 33 1 #&gt; 4 hsa00790_Folate_biosynthesis 11 1 #&gt; 5 hsa03030_DNA_replication 33 -1 #&gt; ... ... ... ... #&gt; 23 hsa04150_mTOR_signaling_pathway 50 1 #&gt; 24 hsa04350_TGF-beta_signaling_pathway 63 1 #&gt; 25 hsa00561_Glycerolipid_metabolism 39 1 #&gt; 26 hsa04621_NOD-like_receptor_signaling_pathway 40 -1 #&gt; 27 hsa04514_Cell_adhesion_molecules_(CAMs) 60 -1 #&gt; P.VALUE #&gt; &lt;numeric&gt; #&gt; 1 0.001 #&gt; 2 0.001 #&gt; 3 0.001 #&gt; 4 0.001 #&gt; 5 0.001 #&gt; ... ... #&gt; 23 0.027 #&gt; 24 0.029 #&gt; 25 0.032 #&gt; 26 0.033 #&gt; 27 0.035 A selection of additional methods is also available: sbeaMethods() #&gt; [1] &quot;ora&quot; &quot;safe&quot; &quot;gsea&quot; &quot;gsa&quot; &quot;padog&quot; #&gt; [6] &quot;globaltest&quot; &quot;roast&quot; &quot;camera&quot; &quot;gsva&quot; &quot;samgs&quot; #&gt; [11] &quot;ebm&quot; &quot;mgsa&quot; Exercise: Carry out a GO overrepresentation analysis for the allSE and airSE. How many significant gene sets do you observe in each case? 5.13 Network-based enrichment analysis Having found gene sets that show enrichment for differential expression, we are now interested whether these findings can be supported by known regulatory interactions. For example, we want to know whether transcription factors and their target genes are expressed in accordance to the connecting regulations (activation/inhibition). Such information is usually given in a gene regulatory network derived from specific experiments or compiled from the literature (Geistlinger et al., 2013 for an example). There are well-studied processes and organisms for which comprehensive and well-annotated regulatory networks are available, e.g. the RegulonDB for E. coli and Yeastract for S. cerevisiae. However, there are also cases where such a network is missing or at least incomplete. A basic workaround is to compile a network from regulations in pathway databases such as KEGG. hsa.grn &lt;- compileGRN(org=&quot;hsa&quot;, db=&quot;kegg&quot;) head(hsa.grn) #&gt; FROM TO TYPE #&gt; [1,] &quot;10000&quot; &quot;100132074&quot; &quot;-&quot; #&gt; [2,] &quot;10000&quot; &quot;1026&quot; &quot;-&quot; #&gt; [3,] &quot;10000&quot; &quot;1026&quot; &quot;+&quot; #&gt; [4,] &quot;10000&quot; &quot;1027&quot; &quot;-&quot; #&gt; [5,] &quot;10000&quot; &quot;10488&quot; &quot;+&quot; #&gt; [6,] &quot;10000&quot; &quot;107&quot; &quot;+&quot; Signaling pathway impact analysis (SPIA) is a network-based enrichment analysis method, which is explicitly designed for KEGG signaling pathways Tarca et al., 2009. The method evaluates whether expression changes are propagated across the pathway topology in combination with ORA. spia.all &lt;- nbea(method=&quot;spia&quot;, se=allSE, gs=hsa.gs, grn=hsa.grn, alpha=0.2) #&gt; #&gt; Done pathway 1 : RNA transport.. #&gt; Done pathway 2 : RNA degradation.. #&gt; Done pathway 3 : PPAR signaling pathway.. #&gt; Done pathway 4 : Fanconi anemia pathway.. #&gt; Done pathway 5 : MAPK signaling pathway.. #&gt; Done pathway 6 : ErbB signaling pathway.. #&gt; Done pathway 7 : Calcium signaling pathway.. #&gt; Done pathway 8 : Cytokine-cytokine receptor int.. #&gt; Done pathway 9 : Chemokine signaling pathway.. #&gt; Done pathway 10 : NF-kappa B signaling pathway.. #&gt; Done pathway 11 : Phosphatidylinositol signaling.. #&gt; Done pathway 12 : Neuroactive ligand-receptor in.. #&gt; Done pathway 13 : Cell cycle.. #&gt; Done pathway 14 : Oocyte meiosis.. #&gt; Done pathway 15 : p53 signaling pathway.. #&gt; Done pathway 16 : Sulfur relay system.. #&gt; Done pathway 17 : SNARE interactions in vesicula.. #&gt; Done pathway 18 : Regulation of autophagy.. #&gt; Done pathway 19 : Protein processing in endoplas.. #&gt; Done pathway 20 : Lysosome.. #&gt; Done pathway 21 : mTOR signaling pathway.. #&gt; Done pathway 22 : Apoptosis.. #&gt; Done pathway 23 : Vascular smooth muscle contrac.. #&gt; Done pathway 24 : Wnt signaling pathway.. #&gt; Done pathway 25 : Dorso-ventral axis formation.. #&gt; Done pathway 26 : Notch signaling pathway.. #&gt; Done pathway 27 : Hedgehog signaling pathway.. #&gt; Done pathway 28 : TGF-beta signaling pathway.. #&gt; Done pathway 29 : Axon guidance.. #&gt; Done pathway 30 : VEGF signaling pathway.. #&gt; Done pathway 31 : Osteoclast differentiation.. #&gt; Done pathway 32 : Focal adhesion.. #&gt; Done pathway 33 : ECM-receptor interaction.. #&gt; Done pathway 34 : Cell adhesion molecules (CAMs).. #&gt; Done pathway 35 : Adherens junction.. #&gt; Done pathway 36 : Tight junction.. #&gt; Done pathway 37 : Gap junction.. #&gt; Done pathway 38 : Complement and coagulation cas.. #&gt; Done pathway 39 : Antigen processing and present.. #&gt; Done pathway 40 : Toll-like receptor signaling p.. #&gt; Done pathway 41 : NOD-like receptor signaling pa.. #&gt; Done pathway 42 : RIG-I-like receptor signaling .. #&gt; Done pathway 43 : Cytosolic DNA-sensing pathway.. #&gt; Done pathway 44 : Jak-STAT signaling pathway.. #&gt; Done pathway 45 : Natural killer cell mediated c.. #&gt; Done pathway 46 : T cell receptor signaling path.. #&gt; Done pathway 47 : B cell receptor signaling path.. #&gt; Done pathway 48 : Fc epsilon RI signaling pathwa.. #&gt; Done pathway 49 : Fc gamma R-mediated phagocytos.. #&gt; Done pathway 50 : Leukocyte transendothelial mig.. #&gt; Done pathway 51 : Intestinal immune network for .. #&gt; Done pathway 52 : Circadian rhythm - mammal.. #&gt; Done pathway 53 : Long-term potentiation.. #&gt; Done pathway 54 : Neurotrophin signaling pathway.. #&gt; Done pathway 55 : Retrograde endocannabinoid sig.. #&gt; Done pathway 56 : Glutamatergic synapse.. #&gt; Done pathway 57 : Cholinergic synapse.. #&gt; Done pathway 58 : Serotonergic synapse.. #&gt; Done pathway 59 : GABAergic synapse.. #&gt; Done pathway 60 : Dopaminergic synapse.. #&gt; Done pathway 61 : Long-term depression.. #&gt; Done pathway 62 : Olfactory transduction.. #&gt; Done pathway 63 : Taste transduction.. #&gt; Done pathway 64 : Phototransduction.. #&gt; Done pathway 65 : Regulation of actin cytoskelet.. #&gt; Done pathway 66 : Insulin signaling pathway.. #&gt; Done pathway 67 : GnRH signaling pathway.. #&gt; Done pathway 68 : Progesterone-mediated oocyte m.. #&gt; Done pathway 69 : Melanogenesis.. #&gt; Done pathway 70 : Adipocytokine signaling pathwa.. #&gt; Done pathway 71 : Type II diabetes mellitus.. #&gt; Done pathway 72 : Type I diabetes mellitus.. #&gt; Done pathway 73 : Maturity onset diabetes of the.. #&gt; Done pathway 74 : Aldosterone-regulated sodium r.. #&gt; Done pathway 75 : Endocrine and other factor-reg.. #&gt; Done pathway 76 : Vasopressin-regulated water re.. #&gt; Done pathway 77 : Salivary secretion.. #&gt; Done pathway 78 : Gastric acid secretion.. #&gt; Done pathway 79 : Pancreatic secretion.. #&gt; Done pathway 80 : Carbohydrate digestion and abs.. #&gt; Done pathway 81 : Bile secretion.. #&gt; Done pathway 82 : Mineral absorption.. #&gt; Done pathway 83 : Alzheimer&#39;s disease.. #&gt; Done pathway 84 : Parkinson&#39;s disease.. #&gt; Done pathway 85 : Amyotrophic lateral sclerosis .. #&gt; Done pathway 86 : Huntington&#39;s disease.. #&gt; Done pathway 87 : Prion diseases.. #&gt; Done pathway 88 : Cocaine addiction.. #&gt; Done pathway 89 : Amphetamine addiction.. #&gt; Done pathway 90 : Morphine addiction.. #&gt; Done pathway 91 : Alcoholism.. #&gt; Done pathway 92 : Bacterial invasion of epitheli.. #&gt; Done pathway 93 : Vibrio cholerae infection.. #&gt; Done pathway 94 : Epithelial cell signaling in H.. #&gt; Done pathway 95 : Pathogenic Escherichia coli in.. #&gt; Done pathway 96 : Shigellosis.. #&gt; Done pathway 97 : Salmonella infection.. #&gt; Done pathway 98 : Pertussis.. #&gt; Done pathway 99 : Legionellosis.. #&gt; Done pathway 100 : Leishmaniasis.. #&gt; Done pathway 101 : Chagas disease (American trypa.. #&gt; Done pathway 102 : African trypanosomiasis.. #&gt; Done pathway 103 : Malaria.. #&gt; Done pathway 104 : Toxoplasmosis.. #&gt; Done pathway 105 : Amoebiasis.. #&gt; Done pathway 106 : Staphylococcus aureus infectio.. #&gt; Done pathway 107 : Tuberculosis.. #&gt; Done pathway 108 : Hepatitis C.. #&gt; Done pathway 109 : Measles.. #&gt; Done pathway 110 : Influenza A.. #&gt; Done pathway 111 : HTLV-I infection.. #&gt; Done pathway 112 : Herpes simplex infection.. #&gt; Done pathway 113 : Epstein-Barr virus infection.. #&gt; Done pathway 114 : Pathways in cancer.. #&gt; Done pathway 115 : Transcriptional misregulation .. #&gt; Done pathway 116 : Viral carcinogenesis.. #&gt; Done pathway 117 : Colorectal cancer.. #&gt; Done pathway 118 : Renal cell carcinoma.. #&gt; Done pathway 119 : Pancreatic cancer.. #&gt; Done pathway 120 : Endometrial cancer.. #&gt; Done pathway 121 : Glioma.. #&gt; Done pathway 122 : Prostate cancer.. #&gt; Done pathway 123 : Thyroid cancer.. #&gt; Done pathway 124 : Basal cell carcinoma.. #&gt; Done pathway 125 : Melanoma.. #&gt; Done pathway 126 : Bladder cancer.. #&gt; Done pathway 127 : Chronic myeloid leukemia.. #&gt; Done pathway 128 : Acute myeloid leukemia.. #&gt; Done pathway 129 : Small cell lung cancer.. #&gt; Done pathway 130 : Non-small cell lung cancer.. #&gt; Done pathway 131 : Asthma.. #&gt; Done pathway 132 : Autoimmune thyroid disease.. #&gt; Done pathway 133 : Systemic lupus erythematosus.. #&gt; Done pathway 134 : Rheumatoid arthritis.. #&gt; Done pathway 135 : Allograft rejection.. #&gt; Done pathway 136 : Graft-versus-host disease.. #&gt; Done pathway 137 : Arrhythmogenic right ventricul.. #&gt; Done pathway 138 : Dilated cardiomyopathy.. #&gt; Done pathway 139 : Viral myocarditis.. #&gt; Finished SPIA analysis gsRanking(spia.all) #&gt; DataFrame with 7 rows and 6 columns #&gt; GENE.SET SIZE NDE #&gt; &lt;character&gt; &lt;numeric&gt; &lt;numeric&gt; #&gt; 1 hsa04620_Toll-like_receptor_signaling_pathway 74 6 #&gt; 2 hsa05202_Transcriptional_misregulation_in_cancer 89 9 #&gt; 3 hsa05416_Viral_myocarditis 45 5 #&gt; 4 hsa04630_Jak-STAT_signaling_pathway 72 8 #&gt; 5 hsa04910_Insulin_signaling_pathway 115 5 #&gt; 6 hsa05143_African_trypanosomiasis 22 4 #&gt; 7 hsa04978_Mineral_absorption 3 1 #&gt; T.ACT STATUS P.VALUE #&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; #&gt; 1 -3.62 -1 0.0497 #&gt; 2 -0.209 -1 0.0726 #&gt; 3 2.98 1 0.0768 #&gt; 4 -1.06 -1 0.0861 #&gt; 5 -7.35 -1 0.153 #&gt; 6 0.263 1 0.193 #&gt; 7 0 -1 0.199 More generally applicable is gene graph enrichment analysis (GGEA), which evaluates consistency of interactions in a given gene regulatory network with the observed expression data Geistlinger et al., 2011. ggea.all &lt;- nbea(method=&quot;ggea&quot;, se=allSE, gs=hsa.gs, grn=hsa.grn) gsRanking(ggea.all) #&gt; DataFrame with 9 rows and 5 columns #&gt; GENE.SET #&gt; &lt;character&gt; #&gt; 1 hsa04390_Hippo_signaling_pathway #&gt; 2 hsa05416_Viral_myocarditis #&gt; 3 hsa05217_Basal_cell_carcinoma #&gt; 4 hsa04520_Adherens_junction #&gt; 5 hsa04350_TGF-beta_signaling_pathway #&gt; 6 hsa05412_Arrhythmogenic_right_ventricular_cardiomyopathy_(ARVC) #&gt; 7 hsa04910_Insulin_signaling_pathway #&gt; 8 hsa04622_RIG-I-like_receptor_signaling_pathway #&gt; 9 hsa04210_Apoptosis #&gt; NR.RELS RAW.SCORE NORM.SCORE P.VALUE #&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; #&gt; 1 62 22.8 0.367 0.002 #&gt; 2 7 3.3 0.471 0.003 #&gt; 3 18 6.92 0.385 0.00799 #&gt; 4 11 4.5 0.409 0.014 #&gt; 5 14 5.36 0.383 0.024 #&gt; 6 4 1.75 0.437 0.032 #&gt; 7 31 11.1 0.359 0.039 #&gt; 8 35 12.5 0.356 0.041 #&gt; 9 47 16.5 0.35 0.044 nbeaMethods() #&gt; [1] &quot;ggea&quot; &quot;spia&quot; &quot;pathnet&quot; &quot;degraph&quot; &quot;ganpa&quot; #&gt; [6] &quot;cepa&quot; &quot;topologygsa&quot; &quot;netgsa&quot; Note #1: As network-based enrichment methods typically do not involve sample permutation but rather network permutation, thus avoiding DE re-computation, they can likewise be applied to RNA-seq data. Note #2: Given the various enrichment methods with individual benefits and limitations, combining multiple methods can be beneficial, e.g. combined application of a set-based and a network-based method. This has been shown to filter out spurious hits of individual methods and to reduce the outcome to gene sets accumulating evidence from different methods Geistlinger et al., 2016, Alhamdoosh et al., 2017. The function combResults implements the straightforward combination of results, thereby facilitating seamless comparison of results across methods. For demonstration, we use the ORA and GSEA results for the ALL dataset from the previous section: res.list &lt;- list(ora.all, gsea.all) comb.res &lt;- combResults(res.list) gsRanking(comb.res) #&gt; DataFrame with 20 rows and 6 columns #&gt; GENE.SET #&gt; &lt;character&gt; #&gt; 1 hsa05412_Arrhythmogenic_right_ventricular_cardiomyopathy_(ARVC) #&gt; 2 hsa05202_Transcriptional_misregulation_in_cancer #&gt; 3 hsa04670_Leukocyte_transendothelial_migration #&gt; 4 hsa04520_Adherens_junction #&gt; 5 hsa05206_MicroRNAs_in_cancer #&gt; ... ... #&gt; 16 hsa05410_Hypertrophic_cardiomyopathy_(HCM) #&gt; 17 hsa04514_Cell_adhesion_molecules_(CAMs) #&gt; 18 hsa04621_NOD-like_receptor_signaling_pathway #&gt; 19 hsa04622_RIG-I-like_receptor_signaling_pathway #&gt; 20 hsa04350_TGF-beta_signaling_pathway #&gt; ORA.RANK GSEA.RANK MEAN.RANK ORA.PVAL GSEA.PVAL #&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; #&gt; 1 5.1 10.3 7.7 0.0717 0 #&gt; 2 2.6 17.9 10.3 0.0351 0.00374 #&gt; 3 10.3 10.3 10.3 0.122 0 #&gt; 4 20.5 10.3 15.4 0.201 0 #&gt; 5 23.1 25.6 24.4 0.225 0.00781 #&gt; ... ... ... ... ... ... #&gt; 16 41 48.7 44.9 0.403 0.0406 #&gt; 17 69.2 23.1 46.2 0.649 0.0058 #&gt; 18 61.5 33.3 47.4 0.631 0.0172 #&gt; 19 15.4 84.6 50 0.178 0.354 #&gt; 20 38.5 61.5 50 0.39 0.113 Exercise: Carry out SPIA and GGEA for the airSE and combine the results. How many gene sets are rendered significant by both methods? 5.14 Genomic region enrichment analysis Microarrays and next-generation sequencing are also widely applied for large-scale detection of variable and regulatory genomic regions, e.g. single nucleotide polymorphisms, copy number variations, and transcription factor binding sites. Such experimentally-derived genomic region sets are raising similar questions regarding functional enrichment as in gene expression data analysis. Of particular interest is thereby whether experimentally-derived regions overlap more (enrichment) or less (depletion) than expected by chance with regions representing known functional features such as genes or promoters. The regioneR package implements a general framework for testing overlaps of genomic regions based on permutation sampling. This allows to repeatedly sample random regions from the genome, matching size and chromosomal distribution of the region set under study. By recomputing the overlap with the functional features in each permutation, statistical significance of the observed overlap can be assessed. suppressPackageStartupMessages(library(regioneR)) To demonstrate the basic functionality of the package, we consider the overlap of gene promoter regions and CpG islands in the human genome. We expect to find an enrichment as promoter regions are known to be GC-rich. Hence, is the overlap between CpG islands and promoters greater than expected by chance? We use the collection of CpG islands described in Wu et al., 2010 and restrict them to the set of canonical chromosomes 1-23, X, and Y. cpgHMM &lt;- toGRanges(&quot;http://www.haowulab.org/software/makeCGI/model-based-cpg-islands-hg19.txt&quot;) cpgHMM &lt;- filterChromosomes(cpgHMM, chr.type=&quot;canonical&quot;) cpgHMM &lt;- sort(cpgHMM) cpgHMM #&gt; GRanges object with 63705 ranges and 5 metadata columns: #&gt; seqnames ranges strand | length CpGcount #&gt; &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;integer&gt; &lt;integer&gt; #&gt; [1] chr1 10497-11241 * | 745 110 #&gt; [2] chr1 28705-29791 * | 1087 115 #&gt; [3] chr1 135086-135805 * | 720 42 #&gt; [4] chr1 136164-137362 * | 1199 71 #&gt; [5] chr1 137665-138121 * | 457 22 #&gt; ... ... ... ... . ... ... #&gt; [63701] chrY 59213702-59214290 * | 589 43 #&gt; [63702] chrY 59240512-59241057 * | 546 40 #&gt; [63703] chrY 59348047-59348370 * | 324 17 #&gt; [63704] chrY 59349137-59349565 * | 429 31 #&gt; [63705] chrY 59361489-59362401 * | 913 128 #&gt; GCcontent pctGC obsExp #&gt; &lt;integer&gt; &lt;numeric&gt; &lt;numeric&gt; #&gt; [1] 549 0.737 1.106 #&gt; [2] 792 0.729 0.818 #&gt; [3] 484 0.672 0.548 #&gt; [4] 832 0.694 0.524 #&gt; [5] 301 0.659 0.475 #&gt; ... ... ... ... #&gt; [63701] 366 0.621 0.765 #&gt; [63702] 369 0.676 0.643 #&gt; [63703] 193 0.596 0.593 #&gt; [63704] 276 0.643 0.7 #&gt; [63705] 650 0.712 1.108 #&gt; ------- #&gt; seqinfo: 24 sequences from an unspecified genome; no seqlengths Analogously, we load promoter regions in the hg19 human genome assembly as available from UCSC: promoters &lt;- toGRanges(&quot;http://gattaca.imppc.org/regioner/data/UCSC.promoters.hg19.bed&quot;) promoters &lt;- filterChromosomes(promoters, chr.type=&quot;canonical&quot;) promoters &lt;- sort(promoters) promoters #&gt; GRanges object with 49049 ranges and 3 metadata columns: #&gt; seqnames ranges strand | V4 V5 V6 #&gt; &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;factor&gt; &lt;factor&gt; &lt;factor&gt; #&gt; [1] chr1 9873-12073 * | TSS . + #&gt; [2] chr1 16565-18765 * | TSS . - #&gt; [3] chr1 17551-19751 * | TSS . - #&gt; [4] chr1 17861-20061 * | TSS . - #&gt; [5] chr1 19559-21759 * | TSS . - #&gt; ... ... ... ... . ... ... ... #&gt; [49045] chrY 59211948-59214148 * | TSS . + #&gt; [49046] chrY 59328251-59330451 * | TSS . + #&gt; [49047] chrY 59350972-59353172 * | TSS . + #&gt; [49048] chrY 59352984-59355184 * | TSS . + #&gt; [49049] chrY 59360654-59362854 * | TSS . - #&gt; ------- #&gt; seqinfo: 24 sequences from an unspecified genome; no seqlengths To speed up the example, we restrict analysis to chromosomes 21 and 22. Note that this is done for demonstration only. To make an accurate claim, the complete region set should be used (which, however, runs considerably longer). cpg &lt;- cpgHMM[seqnames(cpgHMM) %in% c(&quot;chr21&quot;, &quot;chr22&quot;)] prom &lt;- promoters[seqnames(promoters) %in% c(&quot;chr21&quot;, &quot;chr22&quot;)] Now, we are applying an overlap permutation test with 100 permutations (ntimes=100), while maintaining chromosomal distribution of the CpG island region set (per.chromosome=TRUE). Furthermore, we use the option count.once=TRUE to count an overlapping CpG island only once, even if it overlaps with 2 or more promoters. Note that we use 100 permutations for demonstration only. To draw robust conclusions a minimum of 1000 permutations should be carried out. pt &lt;- overlapPermTest(cpg, prom, genome=&quot;hg19&quot;, ntimes=100, per.chromosome=TRUE, count.once=TRUE) pt #&gt; $numOverlaps #&gt; P-value: 0.0099009900990099 #&gt; Z-score: 47.2232 #&gt; Number of iterations: 100 #&gt; Alternative: greater #&gt; Evaluation of the original region set: 719 #&gt; Evaluation function: numOverlaps #&gt; Randomization function: randomizeRegions #&gt; #&gt; attr(,&quot;class&quot;) #&gt; [1] &quot;permTestResultsList&quot; summary(pt[[1]]$permuted) #&gt; Min. 1st Qu. Median Mean 3rd Qu. Max. #&gt; 145.0 161.0 170.0 168.9 177.0 194.0 The resulting permutation p-value indicates a significant enrichment. Out of the 2859 CpG islands, 719 overlap with at least one promoter. In contrast, when repeatedly drawing random regions matching the CpG islands in size and chromosomal distribution, the mean number of overlapping regions across permutations was 117.7 \\(\\pm\\) 11.8. Note #1: The function regioneR::permTest allows to incorporate user-defined functions for randomizing regions and evaluating additional measures of overlap such as total genomic size in bp. Note #2: The LOLA package implements a genomic region ORA, which assesses genomic region overlap based on the hypergeometric distribution using a library of pre-defined functional region sets. "],
["rna-seq-analysis-is-easy-as-1-2-3-with-limma-glimma-and-edger.html", "6 RNA-seq analysis is easy as 1-2-3 with limma, Glimma and edgeR 6.1 Instructor name and contact information 6.2 Workshop Description 6.3 Workshop goals and objectives 6.4 Introduction 6.5 Data packaging 6.6 Data pre-processing 6.7 Differential expression analysis", " 6 RNA-seq analysis is easy as 1-2-3 with limma, Glimma and edgeR 6.1 Instructor name and contact information Charity Law (law@wehi.edu.au) 6.2 Workshop Description In this instructor-led live demo, we analyse RNA-sequencing data from the mouse mammary gland, demonstrating use of the popular edgeR package to import, organise, filter and normalise the data, followed by the limma package with its voom method, linear modelling and empirical Bayes moderation to assess differential expression and graphical representations. This pipeline is further enhanced by the Glimma package which enables interactive exploration of the results so that individual samples and genes can be examined by the user. The complete analysis offered by these three packages highlights the ease with which researchers can turn the raw counts from an RNA-sequencing experiment into biological insights using Bioconductor. The complete workflow is available at http://master.bioconductor.org/packages/release/workflows/html/RNAseq123.html . 6.2.1 Pre-requisites Basic knowledge of RNA-sequencing Basic knowledge of R syntax, R object classes and object manipulation 6.2.2 Workshop Participation Participants can watch the live demo, or may prefer to follow the demonstration by bringing their laptops along. To follow the analysis on their own laptops, participants need to install the RNAseq123 workflow by running source(&quot;https://bioconductor.org/biocLite.R&quot;) biocLite(&quot;RNAseq123&quot;) in R. The relevant sequencing data should also be download in advance. url &lt;- &quot;https://www.ncbi.nlm.nih.gov/geo/download/?acc=GSE63310&amp;format=file&quot; utils::download.file(url, destfile=&quot;GSE63310_RAW.tar&quot;, mode=&quot;wb&quot;) utils::untar(&quot;GSE63310_RAW.tar&quot;, exdir = &quot;.&quot;) files &lt;- c(&quot;GSM1545535_10_6_5_11.txt&quot;, &quot;GSM1545536_9_6_5_11.txt&quot;, &quot;GSM1545538_purep53.txt&quot;, &quot;GSM1545539_JMS8-2.txt&quot;, &quot;GSM1545540_JMS8-3.txt&quot;, &quot;GSM1545541_JMS8-4.txt&quot;, &quot;GSM1545542_JMS8-5.txt&quot;, &quot;GSM1545544_JMS9-P7c.txt&quot;, &quot;GSM1545545_JMS9-P8c.txt&quot;) for(i in paste(files, &quot;.gz&quot;, sep=&quot;&quot;)) R.utils::gunzip(i, overwrite=TRUE) Due to time restraints, extra help regarding R package installation and coding errors will not be addressed during the workshop. 6.2.3 R / Bioconductor packages used Bioconductor: limma, Glimma, edgeR, Mus.musculus CRAN: RColorBrewer, gplots 6.2.4 Time outline Activity Time Introduction 5mins Data packaging 10mins Data pre-processing 15mins Differential expression analysis 30mins 6.3 Workshop goals and objectives The key steps to RNA-seq data analysis are described in this workshop with basic statistical theory of methods used. The goal is to allow beginner-analysts of RNA-seq data to become familiar with each of the steps involved, as well as completing a standard analysis pipeline from start to finish. 6.3.1 Learning goals learn how to analyse RNA-seq data identify methods for pre-processing data understand linear models used in differential expression analysis examine plots for data exploration and result representation 6.3.2 Learning objectives read in count data and format as a DGEList-object annotate Entrez gene identifiers with gene information filter out lowly expressed genes normalise gene expression values unsupervised clustering of samples (standard and interactive plots) linear modelling for comparisons of interest remove heteroscedascity examine the number of differentially expressed genes mean-difference plots (standard and interactive plots) heatmaps 6.4 Introduction RNA-sequencing (RNA-seq) has become the primary technology used for gene expression profiling, with the genome-wide detection of differentially expressed genes between two or more conditions of interest one of the most commonly asked questions by researchers. The edgeR and limma packages available from the Bioconductor project offer a well-developed suite of statistical methods for dealing with this question for RNA-seq data. In this article, we describe an edgeR - limma workflow for analysing RNA-seq data that takes gene-level counts as its input, and moves through pre-processing and exploratory data analysis before obtaining lists of differentially expressed (DE) genes and gene signatures. This analysis is enhanced through the use of interactive graphics from the Glimma package, that allows for a more detailed exploration of the data at both the sample and gene-level than is possible using static R plots. The experiment analysed in this workflow is from Sheridan et al. (2015) and consists of three cell populations (basal, luminal progenitor (LP) and mature luminal (ML)) sorted from the mammary glands of female virgin mice, each profiled in triplicate. RNA samples were sequenced across three batches on an Illumina HiSeq 2000 to obtain 100 base-pair single-end reads. The analysis outlined in this article assumes that reads obtained from an RNA-seq experiment have been aligned to an appropriate reference genome and summarised into counts associated with gene-specific regions. In this instance, reads were aligned to the mouse reference genome (mm10) using the R based pipeline available in the Rsubread package (specifically the align function followed by featureCounts for gene-level summarisation based on the in-built mm10 RefSeq-based annotation). Count data for these samples can be downloaded from the Gene Expression Omnibus (GEO) http://www.ncbi.nlm.nih.gov/geo/ using GEO Series accession number GSE63310. Further information on experimental design and sample preparation is also available from GEO under this accession number. library(limma) library(Glimma) library(edgeR) library(Mus.musculus) #&gt; Loading required package: AnnotationDbi #&gt; Loading required package: stats4 #&gt; Loading required package: BiocGenerics #&gt; Loading required package: parallel #&gt; #&gt; Attaching package: &#39;BiocGenerics&#39; #&gt; The following objects are masked from &#39;package:parallel&#39;: #&gt; #&gt; clusterApply, clusterApplyLB, clusterCall, clusterEvalQ, #&gt; clusterExport, clusterMap, parApply, parCapply, parLapply, #&gt; parLapplyLB, parRapply, parSapply, parSapplyLB #&gt; The following object is masked from &#39;package:limma&#39;: #&gt; #&gt; plotMA #&gt; The following objects are masked from &#39;package:stats&#39;: #&gt; #&gt; IQR, mad, sd, var, xtabs #&gt; The following objects are masked from &#39;package:base&#39;: #&gt; #&gt; anyDuplicated, append, as.data.frame, basename, cbind, #&gt; colMeans, colnames, colSums, dirname, do.call, duplicated, #&gt; eval, evalq, Filter, Find, get, grep, grepl, intersect, #&gt; is.unsorted, lapply, lengths, Map, mapply, match, mget, order, #&gt; paste, pmax, pmax.int, pmin, pmin.int, Position, rank, rbind, #&gt; Reduce, rowMeans, rownames, rowSums, sapply, setdiff, sort, #&gt; table, tapply, union, unique, unsplit, which, which.max, #&gt; which.min #&gt; Loading required package: Biobase #&gt; Welcome to Bioconductor #&gt; #&gt; Vignettes contain introductory material; view with #&gt; &#39;browseVignettes()&#39;. To cite Bioconductor, see #&gt; &#39;citation(&quot;Biobase&quot;)&#39;, and for packages &#39;citation(&quot;pkgname&quot;)&#39;. #&gt; Loading required package: IRanges #&gt; Loading required package: S4Vectors #&gt; #&gt; Attaching package: &#39;S4Vectors&#39; #&gt; The following object is masked from &#39;package:base&#39;: #&gt; #&gt; expand.grid #&gt; Loading required package: OrganismDbi #&gt; Loading required package: GenomicFeatures #&gt; Loading required package: GenomeInfoDb #&gt; Loading required package: GenomicRanges #&gt; Loading required package: GO.db #&gt; #&gt; Loading required package: org.Mm.eg.db #&gt; #&gt; Loading required package: TxDb.Mmusculus.UCSC.mm10.knownGene 6.5 Data packaging dir.create(&quot;Law_RNAseq123&quot;) setwd(&quot;Law_RNAseq123&quot;) url &lt;- &quot;https://www.ncbi.nlm.nih.gov/geo/download/?acc=GSE63310&amp;format=file&quot; utils::download.file(url, destfile=&quot;GSE63310_RAW.tar&quot;, mode=&quot;wb&quot;) utils::untar(&quot;GSE63310_RAW.tar&quot;, exdir = &quot;.&quot;) files &lt;- c(&quot;GSM1545535_10_6_5_11.txt&quot;, &quot;GSM1545536_9_6_5_11.txt&quot;, &quot;GSM1545538_purep53.txt&quot;, &quot;GSM1545539_JMS8-2.txt&quot;, &quot;GSM1545540_JMS8-3.txt&quot;, &quot;GSM1545541_JMS8-4.txt&quot;, &quot;GSM1545542_JMS8-5.txt&quot;, &quot;GSM1545544_JMS9-P7c.txt&quot;, &quot;GSM1545545_JMS9-P8c.txt&quot;) for(i in paste(files, &quot;.gz&quot;, sep=&quot;&quot;)) R.utils::gunzip(i, overwrite=TRUE) 6.5.1 Reading in count-data To get started with this analysis, download the file GSE63310_RAW.tar available online from https://www.ncbi.nlm.nih.gov/geo/download/?acc=GSE63310&amp;format=file, and extract the relevant files from this archive. Each of these text files contains the raw gene-level counts for a given sample. Note that our analysis only includes the basal, LP and ML samples from this experiment (see associated file names below). read.delim(file.path(&quot;Law_RNAseq123&quot;, files[1]), nrow=5) #&gt; EntrezID GeneLength Count #&gt; 1 497097 3634 1 #&gt; 2 100503874 3259 0 #&gt; 3 100038431 1634 0 #&gt; 4 19888 9747 0 #&gt; 5 20671 3130 1 Whilst each of the nine text files can be read into R separately and combined into a matrix of counts, edgeR offers a convenient way to do this in one step using the readDGE function. The resulting DGEList-object contains a matrix of counts with 27,179 rows associated with unique Entrez gene identifiers (IDs) and nine columns associated with the individual samples in the experiment. x &lt;- readDGE(file.path(&quot;Law_RNAseq123&quot;, files), columns=c(1,3)) class(x) #&gt; [1] &quot;DGEList&quot; #&gt; attr(,&quot;package&quot;) #&gt; [1] &quot;edgeR&quot; dim(x) #&gt; [1] 27179 9 If the counts from all samples were stored in a single file, the data can be read into R and then converted into a DGEList-object using the DGEList function. 6.5.2 Organising sample information For downstream analysis, sample-level information related to the experimental design needs to be associated with the columns of the counts matrix. This should include experimental variables, both biological and technical, that could have an effect on expression levels. Examples include cell type (basal, LP and ML in this experiment), genotype (wild-type, knock-out), phenotype (disease status, sex, age), sample treatment (drug, control) and batch information (date experiment was performed if samples were collected and analysed at distinct time points) to name just a few. Our DGEList-object contains a samples data frame that stores both cell type (or group) and batch (sequencing lane) information, each of which consists of three distinct levels. Note that within x$samples, library sizes are automatically calculated for each sample and normalisation factors are set to 1. For simplicity, we remove the GEO sample IDs (GSM*) from the column names of our DGEList-object x. samplenames &lt;- substring(colnames(x), 12, nchar(colnames(x))) samplenames #&gt; [1] &quot;23/GSM1545535_10_6_5_11&quot; &quot;23/GSM1545536_9_6_5_11&quot; #&gt; [3] &quot;23/GSM1545538_purep53&quot; &quot;23/GSM1545539_JMS8-2&quot; #&gt; [5] &quot;23/GSM1545540_JMS8-3&quot; &quot;23/GSM1545541_JMS8-4&quot; #&gt; [7] &quot;23/GSM1545542_JMS8-5&quot; &quot;23/GSM1545544_JMS9-P7c&quot; #&gt; [9] &quot;23/GSM1545545_JMS9-P8c&quot; colnames(x) &lt;- samplenames group &lt;- as.factor(c(&quot;LP&quot;, &quot;ML&quot;, &quot;Basal&quot;, &quot;Basal&quot;, &quot;ML&quot;, &quot;LP&quot;, &quot;Basal&quot;, &quot;ML&quot;, &quot;LP&quot;)) x$samples$group &lt;- group lane &lt;- as.factor(rep(c(&quot;L004&quot;,&quot;L006&quot;,&quot;L008&quot;), c(3,4,2))) x$samples$lane &lt;- lane x$samples #&gt; files group #&gt; 23/GSM1545535_10_6_5_11 Law_RNAseq123/GSM1545535_10_6_5_11.txt LP #&gt; 23/GSM1545536_9_6_5_11 Law_RNAseq123/GSM1545536_9_6_5_11.txt ML #&gt; 23/GSM1545538_purep53 Law_RNAseq123/GSM1545538_purep53.txt Basal #&gt; 23/GSM1545539_JMS8-2 Law_RNAseq123/GSM1545539_JMS8-2.txt Basal #&gt; 23/GSM1545540_JMS8-3 Law_RNAseq123/GSM1545540_JMS8-3.txt ML #&gt; 23/GSM1545541_JMS8-4 Law_RNAseq123/GSM1545541_JMS8-4.txt LP #&gt; 23/GSM1545542_JMS8-5 Law_RNAseq123/GSM1545542_JMS8-5.txt Basal #&gt; 23/GSM1545544_JMS9-P7c Law_RNAseq123/GSM1545544_JMS9-P7c.txt ML #&gt; 23/GSM1545545_JMS9-P8c Law_RNAseq123/GSM1545545_JMS9-P8c.txt LP #&gt; lib.size norm.factors lane #&gt; 23/GSM1545535_10_6_5_11 32863052 1 L004 #&gt; 23/GSM1545536_9_6_5_11 35335491 1 L004 #&gt; 23/GSM1545538_purep53 57160817 1 L004 #&gt; 23/GSM1545539_JMS8-2 51368625 1 L006 #&gt; 23/GSM1545540_JMS8-3 75795034 1 L006 #&gt; 23/GSM1545541_JMS8-4 60517657 1 L006 #&gt; 23/GSM1545542_JMS8-5 55086324 1 L006 #&gt; 23/GSM1545544_JMS9-P7c 21311068 1 L008 #&gt; 23/GSM1545545_JMS9-P8c 19958838 1 L008 6.5.3 Organising gene annotations A second data frame named genes in the DGEList-object is used to store gene-level information associated with rows of the counts matrix. This information can be retrieved using organism specific packages such as Mus.musculus for mouse (or Homo.sapiens for human) or the biomaRt package which interfaces the Ensembl genome databases in order to perform gene annotation. The type of information that can be retrieved includes gene symbols, gene names, chromosome names and locations, Entrez gene IDs, Refseq gene IDs and Ensembl gene IDs to name just a few. biomaRt primarily works off Ensembl gene IDs, whereas Mus.musculus packages information from various sources and allows users to choose between many different gene IDs as the key. The Entrez gene IDs available in our dataset were annotated using the Mus.musculus package to retrieve associated gene symbols and chromosome information. geneid &lt;- rownames(x) genes &lt;- select(Mus.musculus, keys=geneid, columns=c(&quot;SYMBOL&quot;, &quot;TXCHROM&quot;), keytype=&quot;ENTREZID&quot;) head(genes) #&gt; ENTREZID SYMBOL TXCHROM #&gt; 1 497097 Xkr4 chr1 #&gt; 2 100503874 Gm19938 &lt;NA&gt; #&gt; 3 100038431 Gm10568 &lt;NA&gt; #&gt; 4 19888 Rp1 chr1 #&gt; 5 20671 Sox17 chr1 #&gt; 6 27395 Mrpl15 chr1 As with any gene ID, Entrez gene IDs may not map one-to-one to the gene information of interest. It is important to check for duplicated gene IDs and to understand the source of duplication before resolving them. Our gene annotation contains 28 genes that map to multiple chromosomes (e.g. gene Gm1987 is associated with chr4 and chr4_JH584294_random and microRNA Mir5098 is associated with chr2, chr5, chr8, chr11 and chr17). To resolve duplicate gene IDs one could combine all chromosome information from the multi-mapped genes, such that gene Gm1987 would be is assigned to chr4 and chr4_JH584294_random, or select one of the chromosomes to represent the gene with duplicate annotation. For simplicity we do the latter, keeping only the first occurrence of each gene ID. genes &lt;- genes[!duplicated(genes$ENTREZID),] In this example, the gene order is the same in both the annotation and the data object. If this is not the case due to missing and/or rearranged gene IDs, the match function can be used to order genes correctly. The data frame of gene annotations is then added to the data object and neatly packaged in a DGEList-object containing raw count data with associated sample information and gene annotations. x$genes &lt;- genes x #&gt; An object of class &quot;DGEList&quot; #&gt; $samples #&gt; files group #&gt; 23/GSM1545535_10_6_5_11 Law_RNAseq123/GSM1545535_10_6_5_11.txt LP #&gt; 23/GSM1545536_9_6_5_11 Law_RNAseq123/GSM1545536_9_6_5_11.txt ML #&gt; 23/GSM1545538_purep53 Law_RNAseq123/GSM1545538_purep53.txt Basal #&gt; 23/GSM1545539_JMS8-2 Law_RNAseq123/GSM1545539_JMS8-2.txt Basal #&gt; 23/GSM1545540_JMS8-3 Law_RNAseq123/GSM1545540_JMS8-3.txt ML #&gt; 23/GSM1545541_JMS8-4 Law_RNAseq123/GSM1545541_JMS8-4.txt LP #&gt; 23/GSM1545542_JMS8-5 Law_RNAseq123/GSM1545542_JMS8-5.txt Basal #&gt; 23/GSM1545544_JMS9-P7c Law_RNAseq123/GSM1545544_JMS9-P7c.txt ML #&gt; 23/GSM1545545_JMS9-P8c Law_RNAseq123/GSM1545545_JMS9-P8c.txt LP #&gt; lib.size norm.factors lane #&gt; 23/GSM1545535_10_6_5_11 32863052 1 L004 #&gt; 23/GSM1545536_9_6_5_11 35335491 1 L004 #&gt; 23/GSM1545538_purep53 57160817 1 L004 #&gt; 23/GSM1545539_JMS8-2 51368625 1 L006 #&gt; 23/GSM1545540_JMS8-3 75795034 1 L006 #&gt; 23/GSM1545541_JMS8-4 60517657 1 L006 #&gt; 23/GSM1545542_JMS8-5 55086324 1 L006 #&gt; 23/GSM1545544_JMS9-P7c 21311068 1 L008 #&gt; 23/GSM1545545_JMS9-P8c 19958838 1 L008 #&gt; #&gt; $counts #&gt; Samples #&gt; Tags 23/GSM1545535_10_6_5_11 23/GSM1545536_9_6_5_11 #&gt; 497097 1 2 #&gt; 100503874 0 0 #&gt; 100038431 0 0 #&gt; 19888 0 1 #&gt; 20671 1 1 #&gt; Samples #&gt; Tags 23/GSM1545538_purep53 23/GSM1545539_JMS8-2 #&gt; 497097 342 526 #&gt; 100503874 5 6 #&gt; 100038431 0 0 #&gt; 19888 0 0 #&gt; 20671 76 40 #&gt; Samples #&gt; Tags 23/GSM1545540_JMS8-3 23/GSM1545541_JMS8-4 23/GSM1545542_JMS8-5 #&gt; 497097 3 3 535 #&gt; 100503874 0 0 5 #&gt; 100038431 0 0 1 #&gt; 19888 17 2 0 #&gt; 20671 33 14 98 #&gt; Samples #&gt; Tags 23/GSM1545544_JMS9-P7c 23/GSM1545545_JMS9-P8c #&gt; 497097 2 0 #&gt; 100503874 0 0 #&gt; 100038431 0 0 #&gt; 19888 1 0 #&gt; 20671 18 8 #&gt; 27174 more rows ... #&gt; #&gt; $genes #&gt; ENTREZID SYMBOL TXCHROM #&gt; 1 497097 Xkr4 chr1 #&gt; 2 100503874 Gm19938 &lt;NA&gt; #&gt; 3 100038431 Gm10568 &lt;NA&gt; #&gt; 4 19888 Rp1 chr1 #&gt; 5 20671 Sox17 chr1 #&gt; 27174 more rows ... 6.6 Data pre-processing 6.6.1 Transformations from the raw-scale For differential expression and related analyses, gene expression is rarely considered at the level of raw counts since libraries sequenced at a greater depth will result in higher counts. Rather, it is common practice to transform raw counts onto a scale that accounts for such library size differences. Popular transformations include counts per million (CPM), log2-counts per million (log-CPM), reads per kilobase of transcript per million (RPKM), and fragments per kilobase of transcript per million (FPKM). In our analyses, CPM and log-CPM transformations are used regularly although they do not account for feature length differences which RPKM and FPKM values do. Whilst RPKM and FPKM values can just as well be used, CPM and log-CPM values can be calculated using a counts matrix alone and will suffice for the type of comparisons we are interested in. Assuming that there are no differences in isoform usage between conditions, differential expression analyses look at gene expression changes between conditions rather than comparing expression across multiple genes or drawing conclusions on absolute levels of expression. In other words, gene lengths remain constant for comparisons of interest and any observed differences are a result of changes in condition rather than changes in gene length. Here raw counts are converted to CPM and log-CPM values using the cpm function in edgeR, where log-transformations use a prior count of 0.25 to avoid taking the log of zero. RPKM values are just as easily calculated as CPM values using the rpkm function in edgeR if gene lengths are available. cpm &lt;- cpm(x) lcpm &lt;- cpm(x, log=TRUE) 6.6.2 Removing genes that are lowly expressed All datasets will include a mix of genes that are expressed and those that are not expressed. Whilst it is of interest to examine genes that are expressed in one condition but not in another, some genes are unexpressed throughout all samples. In fact, 19% of genes in this dataset have zero counts across all nine samples. table(rowSums(x$counts==0)==9) #&gt; #&gt; FALSE TRUE #&gt; 22026 5153 Genes that are not expressed at a biologically meaningful level in any condition should be discarded to reduce the subset of genes to those that are of interest, and to reduce the number of tests carried out downstream when looking at differential expression. Upon examination of log-CPM values, it can be seen that a large proportion of genes within each sample is unexpressed or lowly-expressed (shown in panel A of the next figure). Using a nominal CPM value of 1 (which is equivalent to a log-CPM value of 0) genes are deemed to be expressed if their expression is above this threshold, and unexpressed otherwise. Genes must be expressed in at least one group (or in at least three samples across the entire experiment) to be kept for downstream analysis. Although any sensible value can be used as the expression cutoff, typically a CPM value of 1 is used in our analyses as it separates expressed genes from unexpressed genes well for most datasets. Here, a CPM value of 1 means that a gene is expressed if it has at least 20 counts in the sample with the lowest sequencing depth (JMS9-P8c, library size approx. 20 million) or at least 76 counts in the sample with the greatest sequencing depth (JMS8-3, library size approx. 76 million). If sequence reads are summarised by exons rather than genes and/or experiments have low sequencing depth, a lower CPM cutoff may be considered. keep.exprs &lt;- rowSums(cpm&gt;1)&gt;=3 x &lt;- x[keep.exprs,, keep.lib.sizes=FALSE] dim(x) #&gt; [1] 14165 9 Using this criterion, the number of genes is reduced to approximately half the number that we started with (14,165 genes, panel B of the next figure). Note that subsetting the entire DGEList-object removes both the counts as well as the associated gene information. Code to produce the figure is given below. library(RColorBrewer) nsamples &lt;- ncol(x) col &lt;- brewer.pal(nsamples, &quot;Paired&quot;) par(mfrow=c(1,2)) plot(density(lcpm[,1]), col=col[1], lwd=2, ylim=c(0,0.21), las=2, main=&quot;&quot;, xlab=&quot;&quot;) title(main=&quot;A. Raw data&quot;, xlab=&quot;Log-cpm&quot;) abline(v=0, lty=3) for (i in 2:nsamples){ den &lt;- density(lcpm[,i]) lines(den$x, den$y, col=col[i], lwd=2) } legend(&quot;topright&quot;, samplenames, text.col=col, bty=&quot;n&quot;) lcpm &lt;- cpm(x, log=TRUE) plot(density(lcpm[,1]), col=col[1], lwd=2, ylim=c(0,0.21), las=2, main=&quot;&quot;, xlab=&quot;&quot;) title(main=&quot;B. Filtered data&quot;, xlab=&quot;Log-cpm&quot;) abline(v=0, lty=3) for (i in 2:nsamples){ den &lt;- density(lcpm[,i]) lines(den$x, den$y, col=col[i], lwd=2) } legend(&quot;topright&quot;, samplenames, text.col=col, bty=&quot;n&quot;) Figure 6.1: The density of log-CPM values for raw pre-filtered data (A) and post-filtered data (B) are shown for each sample. Dotted vertical lines mark the log-CPM of zero threshold (equivalent to a CPM value of 1) used in the filtering step. 6.6.3 Normalising gene expression distributions During the sample preparation or sequencing process, external factors that are not of biological interest can affect the expression of individual samples. For example, samples processed in the first batch of an experiment can have higher expression overall when compared to samples processed in a second batch. It is assumed that all samples should have a similar range and distribution of expression values. Normalisation is required to ensure that the expression distributions of each sample are similar across the entire experiment. Any plot showing the per sample expression distributions, such as a density or boxplot, is useful in determining whether any samples are dissimilar to others. Distributions of log-CPM values are similar throughout all samples within this dataset (panel B of the figure above). Nonetheless, normalisation by the method of trimmed mean of M-values (TMM) is performed using the calcNormFactors function in edgeR. The normalisation factors calculated here are used as a scaling factor for the library sizes. When working with DGEList-objects, these normalisation factors are automatically stored in x$samples$norm.factors. For this dataset the effect of TMM-normalisation is mild, as evident in the magnitude of the scaling factors, which are all relatively close to 1. x &lt;- calcNormFactors(x, method = &quot;TMM&quot;) x$samples$norm.factors #&gt; [1] 0.8957309 1.0349196 1.0439552 1.0405040 1.0323599 0.9223424 0.9836603 #&gt; [8] 1.0827381 0.9792607 To give a better visual representation of the effects of normalisation, the data was duplicated then adjusted so that the counts of the first sample are reduced to 5% of their original values, and in the second sample they are inflated to be 5-times larger. x2 &lt;- x x2$samples$norm.factors &lt;- 1 x2$counts[,1] &lt;- ceiling(x2$counts[,1]*0.05) x2$counts[,2] &lt;- x2$counts[,2]*5 The figure below shows the expression distribution of samples for unnormalised and normalised data, where distributions are noticeably different pre-normalisation and are similar post-normalisation. Here the first sample has a small TMM scaling factor of 0.05, whereas the second sample has a large scaling factor of 6.13 – neither values are close to 1. par(mfrow=c(1,2)) lcpm &lt;- cpm(x2, log=TRUE) boxplot(lcpm, las=2, col=col, main=&quot;&quot;) title(main=&quot;A. Example: Unnormalised data&quot;,ylab=&quot;Log-cpm&quot;) x2 &lt;- calcNormFactors(x2) x2$samples$norm.factors #&gt; [1] 0.05472223 6.13059440 1.22927355 1.17051887 1.21487709 1.05622968 #&gt; [7] 1.14587663 1.26129350 1.11702264 lcpm &lt;- cpm(x2, log=TRUE) boxplot(lcpm, las=2, col=col, main=&quot;&quot;) title(main=&quot;B. Example: Normalised data&quot;,ylab=&quot;Log-cpm&quot;) Figure 6.2: Example data: Boxplots of log-CPM values showing expression distributions for unnormalised data (A) and normalised data (B) for each sample in the modified dataset where the counts in samples 1 and 2 have been scaled to 5% and 500% of their original values respectively. 6.6.4 Unsupervised clustering of samples In our opinion, one of the most important exploratory plots to examine for gene expression analyses is the multi-dimensional scaling (MDS) plot, or similar. The plot shows similarities and dissimilarities between samples in an unsupervised manner so that one can have an idea of the extent to which differential expression can be detected before carrying out formal tests. Ideally, samples would cluster well within the primary condition of interest, and any sample straying far from its group could be identified and followed up for sources of error or extra variation. If present, technical replicates should lie very close to one another. Such a plot can be made in limma using the plotMDS function. The first dimension represents the leading-fold-change that best separates samples and explains the largest proportion of variation in the data, with subsequent dimensions having a smaller effect and being orthogonal to the ones before it. When experimental design involves multiple factors, it is recommended that each factor is examined over several dimensions. If samples cluster by a given factor in any of these dimensions, it suggests that the factor contributes to expression differences and is worth including in the linear modelling. On the other hand, factors that show little or no effect may be left out of downstream analysis. In this dataset, samples can be seen to cluster well within experimental groups over dimension 1 and 2, and then separate by sequencing lane (sample batch) over dimension 3 (shown in the plot below). Keeping in mind that the first dimension explains the largest proportion of variation in the data, notice that the range of values over the dimensions become smaller as we move to higher dimensions. Whilst all samples cluster by groups, the largest transcriptional difference is observed between basal and LP, and basal and ML over dimension 1. For this reason, it is expected that pairwise comparisons between cell populations will result in a greater number of DE genes for comparisons involving basal samples, and relatively small numbers of DE genes when comparing ML to LP. In other datasets, samples that do not cluster by their groups of interest may also show little or no evidence of differential expression in the downstream analysis. To create the MDS plots, different colour groupings are assigned to factors of interest. Dimensions 1 and 2 are examined using the color grouping defined by cell types. Dimensions 3 and 4 are examined using the colour grouping defined by sequencing lanes (batch). lcpm &lt;- cpm(x, log=TRUE) par(mfrow=c(1,2)) col.group &lt;- group levels(col.group) &lt;- brewer.pal(nlevels(col.group), &quot;Set1&quot;) col.group &lt;- as.character(col.group) col.lane &lt;- lane levels(col.lane) &lt;- brewer.pal(nlevels(col.lane), &quot;Set2&quot;) col.lane &lt;- as.character(col.lane) plotMDS(lcpm, labels=group, col=col.group) title(main=&quot;A. Sample groups&quot;) plotMDS(lcpm, labels=lane, col=col.lane, dim=c(3,4)) title(main=&quot;B. Sequencing lanes&quot;) Figure 6.3: MDS plots of log-CPM values over dimensions 1 and 2 with samples coloured and labeled by sample groups (A) and over dimensions 3 and 4 with samples coloured and labeled by sequencing lane (B). Distances on the plot correspond to the leading fold-change, which is the average (root-mean-square) log2-fold-change for the 500 genes most divergent between each pair of samples by default. Alternatively, the Glimma package offers the convenience of an interactive MDS plot where multiple dimensions can be explored. The glMDSPlot function generates an html page (that is opened in a browser if launch=TRUE) with an MDS plot in the left panel and a barplot showing the proportion of variation explained by each dimension in the right panel. Clicking on the bars of the bar plot changes the pair of dimensions plotted in the MDS plot, and hovering over the individual points reveals the sample label. The colour scheme can be changed as well to highlight cell population or sequencing lane (batch). An interactive MDS plot of this dataset can be found at http://bioinf.wehi.edu.au/folders/limmaWorkflow/glimma-plots/MDS-Plot.html. glMDSPlot(lcpm, labels=paste(group, lane, sep=&quot;_&quot;), groups=x$samples[,c(2,5)], launch=FALSE) 6.7 Differential expression analysis 6.7.1 Creating a design matrix and contrasts In this study, it is of interest to see which genes are expressed at different levels between the three cell populations profiled. In our analysis, linear models are fitted to the data with the assumption that the underlying data is normally distributed. To get started, a design matrix is set up with both the cell population and sequencing lane (batch) information. design &lt;- model.matrix(~0+group+lane) colnames(design) &lt;- gsub(&quot;group&quot;, &quot;&quot;, colnames(design)) design #&gt; Basal LP ML laneL006 laneL008 #&gt; 1 0 1 0 0 0 #&gt; 2 0 0 1 0 0 #&gt; 3 1 0 0 0 0 #&gt; 4 1 0 0 1 0 #&gt; 5 0 0 1 1 0 #&gt; 6 0 1 0 1 0 #&gt; 7 1 0 0 1 0 #&gt; 8 0 0 1 0 1 #&gt; 9 0 1 0 0 1 #&gt; attr(,&quot;assign&quot;) #&gt; [1] 1 1 1 2 2 #&gt; attr(,&quot;contrasts&quot;) #&gt; attr(,&quot;contrasts&quot;)$group #&gt; [1] &quot;contr.treatment&quot; #&gt; #&gt; attr(,&quot;contrasts&quot;)$lane #&gt; [1] &quot;contr.treatment&quot; For a given experiment, there are usually several equivalent ways to set up an appropriate design matrix. For example, ~0+group+lane removes the intercept from the first factor, group, but an intercept remains in the second factor lane. Alternatively, ~group+lane could be used to keep the intercepts in both group and lane. Understanding how to interpret the coefficients estimated in a given model is key here. We choose the first model for our analysis, as setting up model contrasts is more straight forward in the absence of an intercept for group. Contrasts for pairwise comparisons between cell populations are set up in limma using the makeContrasts function. contr.matrix &lt;- makeContrasts( BasalvsLP = Basal-LP, BasalvsML = Basal - ML, LPvsML = LP - ML, levels = colnames(design)) contr.matrix #&gt; Contrasts #&gt; Levels BasalvsLP BasalvsML LPvsML #&gt; Basal 1 1 0 #&gt; LP -1 0 1 #&gt; ML 0 -1 -1 #&gt; laneL006 0 0 0 #&gt; laneL008 0 0 0 A key strength of limma’s linear modelling approach, is the ability accommodate arbitrary experimental complexity. Simple designs, such as the one in this workflow, with cell type and batch, through to more complicated factorial designs and models with interaction terms can be handled relatively easily. Where experimental or technical effects can be modelled using a random effect, another possibility in limma is to estimate correlations using duplicateCorrelation by specifying a block argument for both this function and in the lmFit linear modelling step. 6.7.2 Removing heteroscedascity from count data It has been shown that for RNA-seq count data, the variance is not independent of the mean – this is true of raw counts or when transformed to log-CPM values. Methods that model counts using a Negative Binomial distribution assume a quadratic mean-variance relationship. In limma, linear modelling is carried out on the log-CPM values which are assumed to be normally distributed and the mean-variance relationship is accommodated using precision weights calculated by the voom function. When operating on a DGEList-object, voom converts raw counts to log-CPM values by automatically extracting library sizes and normalisation factors from x itself. Additional normalisation to log-CPM values can be specified within voom using the normalize.method argument. The mean-variance relationship of log-CPM values for this dataset is shown in the left-hand panel of the next figure. Typically, the voom-plot shows a decreasing trend between the means and variances resulting from a combination of technical variation in the sequencing experiment and biological variation amongst the replicate samples from different cell populations. Experiments with high biological variation usually result in flatter trends, where variance values plateau at high expression values. Experiments with low biological variation tend to result in sharp decreasing trends. Moreover, the voom-plot provides a visual check on the level of filtering performed upstream. If filtering of lowly-expressed genes is insufficient, a drop in variance levels can be observed at the low end of the expression scale due to very small counts. If this is observed, one should return to the earlier filtering step and increase the expression threshold applied to the dataset. Where sample-level variation is evident from earlier inspections of the MDS plot, the voomWithQualityWeights function can be used to simultaneously incorporate sample-level weights together with the abundance dependent weights estimated by voom. For an example of this, see Liu et al. (2016). par(mfrow=c(1,2)) v &lt;- voom(x, design, plot=TRUE) v #&gt; An object of class &quot;EList&quot; #&gt; $genes #&gt; ENTREZID SYMBOL TXCHROM #&gt; 1 497097 Xkr4 chr1 #&gt; 6 27395 Mrpl15 chr1 #&gt; 7 18777 Lypla1 chr1 #&gt; 9 21399 Tcea1 chr1 #&gt; 10 58175 Rgs20 chr1 #&gt; 14160 more rows ... #&gt; #&gt; $targets #&gt; files group #&gt; 23/GSM1545535_10_6_5_11 Law_RNAseq123/GSM1545535_10_6_5_11.txt LP #&gt; 23/GSM1545536_9_6_5_11 Law_RNAseq123/GSM1545536_9_6_5_11.txt ML #&gt; 23/GSM1545538_purep53 Law_RNAseq123/GSM1545538_purep53.txt Basal #&gt; 23/GSM1545539_JMS8-2 Law_RNAseq123/GSM1545539_JMS8-2.txt Basal #&gt; 23/GSM1545540_JMS8-3 Law_RNAseq123/GSM1545540_JMS8-3.txt ML #&gt; 23/GSM1545541_JMS8-4 Law_RNAseq123/GSM1545541_JMS8-4.txt LP #&gt; 23/GSM1545542_JMS8-5 Law_RNAseq123/GSM1545542_JMS8-5.txt Basal #&gt; 23/GSM1545544_JMS9-P7c Law_RNAseq123/GSM1545544_JMS9-P7c.txt ML #&gt; 23/GSM1545545_JMS9-P8c Law_RNAseq123/GSM1545545_JMS9-P8c.txt LP #&gt; lib.size norm.factors lane #&gt; 23/GSM1545535_10_6_5_11 29409426 0.8957309 L004 #&gt; 23/GSM1545536_9_6_5_11 36528591 1.0349196 L004 #&gt; 23/GSM1545538_purep53 59598629 1.0439552 L004 #&gt; 23/GSM1545539_JMS8-2 53382070 1.0405040 L006 #&gt; 23/GSM1545540_JMS8-3 78175314 1.0323599 L006 #&gt; 23/GSM1545541_JMS8-4 55762781 0.9223424 L006 #&gt; 23/GSM1545542_JMS8-5 54115150 0.9836603 L006 #&gt; 23/GSM1545544_JMS9-P7c 23043111 1.0827381 L008 #&gt; 23/GSM1545545_JMS9-P8c 19525423 0.9792607 L008 #&gt; #&gt; $E #&gt; Samples #&gt; Tags 23/GSM1545535_10_6_5_11 23/GSM1545536_9_6_5_11 #&gt; 497097 -4.293244 -3.869026 #&gt; 27395 3.875010 4.400568 #&gt; 18777 4.707695 5.559334 #&gt; 21399 4.784462 4.741999 #&gt; 58175 3.943567 3.294875 #&gt; Samples #&gt; Tags 23/GSM1545538_purep53 23/GSM1545539_JMS8-2 23/GSM1545540_JMS8-3 #&gt; 497097 2.522753 3.302006 -4.481286 #&gt; 27395 4.521172 4.570624 4.322845 #&gt; 18777 5.400569 5.171235 5.627798 #&gt; 21399 5.374548 5.130925 4.848030 #&gt; 58175 -1.767924 -1.880302 2.993289 #&gt; Samples #&gt; Tags 23/GSM1545541_JMS8-4 23/GSM1545542_JMS8-5 23/GSM1545544_JMS9-P7c #&gt; 497097 -3.993876 3.306782 -3.204336 #&gt; 27395 3.786547 3.918878 4.345642 #&gt; 18777 5.081794 5.080061 5.757404 #&gt; 21399 4.944024 5.158292 5.036933 #&gt; 58175 3.357379 -2.114104 3.142621 #&gt; Samples #&gt; Tags 23/GSM1545545_JMS9-P8c #&gt; 497097 -5.287282 #&gt; 27395 4.132678 #&gt; 18777 5.150470 #&gt; 21399 4.987679 #&gt; 58175 3.523290 #&gt; 14160 more rows ... #&gt; #&gt; $weights #&gt; [,1] [,2] [,3] [,4] [,5] [,6] [,7] #&gt; [1,] 1.183974 1.183974 20.526779 20.97747 1.773562 1.217142 21.125740 #&gt; [2,] 20.879554 26.561871 31.596323 29.66102 32.558344 26.745293 29.792090 #&gt; [3,] 28.003202 33.695540 34.845507 34.45673 35.148529 33.550527 34.517259 #&gt; [4,] 27.670233 29.595778 34.901302 34.43298 34.841349 33.159425 34.493456 #&gt; [5,] 19.737381 18.658333 3.184207 2.62986 24.191635 24.014937 2.648747 #&gt; [,8] [,9] #&gt; [1,] 1.183974 1.183974 #&gt; [2,] 21.900102 17.150677 #&gt; [3,] 31.440457 25.228325 #&gt; [4,] 26.136796 24.502247 #&gt; [5,] 13.149278 14.351930 #&gt; 14160 more rows ... #&gt; #&gt; $design #&gt; Basal LP ML laneL006 laneL008 #&gt; 1 0 1 0 0 0 #&gt; 2 0 0 1 0 0 #&gt; 3 1 0 0 0 0 #&gt; 4 1 0 0 1 0 #&gt; 5 0 0 1 1 0 #&gt; 6 0 1 0 1 0 #&gt; 7 1 0 0 1 0 #&gt; 8 0 0 1 0 1 #&gt; 9 0 1 0 0 1 #&gt; attr(,&quot;assign&quot;) #&gt; [1] 1 1 1 2 2 #&gt; attr(,&quot;contrasts&quot;) #&gt; attr(,&quot;contrasts&quot;)$group #&gt; [1] &quot;contr.treatment&quot; #&gt; #&gt; attr(,&quot;contrasts&quot;)$lane #&gt; [1] &quot;contr.treatment&quot; vfit &lt;- lmFit(v, design) vfit &lt;- contrasts.fit(vfit, contrasts=contr.matrix) efit &lt;- eBayes(vfit) plotSA(efit, main=&quot;Final model: Mean−variance trend&quot;) Note that the other data frames stored within the DGEList-object that contain gene- and sample-level information, are retained in the EList-object v created by voom. The v$genes data frame is equivalent to x$genes, v$targets is equivalent to x$samples, and the expression values stored in v$E is analogous to x$counts, albeit on a transformed scale. In addition to this, the voom EList-object has a matrix of precision weights v$weights and stores the design matrix in v$design. 6.7.3 Fitting linear models for comparisons of interest Linear modelling in limma is carried out using the lmFit and contrasts.fit functions originally written for application to microarrays. The functions can be used for both microarray and RNA-seq data and fit a separate model to the expression values for each gene. Next, empirical Bayes moderation is carried out by borrowing information across all the genes to obtain more precise estimates of gene-wise variability. The model’s residual variances are plotted against average expression values in the next figure. It can be seen from this plot that the variance is no longer dependent on the mean expression level. 6.7.4 Examining the number of DE genes For a quick look at differential expression levels, the number of significantly up- and down-regulated genes can be summarised in a table. Significance is defined using an adjusted p-value cutoff that is set at 5% by default. For the comparison between expression levels in basal and LP, 4,127 genes are found to be down-regulated in basal relative to LP and 4,298 genes are up-regulated in basal relative to LP – a total of 8,425 DE genes. A total of 8,510 DE genes are found between basal and ML (4,338 down- and 4,172 up-regulated genes), and a total of 5,340 DE genes are found between LP and ML (2,895 down- and 2,445 up-regulated). The larger numbers of DE genes observed for comparisons involving the basal population are consistent with our observations from the MDS plots. summary(decideTests(efit)) #&gt; BasalvsLP BasalvsML LPvsML #&gt; Down 4127 4338 2895 #&gt; NotSig 5740 5655 8825 #&gt; Up 4298 4172 2445 Some studies require more than an adjusted p-value cut-off. For a stricter definition on significance, one may require log-fold-changes (log-FCs) to be above a minimum value. The treat method can be used to calculate p-values from empirical Bayes moderated t-statistics with a minimum log-FC requirement. The number of differentially expressed genes are reduced to a total of 3,135 DE genes for basal versus LP, 3,270 DE genes for basal versus ML, and 385 DE genes for LP versus ML when testing requires genes to have a log-FC that is significantly greater than 1 (equivalent to a 2-fold difference between cell types on the original scale). tfit &lt;- treat(vfit, lfc=1) dt &lt;- decideTests(tfit) summary(dt) #&gt; BasalvsLP BasalvsML LPvsML #&gt; Down 1417 1512 203 #&gt; NotSig 11030 10895 13780 #&gt; Up 1718 1758 182 Genes that are DE in multiple comparisons can be extracted using the results from decideTests, where 0s represent genes that are not DE, 1s represent genes that are up-regulated, and -1s represent genes that are down-regulated. A total of 2,409 genes are DE in both basal versus LP and basal versus ML, twenty of which are listed below. The write.fit function can be used to extract and write results for all three comparisons to a single output file. de.common &lt;- which(dt[,1]!=0 &amp; dt[,2]!=0) length(de.common) #&gt; [1] 2409 head(tfit$genes$SYMBOL[de.common], n=20) #&gt; [1] &quot;Xkr4&quot; &quot;Rgs20&quot; &quot;Cpa6&quot; &quot;Sulf1&quot; #&gt; [5] &quot;Eya1&quot; &quot;Msc&quot; &quot;Sbspon&quot; &quot;Pi15&quot; #&gt; [9] &quot;Crispld1&quot; &quot;Kcnq5&quot; &quot;Ptpn18&quot; &quot;Arhgef4&quot; #&gt; [13] &quot;2010300C02Rik&quot; &quot;Aff3&quot; &quot;Npas2&quot; &quot;Tbc1d8&quot; #&gt; [17] &quot;Creg2&quot; &quot;Il1r1&quot; &quot;Il18r1&quot; &quot;Il18rap&quot; vennDiagram(dt[,1:2], circle.col=c(&quot;turquoise&quot;, &quot;salmon&quot;)) Figure 6.4: Venn diagram showing the number of genes DE in the comparison between basal versus LP only (left), basal versus ML only (right), and the number of genes that are DE in both comparisons (center). The number of genes that are not DE in either comparison are marked in the bottom-right. write.fit(tfit, dt, file=&quot;results.txt&quot;) 6.7.5 Examining individual DE genes from top to bottom The top DE genes can be listed using topTreat for results using treat (or topTable for results using eBayes). By default topTreat arranges genes from smallest to largest adjusted p-value with associated gene information, log-FC, average log-CPM, moderated t-statistic, raw and adjusted p-value for each gene. The number of top genes displayed can be specified, where n=Inf includes all genes. Genes Cldn7 and Rasef are amongst the top DE genes for both basal versus LP and basal versus ML. basal.vs.lp &lt;- topTreat(tfit, coef=1, n=Inf) basal.vs.ml &lt;- topTreat(tfit, coef=2, n=Inf) head(basal.vs.lp) #&gt; ENTREZID SYMBOL TXCHROM logFC AveExpr t P.Value #&gt; 12759 12759 Clu chr14 -5.442877 8.857907 -33.44429 3.990899e-10 #&gt; 53624 53624 Cldn7 chr11 -5.514605 6.296762 -32.94533 4.503694e-10 #&gt; 242505 242505 Rasef chr4 -5.921741 5.119585 -31.77625 6.063249e-10 #&gt; 67451 67451 Pkp2 chr16 -5.724823 4.420495 -30.65370 8.010456e-10 #&gt; 228543 228543 Rhov chr2 -6.253427 5.486640 -29.46244 1.112729e-09 #&gt; 70350 70350 Basp1 chr15 -6.073297 5.248349 -28.64890 1.380545e-09 #&gt; adj.P.Val #&gt; 12759 2.703871e-06 #&gt; 53624 2.703871e-06 #&gt; 242505 2.703871e-06 #&gt; 67451 2.703871e-06 #&gt; 228543 2.703871e-06 #&gt; 70350 2.703871e-06 head(basal.vs.ml) #&gt; ENTREZID SYMBOL TXCHROM logFC AveExpr t P.Value #&gt; 242505 242505 Rasef chr4 -6.510470 5.119585 -35.49093 2.573575e-10 #&gt; 53624 53624 Cldn7 chr11 -5.469160 6.296762 -32.52520 4.978446e-10 #&gt; 12521 12521 Cd82 chr2 -4.667737 7.070963 -31.82187 5.796191e-10 #&gt; 71740 71740 Nectin4 chr1 -5.556046 5.166292 -31.29987 6.760578e-10 #&gt; 20661 20661 Sort1 chr3 -4.908119 6.705784 -31.23083 6.761331e-10 #&gt; 15375 15375 Foxa1 chr12 -5.753884 5.625064 -28.34612 1.487280e-09 #&gt; adj.P.Val #&gt; 242505 1.915485e-06 #&gt; 53624 1.915485e-06 #&gt; 12521 1.915485e-06 #&gt; 71740 1.915485e-06 #&gt; 20661 1.915485e-06 #&gt; 15375 2.281914e-06 6.7.6 Useful graphical representations of differential expression results To summarise results for all genes visually, mean-difference plots, which display log-FCs from the linear model fit against the average log-CPM values can be generated using the plotMD function, with the differentially expressed genes highlighted. plotMD(tfit, column=1, status=dt[,1], main=colnames(tfit)[1], xlim=c(-8,13)) Glimma extends this functionality by providing an interactive mean-difference plot via the glMDPlot function. The output of this function is an html page, with summarised results in the left panel (similar to what is output by plotMD), and the log-CPM values from individual samples in the right panel, with a table of results below the plots. This interactive display allows the user to search for particular genes based on their Gene symbol, which is not possible in a static R plot. The glMDPlot function is not limited to mean-difference plots, with a default version allowing a data frame to be passed with the user able to select the columns of interest to plot in the left panel. glMDPlot(tfit, coef=1, status=dt, main=colnames(tfit)[1], side.main=&quot;ENTREZID&quot;, counts=x$counts, groups=group, launch=FALSE) The mean-difference plot generated by the command above is available online (see http://bioinf.wehi.edu.au/folders/limmaWorkflow/glimma-plots/MD-Plot.html). The interactivity provided by the Glimma package allows additional information to be presented in a single graphical window. Glimma is implemented in R and Javascript, with the R code generating the data which is converted into graphics using the Javascript library D3 (https://d3js.org), with the Bootstrap library handling layouts and Datatables generating the interactive searchable tables. This allows plots to be viewed in any modern browser, which is convenient for including them as linked files from an Rmarkdown report of the analysis. Plots shown previously include either all of the genes that are expressed in any one condition (such as the Venn diagram of common DE genes or mean-difference plot) or look at genes individually (log-CPM values shown in right panel of the interactive mean-difference plot). Heatmaps allow users to look at the expression of a subset of genes. This can be give useful insight into the expression of individual groups and samples without losing perspective of the overall study when focusing on individual genes, or losing resolution when examining patterns averaged over thousands of genes at the same time. A heatmap is created for the top 100 DE genes (as ranked by adjusted p-value) from the basal versus LP contrast using the heatmap.2 function from the gplots package. The heatmap correctly clusters samples into cell type and rearranges the order of genes to form blocks of similar expression. From the heatmap, we observe that the expression of ML and LP samples are very similar for the top 100 DE genes between basal and LP. library(gplots) basal.vs.lp.topgenes &lt;- basal.vs.lp$ENTREZID[1:100] i &lt;- which(v$genes$ENTREZID %in% basal.vs.lp.topgenes) mycol &lt;- colorpanel(1000,&quot;blue&quot;,&quot;white&quot;,&quot;red&quot;) heatmap.2(v$E[i,], scale=&quot;row&quot;, labRow=v$genes$SYMBOL[i], labCol=group, col=mycol, trace=&quot;none&quot;, density.info=&quot;none&quot;, margin=c(8,6), lhei=c(2,10), dendrogram=&quot;column&quot;) Figure 6.5: Heatmap of log-CPM values for top 100 genes DE in basal versus LP. Expression across each gene (or row) have been scaled so that mean expression is zero and standard deviation is one. Samples with relatively high expression of a given gene are marked in red and samples with relatively low expression are marked in blue. Lighter shades and white represent genes with intermediate expression levels. Samples and genes have been reordered by the method of hierarchical clustering. A dendrogram is shown for the sample clustering. "],
["solving-common-bioinformatic-challenges-using-genomicranges.html", "7 Solving common bioinformatic challenges using GenomicRanges 7.1 Instructor(s) name(s) and contact information 7.2 Workshop Description 7.3 Workshop goals and objectives 7.4 GRanges: Genomic Ranges 7.5 Splitting and combining GRanges objects 7.6 Subsetting GRanges objects 7.7 Basic interval operations for GRanges objects 7.8 Interval set operations for GRanges objects 7.9 GRangesList: Groups of Genomic Ranges 7.10 Basic GRangesList accessors 7.11 Combining GRangesList objects 7.12 Basic interval operations for GRangesList objects 7.13 Subsetting GRangesList objects 7.14 Looping over GRangesList objects", " 7 Solving common bioinformatic challenges using GenomicRanges 7.1 Instructor(s) name(s) and contact information Michael Lawrence (michafla@gene.com) 7.2 Workshop Description We will introduce the fundamental concepts underlying the GenomicRanges package and related infrastructure. After a structured introduction, we will follow a realistic workflow, along the way exploring the central data structures, including GRanges and SummarizedExperiment, and useful operations in the ranges algebra. Topics will include data import/export, computing and summarizing data on genomic features, overlap detection, integration with reference annotations, scaling strategies, and visualization. Students can follow along, and there will be plenty of time for students to ask questions about how to apply the infrastructure to their particular use case. Michael Lawrence (Genentech). 7.2.1 Pre-requisites Solid understanding of R Basic familiarity with GRanges objects Basic familiarity with packages like S4Vectors, IRanges, GenomicRanges, rtracklayer, etc. 7.2.2 Workshop Participation Describe how students will be expected to participate in the workshop. 7.2.3 R / Bioconductor packages used S4Vectors IRanges GenomicRanges rtracklayer GenomicFeatures SummarizedExperiment VariantAnnotation GenomicAlignments 7.2.4 Time outline Activity Time Intro slides 30m Workflow(s) 1hr Remaining questions 30m 7.3 Workshop goals and objectives 7.3.1 Learning goals Understand how to apply the *Ranges infrastructure to real-world problems Gain insight into the design principles of the infrastructure and how it was meant to be used 7.3.2 Learning objectives Manipulate GRanges and related objects Use the ranges algebra to analyze genomic ranges Implement efficient workflows based on the *Ranges infrastructure 7.4 GRanges: Genomic Ranges The GRanges class represents a collection of genomic ranges that each have a single start and end location on the genome. It can be used to store the location of genomic features such as contiguous binding sites, transcripts, and exons. These objects can be created by using the GRanges constructor function. For example, suppressPackageStartupMessages({ library(BiocStyle) library(GenomicRanges) }) gr &lt;- GRanges( seqnames = Rle(c(&quot;chr1&quot;, &quot;chr2&quot;, &quot;chr1&quot;, &quot;chr3&quot;), c(1, 3, 2, 4)), ranges = IRanges(101:110, end = 111:120, names = head(letters, 10)), strand = Rle(strand(c(&quot;-&quot;, &quot;+&quot;, &quot;*&quot;, &quot;+&quot;, &quot;-&quot;)), c(1, 2, 2, 3, 2)), score = 1:10, GC = seq(1, 0, length=10)) gr #&gt; GRanges object with 10 ranges and 2 metadata columns: #&gt; seqnames ranges strand | score GC #&gt; &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;integer&gt; &lt;numeric&gt; #&gt; a chr1 101-111 - | 1 1 #&gt; b chr2 102-112 + | 2 0.888888888888889 #&gt; c chr2 103-113 + | 3 0.777777777777778 #&gt; d chr2 104-114 * | 4 0.666666666666667 #&gt; e chr1 105-115 * | 5 0.555555555555556 #&gt; f chr1 106-116 + | 6 0.444444444444444 #&gt; g chr3 107-117 + | 7 0.333333333333333 #&gt; h chr3 108-118 + | 8 0.222222222222222 #&gt; i chr3 109-119 - | 9 0.111111111111111 #&gt; j chr3 110-120 - | 10 0 #&gt; ------- #&gt; seqinfo: 3 sequences from an unspecified genome; no seqlengths options(warn=2) creates a GRanges object with 10 genomic ranges. The output of the GRanges show method separates the information into a left and right hand region that are separated by | symbols. The genomic coordinates (seqnames, ranges, and strand) are located on the left-hand side and the metadata columns (annotation) are located on the right. For this example, the metadata is comprised of score and GC information, but almost anything can be stored in the metadata portion of a GRanges object. The components of the genomic coordinates within a GRanges object can be extracted using the seqnames, ranges, and strand accessor functions. seqnames(gr) #&gt; factor-Rle of length 10 with 4 runs #&gt; Lengths: 1 3 2 4 #&gt; Values : chr1 chr2 chr1 chr3 #&gt; Levels(3): chr1 chr2 chr3 ranges(gr) #&gt; IRanges object with 10 ranges and 0 metadata columns: #&gt; start end width #&gt; &lt;integer&gt; &lt;integer&gt; &lt;integer&gt; #&gt; a 101 111 11 #&gt; b 102 112 11 #&gt; c 103 113 11 #&gt; d 104 114 11 #&gt; e 105 115 11 #&gt; f 106 116 11 #&gt; g 107 117 11 #&gt; h 108 118 11 #&gt; i 109 119 11 #&gt; j 110 120 11 strand(gr) #&gt; factor-Rle of length 10 with 5 runs #&gt; Lengths: 1 2 2 3 2 #&gt; Values : - + * + - #&gt; Levels(3): + - * The genomic ranges can be extracted without corresponding metadata with granges granges(gr) #&gt; GRanges object with 10 ranges and 0 metadata columns: #&gt; seqnames ranges strand #&gt; &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; #&gt; a chr1 101-111 - #&gt; b chr2 102-112 + #&gt; c chr2 103-113 + #&gt; d chr2 104-114 * #&gt; e chr1 105-115 * #&gt; f chr1 106-116 + #&gt; g chr3 107-117 + #&gt; h chr3 108-118 + #&gt; i chr3 109-119 - #&gt; j chr3 110-120 - #&gt; ------- #&gt; seqinfo: 3 sequences from an unspecified genome; no seqlengths Annotations for these coordinates can be extracted as a DataFrame object using the mcols accessor. mcols(gr) #&gt; DataFrame with 10 rows and 2 columns #&gt; score GC #&gt; &lt;integer&gt; &lt;numeric&gt; #&gt; a 1 1 #&gt; b 2 0.888888888888889 #&gt; c 3 0.777777777777778 #&gt; d 4 0.666666666666667 #&gt; e 5 0.555555555555556 #&gt; f 6 0.444444444444444 #&gt; g 7 0.333333333333333 #&gt; h 8 0.222222222222222 #&gt; i 9 0.111111111111111 #&gt; j 10 0 mcols(gr)$score #&gt; [1] 1 2 3 4 5 6 7 8 9 10 Information about the lengths of the various sequences that the ranges are aligned to can also be stored in the GRanges object. So if this is data from Homo sapiens, we can set the values as: seqlengths(gr) &lt;- c(249250621, 243199373, 198022430) And then retrieves as: seqlengths(gr) #&gt; chr1 chr2 chr3 #&gt; 249250621 243199373 198022430 Methods for accessing the length and names have also been defined. names(gr) #&gt; [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; &quot;j&quot; length(gr) #&gt; [1] 10 7.5 Splitting and combining GRanges objects GRanges objects can be devided into groups using the split method. This produces a GRangesList object, a class that will be discussed in detail in the next section. sp &lt;- split(gr, rep(1:2, each=5)) sp #&gt; GRangesList object of length 2: #&gt; $1 #&gt; GRanges object with 5 ranges and 2 metadata columns: #&gt; seqnames ranges strand | score GC #&gt; &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;integer&gt; &lt;numeric&gt; #&gt; a chr1 101-111 - | 1 1 #&gt; b chr2 102-112 + | 2 0.888888888888889 #&gt; c chr2 103-113 + | 3 0.777777777777778 #&gt; d chr2 104-114 * | 4 0.666666666666667 #&gt; e chr1 105-115 * | 5 0.555555555555556 #&gt; #&gt; $2 #&gt; GRanges object with 5 ranges and 2 metadata columns: #&gt; seqnames ranges strand | score GC #&gt; f chr1 106-116 + | 6 0.444444444444444 #&gt; g chr3 107-117 + | 7 0.333333333333333 #&gt; h chr3 108-118 + | 8 0.222222222222222 #&gt; i chr3 109-119 - | 9 0.111111111111111 #&gt; j chr3 110-120 - | 10 0 #&gt; #&gt; ------- #&gt; seqinfo: 3 sequences from an unspecified genome Separate GRanges instances can be concatenated by using the c and append methods. c(sp[[1]], sp[[2]]) #&gt; GRanges object with 10 ranges and 2 metadata columns: #&gt; seqnames ranges strand | score GC #&gt; &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;integer&gt; &lt;numeric&gt; #&gt; a chr1 101-111 - | 1 1 #&gt; b chr2 102-112 + | 2 0.888888888888889 #&gt; c chr2 103-113 + | 3 0.777777777777778 #&gt; d chr2 104-114 * | 4 0.666666666666667 #&gt; e chr1 105-115 * | 5 0.555555555555556 #&gt; f chr1 106-116 + | 6 0.444444444444444 #&gt; g chr3 107-117 + | 7 0.333333333333333 #&gt; h chr3 108-118 + | 8 0.222222222222222 #&gt; i chr3 109-119 - | 9 0.111111111111111 #&gt; j chr3 110-120 - | 10 0 #&gt; ------- #&gt; seqinfo: 3 sequences from an unspecified genome 7.6 Subsetting GRanges objects GRanges objects act like vectors of ranges, with the expected vector-like subsetting operations available gr[2:3] #&gt; GRanges object with 2 ranges and 2 metadata columns: #&gt; seqnames ranges strand | score GC #&gt; &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;integer&gt; &lt;numeric&gt; #&gt; b chr2 102-112 + | 2 0.888888888888889 #&gt; c chr2 103-113 + | 3 0.777777777777778 #&gt; ------- #&gt; seqinfo: 3 sequences from an unspecified genome A second argument to the [ subset operator can be used to specify which metadata columns to extract from the GRanges object. For example, gr[2:3, &quot;GC&quot;] #&gt; GRanges object with 2 ranges and 1 metadata column: #&gt; seqnames ranges strand | GC #&gt; &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;numeric&gt; #&gt; b chr2 102-112 + | 0.888888888888889 #&gt; c chr2 103-113 + | 0.777777777777778 #&gt; ------- #&gt; seqinfo: 3 sequences from an unspecified genome Elements can also be assigned to the GRanges object. Here is an example where the second row of a GRanges object is replaced with the first row of gr. singles &lt;- split(gr, names(gr)) grMod &lt;- gr grMod[2] &lt;- singles[[1]] head(grMod, n=3) #&gt; GRanges object with 3 ranges and 2 metadata columns: #&gt; seqnames ranges strand | score GC #&gt; &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;integer&gt; &lt;numeric&gt; #&gt; a chr1 101-111 - | 1 1 #&gt; b chr1 101-111 - | 1 1 #&gt; c chr2 103-113 + | 3 0.777777777777778 #&gt; ------- #&gt; seqinfo: 3 sequences from an unspecified genome There are methods to repeat, reverse, or select specific portions of GRanges objects. rep(singles[[2]], times = 3) #&gt; GRanges object with 3 ranges and 2 metadata columns: #&gt; seqnames ranges strand | score GC #&gt; &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;integer&gt; &lt;numeric&gt; #&gt; b chr2 102-112 + | 2 0.888888888888889 #&gt; b chr2 102-112 + | 2 0.888888888888889 #&gt; b chr2 102-112 + | 2 0.888888888888889 #&gt; ------- #&gt; seqinfo: 3 sequences from an unspecified genome rev(gr) #&gt; GRanges object with 10 ranges and 2 metadata columns: #&gt; seqnames ranges strand | score GC #&gt; &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;integer&gt; &lt;numeric&gt; #&gt; j chr3 110-120 - | 10 0 #&gt; i chr3 109-119 - | 9 0.111111111111111 #&gt; h chr3 108-118 + | 8 0.222222222222222 #&gt; g chr3 107-117 + | 7 0.333333333333333 #&gt; f chr1 106-116 + | 6 0.444444444444444 #&gt; e chr1 105-115 * | 5 0.555555555555556 #&gt; d chr2 104-114 * | 4 0.666666666666667 #&gt; c chr2 103-113 + | 3 0.777777777777778 #&gt; b chr2 102-112 + | 2 0.888888888888889 #&gt; a chr1 101-111 - | 1 1 #&gt; ------- #&gt; seqinfo: 3 sequences from an unspecified genome head(gr,n=2) #&gt; GRanges object with 2 ranges and 2 metadata columns: #&gt; seqnames ranges strand | score GC #&gt; &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;integer&gt; &lt;numeric&gt; #&gt; a chr1 101-111 - | 1 1 #&gt; b chr2 102-112 + | 2 0.888888888888889 #&gt; ------- #&gt; seqinfo: 3 sequences from an unspecified genome tail(gr,n=2) #&gt; GRanges object with 2 ranges and 2 metadata columns: #&gt; seqnames ranges strand | score GC #&gt; &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;integer&gt; &lt;numeric&gt; #&gt; i chr3 109-119 - | 9 0.111111111111111 #&gt; j chr3 110-120 - | 10 0 #&gt; ------- #&gt; seqinfo: 3 sequences from an unspecified genome window(gr, start=2,end=4) #&gt; GRanges object with 3 ranges and 2 metadata columns: #&gt; seqnames ranges strand | score GC #&gt; &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;integer&gt; &lt;numeric&gt; #&gt; b chr2 102-112 + | 2 0.888888888888889 #&gt; c chr2 103-113 + | 3 0.777777777777778 #&gt; d chr2 104-114 * | 4 0.666666666666667 #&gt; ------- #&gt; seqinfo: 3 sequences from an unspecified genome gr[IRanges(start=c(2,7), end=c(3,9))] #&gt; GRanges object with 5 ranges and 2 metadata columns: #&gt; seqnames ranges strand | score GC #&gt; &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;integer&gt; &lt;numeric&gt; #&gt; b chr2 102-112 + | 2 0.888888888888889 #&gt; c chr2 103-113 + | 3 0.777777777777778 #&gt; g chr3 107-117 + | 7 0.333333333333333 #&gt; h chr3 108-118 + | 8 0.222222222222222 #&gt; i chr3 109-119 - | 9 0.111111111111111 #&gt; ------- #&gt; seqinfo: 3 sequences from an unspecified genome 7.7 Basic interval operations for GRanges objects Basic interval characteristics of GRanges objects can be extracted using the start, end, width, and range methods. g &lt;- gr[1:3] g &lt;- append(g, singles[[10]]) start(g) #&gt; [1] 101 102 103 110 end(g) #&gt; [1] 111 112 113 120 width(g) #&gt; [1] 11 11 11 11 range(g) #&gt; GRanges object with 3 ranges and 0 metadata columns: #&gt; seqnames ranges strand #&gt; &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; #&gt; [1] chr1 101-111 - #&gt; [2] chr2 102-113 + #&gt; [3] chr3 110-120 - #&gt; ------- #&gt; seqinfo: 3 sequences from an unspecified genome The GRanges class also has many methods for manipulating the ranges. The methods can be classified as intra-range methods, inter-range methods, and between-range methods. Intra-range methods operate on each element of a GRanges object independent of the other ranges in the object. For example, the flank method can be used to recover regions flanking the set of ranges represented by the GRanges object. So to get a GRanges object containing the ranges that include the 10 bases upstream of the ranges: flank(g, 10) #&gt; GRanges object with 4 ranges and 2 metadata columns: #&gt; seqnames ranges strand | score GC #&gt; &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;integer&gt; &lt;numeric&gt; #&gt; a chr1 112-121 - | 1 1 #&gt; b chr2 92-101 + | 2 0.888888888888889 #&gt; c chr2 93-102 + | 3 0.777777777777778 #&gt; j chr3 121-130 - | 10 0 #&gt; ------- #&gt; seqinfo: 3 sequences from an unspecified genome And to include the downstream bases: flank(g, 10, start=FALSE) #&gt; GRanges object with 4 ranges and 2 metadata columns: #&gt; seqnames ranges strand | score GC #&gt; &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;integer&gt; &lt;numeric&gt; #&gt; a chr1 91-100 - | 1 1 #&gt; b chr2 113-122 + | 2 0.888888888888889 #&gt; c chr2 114-123 + | 3 0.777777777777778 #&gt; j chr3 100-109 - | 10 0 #&gt; ------- #&gt; seqinfo: 3 sequences from an unspecified genome Other examples of intra-range methods include resize and shift. The shift method will move the ranges by a specific number of base pairs, and the resize method will extend the ranges by a specified width. shift(g, 5) #&gt; GRanges object with 4 ranges and 2 metadata columns: #&gt; seqnames ranges strand | score GC #&gt; &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;integer&gt; &lt;numeric&gt; #&gt; a chr1 106-116 - | 1 1 #&gt; b chr2 107-117 + | 2 0.888888888888889 #&gt; c chr2 108-118 + | 3 0.777777777777778 #&gt; j chr3 115-125 - | 10 0 #&gt; ------- #&gt; seqinfo: 3 sequences from an unspecified genome resize(g, 30) #&gt; GRanges object with 4 ranges and 2 metadata columns: #&gt; seqnames ranges strand | score GC #&gt; &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;integer&gt; &lt;numeric&gt; #&gt; a chr1 82-111 - | 1 1 #&gt; b chr2 102-131 + | 2 0.888888888888889 #&gt; c chr2 103-132 + | 3 0.777777777777778 #&gt; j chr3 91-120 - | 10 0 #&gt; ------- #&gt; seqinfo: 3 sequences from an unspecified genome The GenomicRanges help page ?&quot;intra-range-methods&quot; summarizes these methods. Inter-range methods involve comparisons between ranges in a single GRanges object. For instance, the reduce method will align the ranges and merge overlapping ranges to produce a simplified set. reduce(g) #&gt; GRanges object with 3 ranges and 0 metadata columns: #&gt; seqnames ranges strand #&gt; &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; #&gt; [1] chr1 101-111 - #&gt; [2] chr2 102-113 + #&gt; [3] chr3 110-120 - #&gt; ------- #&gt; seqinfo: 3 sequences from an unspecified genome Sometimes one is interested in the gaps or the qualities of the gaps between the ranges represented by your GRanges object. The gaps method provides this information: reduced version of your ranges: gaps(g) #&gt; GRanges object with 12 ranges and 0 metadata columns: #&gt; seqnames ranges strand #&gt; &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; #&gt; [1] chr1 1-249250621 + #&gt; [2] chr1 1-100 - #&gt; [3] chr1 112-249250621 - #&gt; [4] chr1 1-249250621 * #&gt; [5] chr2 1-101 + #&gt; ... ... ... ... #&gt; [8] chr2 1-243199373 * #&gt; [9] chr3 1-198022430 + #&gt; [10] chr3 1-109 - #&gt; [11] chr3 121-198022430 - #&gt; [12] chr3 1-198022430 * #&gt; ------- #&gt; seqinfo: 3 sequences from an unspecified genome The disjoin method represents a GRanges object as a collection of non-overlapping ranges: disjoin(g) #&gt; GRanges object with 5 ranges and 0 metadata columns: #&gt; seqnames ranges strand #&gt; &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; #&gt; [1] chr1 101-111 - #&gt; [2] chr2 102 + #&gt; [3] chr2 103-112 + #&gt; [4] chr2 113 + #&gt; [5] chr3 110-120 - #&gt; ------- #&gt; seqinfo: 3 sequences from an unspecified genome The coverage method quantifies the degree of overlap for all the ranges in a GRanges object. coverage(g) #&gt; RleList of length 3 #&gt; $chr1 #&gt; integer-Rle of length 249250621 with 3 runs #&gt; Lengths: 100 11 249250510 #&gt; Values : 0 1 0 #&gt; #&gt; $chr2 #&gt; integer-Rle of length 243199373 with 5 runs #&gt; Lengths: 101 1 10 1 243199260 #&gt; Values : 0 1 2 1 0 #&gt; #&gt; $chr3 #&gt; integer-Rle of length 198022430 with 3 runs #&gt; Lengths: 109 11 198022310 #&gt; Values : 0 1 0 See the GenomicRanges help page ?&quot;inter-range-methods&quot; for additional help. Between-range methods involve operations between two GRanges objects; some of these are summarized in the next section. 7.8 Interval set operations for GRanges objects Between-range methods calculate relationships between different GRanges objects. Of central importance are findOverlaps and related operations; these are discussed below. Additional operations treat GRanges as mathematical sets of coordinates; union(g, g2) is the union of the coordinates in g and g2. Here are examples for calculating the union, the intersect and the asymmetric difference (using setdiff). g2 &lt;- head(gr, n=2) union(g, g2) #&gt; GRanges object with 3 ranges and 0 metadata columns: #&gt; seqnames ranges strand #&gt; &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; #&gt; [1] chr1 101-111 - #&gt; [2] chr2 102-113 + #&gt; [3] chr3 110-120 - #&gt; ------- #&gt; seqinfo: 3 sequences from an unspecified genome intersect(g, g2) #&gt; GRanges object with 2 ranges and 0 metadata columns: #&gt; seqnames ranges strand #&gt; &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; #&gt; [1] chr1 101-111 - #&gt; [2] chr2 102-112 + #&gt; ------- #&gt; seqinfo: 3 sequences from an unspecified genome setdiff(g, g2) #&gt; GRanges object with 2 ranges and 0 metadata columns: #&gt; seqnames ranges strand #&gt; &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; #&gt; [1] chr2 113 + #&gt; [2] chr3 110-120 - #&gt; ------- #&gt; seqinfo: 3 sequences from an unspecified genome Related methods are available when the structure of the GRanges objects are ‘parallel’ to one another, i.e., element 1 of object 1 is related to element 1 of object 2, and so on. These operations all begin with a p, which is short for parallel. The methods then perform element-wise, e.g., the union of element 1 of object 1 with element 1 of object 2, etc. A requirement for these operations is that the number of elements in each GRanges object is the same, and that both of the objects have the same seqnames and strand assignments throughout. g3 &lt;- g[1:2] ranges(g3[1]) &lt;- IRanges(start=105, end=112) punion(g2, g3) #&gt; GRanges object with 2 ranges and 0 metadata columns: #&gt; seqnames ranges strand #&gt; &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; #&gt; a chr1 101-112 - #&gt; b chr2 102-112 + #&gt; ------- #&gt; seqinfo: 3 sequences from an unspecified genome pintersect(g2, g3) #&gt; GRanges object with 2 ranges and 3 metadata columns: #&gt; seqnames ranges strand | score GC hit #&gt; &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;integer&gt; &lt;numeric&gt; &lt;logical&gt; #&gt; a chr1 105-111 - | 1 1 TRUE #&gt; b chr2 102-112 + | 2 0.888888888888889 TRUE #&gt; ------- #&gt; seqinfo: 3 sequences from an unspecified genome psetdiff(g2, g3) #&gt; GRanges object with 2 ranges and 0 metadata columns: #&gt; seqnames ranges strand #&gt; &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; #&gt; a chr1 101-104 - #&gt; b chr2 102-101 + #&gt; ------- #&gt; seqinfo: 3 sequences from an unspecified genome For more information on the GRanges classes be sure to consult the manual page. ?GRanges A relatively comprehensive list of available methods is discovered with methods(class=&quot;GRanges&quot;) 7.9 GRangesList: Groups of Genomic Ranges Some important genomic features, such as spliced transcripts that are are comprised of exons, are inherently compound structures. Such a feature makes much more sense when expressed as a compound object such as a GRangesList. Whenever genomic features consist of multiple ranges that are grouped by a parent feature, they can be represented as a GRangesList object. Consider the simple example of the two transcript GRangesList below created using the GRangesList constructor. gr1 &lt;- GRanges( seqnames = &quot;chr2&quot;, ranges = IRanges(103, 106), strand = &quot;+&quot;, score = 5L, GC = 0.45) gr2 &lt;- GRanges( seqnames = c(&quot;chr1&quot;, &quot;chr1&quot;), ranges = IRanges(c(107, 113), width = 3), strand = c(&quot;+&quot;, &quot;-&quot;), score = 3:4, GC = c(0.3, 0.5)) grl &lt;- GRangesList(&quot;txA&quot; = gr1, &quot;txB&quot; = gr2) grl #&gt; GRangesList object of length 2: #&gt; $txA #&gt; GRanges object with 1 range and 2 metadata columns: #&gt; seqnames ranges strand | score GC #&gt; &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;integer&gt; &lt;numeric&gt; #&gt; [1] chr2 103-106 + | 5 0.45 #&gt; #&gt; $txB #&gt; GRanges object with 2 ranges and 2 metadata columns: #&gt; seqnames ranges strand | score GC #&gt; [1] chr1 107-109 + | 3 0.3 #&gt; [2] chr1 113-115 - | 4 0.5 #&gt; #&gt; ------- #&gt; seqinfo: 2 sequences from an unspecified genome; no seqlengths The show method for a GRangesList object displays it as a named list of GRanges objects, where the names of this list are considered to be the names of the grouping feature. In the example above, the groups of individual exon ranges are represented as separate GRanges objects which are further organized into a list structure where each element name is a transcript name. Many other combinations of grouped and labeled GRanges objects are possible of course, but this example is expected to be a common arrangement. 7.10 Basic GRangesList accessors Just as with GRanges object, the components of the genomic coordinates within a GRangesList object can be extracted using simple accessor methods. Not surprisingly, the GRangesList objects have many of the same accessors as GRanges objects. The difference is that many of these methods return a list since the input is now essentially a list of GRanges objects. Here are a few examples: seqnames(grl) #&gt; RleList of length 2 #&gt; $txA #&gt; factor-Rle of length 1 with 1 run #&gt; Lengths: 1 #&gt; Values : chr2 #&gt; Levels(2): chr2 chr1 #&gt; #&gt; $txB #&gt; factor-Rle of length 2 with 1 run #&gt; Lengths: 2 #&gt; Values : chr1 #&gt; Levels(2): chr2 chr1 ranges(grl) #&gt; IRangesList of length 2 #&gt; $txA #&gt; IRanges object with 1 range and 0 metadata columns: #&gt; start end width #&gt; &lt;integer&gt; &lt;integer&gt; &lt;integer&gt; #&gt; [1] 103 106 4 #&gt; #&gt; $txB #&gt; IRanges object with 2 ranges and 0 metadata columns: #&gt; start end width #&gt; &lt;integer&gt; &lt;integer&gt; &lt;integer&gt; #&gt; [1] 107 109 3 #&gt; [2] 113 115 3 strand(grl) #&gt; RleList of length 2 #&gt; $txA #&gt; factor-Rle of length 1 with 1 run #&gt; Lengths: 1 #&gt; Values : + #&gt; Levels(3): + - * #&gt; #&gt; $txB #&gt; factor-Rle of length 2 with 2 runs #&gt; Lengths: 1 1 #&gt; Values : + - #&gt; Levels(3): + - * The length and names methods will return the length or names of the list and the seqlengths method will return the set of sequence lengths. length(grl) #&gt; [1] 2 names(grl) #&gt; [1] &quot;txA&quot; &quot;txB&quot; seqlengths(grl) #&gt; chr2 chr1 #&gt; NA NA The elementNROWS method returns a list of integers corresponding to the result of calling NROW on each individual GRanges object contained by the GRangesList. This is a faster alternative to calling lapply on the GRangesList. elementNROWS(grl) #&gt; txA txB #&gt; 1 2 isEmpty tests if a GRangesList object contains anything. isEmpty(grl) #&gt; [1] FALSE In the context of a GRangesList object, the mcols method performs a similar operation to what it does on a GRanges object. However, this metadata now refers to information at the list level instead of the level of the individual GRanges objects. mcols(grl) &lt;- c(&quot;Transcript A&quot;,&quot;Transcript B&quot;) mcols(grl) #&gt; DataFrame with 2 rows and 1 column #&gt; value #&gt; &lt;character&gt; #&gt; txA Transcript A #&gt; txB Transcript B Element-level metadata can be retrieved by unlisting the GRangesList, and extracting the metadata mcols(unlist(grl)) #&gt; DataFrame with 3 rows and 2 columns #&gt; score GC #&gt; &lt;integer&gt; &lt;numeric&gt; #&gt; txA 5 0.45 #&gt; txB 3 0.3 #&gt; txB 4 0.5 7.11 Combining GRangesList objects GRangesList objects can be unlisted to combine the separate GRanges objects that they contain as an expanded GRanges. ul &lt;- unlist(grl) ul #&gt; GRanges object with 3 ranges and 2 metadata columns: #&gt; seqnames ranges strand | score GC #&gt; &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;integer&gt; &lt;numeric&gt; #&gt; txA chr2 103-106 + | 5 0.45 #&gt; txB chr1 107-109 + | 3 0.3 #&gt; txB chr1 113-115 - | 4 0.5 #&gt; ------- #&gt; seqinfo: 2 sequences from an unspecified genome; no seqlengths Append lists using append or c. A had two GRangesList objects with ‘parallel’ elements, and wanted to combined these element-wise into a single GRangesList. One solution is to use pc() – parallel (element-wise) c(). A more general solution is to concatenate the lists and then re-group by some factor, in this case the names of the elements. grl1 &lt;- GRangesList( gr1 = GRanges(&quot;chr2&quot;, IRanges(3, 6)), gr2 = GRanges(&quot;chr1&quot;, IRanges(c(7,13), width = 3))) grl2 &lt;- GRangesList( gr1 = GRanges(&quot;chr2&quot;, IRanges(9, 12)), gr2 = GRanges(&quot;chr1&quot;, IRanges(c(25,38), width = 3))) pc(grl1, grl2) #&gt; GRangesList object of length 2: #&gt; $gr1 #&gt; GRanges object with 2 ranges and 0 metadata columns: #&gt; seqnames ranges strand #&gt; &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; #&gt; [1] chr2 3-6 * #&gt; [2] chr2 9-12 * #&gt; #&gt; $gr2 #&gt; GRanges object with 4 ranges and 0 metadata columns: #&gt; seqnames ranges strand #&gt; [1] chr1 7-9 * #&gt; [2] chr1 13-15 * #&gt; [3] chr1 25-27 * #&gt; [4] chr1 38-40 * #&gt; #&gt; ------- #&gt; seqinfo: 2 sequences from an unspecified genome; no seqlengths grl3 &lt;- c(grl1, grl2) regroup(grl3, names(grl3)) #&gt; GRangesList object of length 2: #&gt; $gr1 #&gt; GRanges object with 2 ranges and 0 metadata columns: #&gt; seqnames ranges strand #&gt; &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; #&gt; [1] chr2 3-6 * #&gt; [2] chr2 9-12 * #&gt; #&gt; $gr2 #&gt; GRanges object with 4 ranges and 0 metadata columns: #&gt; seqnames ranges strand #&gt; [1] chr1 7-9 * #&gt; [2] chr1 13-15 * #&gt; [3] chr1 25-27 * #&gt; [4] chr1 38-40 * #&gt; #&gt; ------- #&gt; seqinfo: 2 sequences from an unspecified genome; no seqlengths 7.12 Basic interval operations for GRangesList objects For interval operations, many of the same methods exist for GRangesList objects that exist for GRanges objects. start(grl) #&gt; IntegerList of length 2 #&gt; [[&quot;txA&quot;]] 103 #&gt; [[&quot;txB&quot;]] 107 113 end(grl) #&gt; IntegerList of length 2 #&gt; [[&quot;txA&quot;]] 106 #&gt; [[&quot;txB&quot;]] 109 115 width(grl) #&gt; IntegerList of length 2 #&gt; [[&quot;txA&quot;]] 4 #&gt; [[&quot;txB&quot;]] 3 3 These operations return a data structure representing, e.g., IntegerList, a list where all elements are integers; it can be convenient to use mathematical and other operations on **List* objects that work on each element, e.g., sum(width(grl)) # sum of widths of each grl element #&gt; txA txB #&gt; 4 6 Most of the intra-, inter- and between-range methods operate on GRangesList objects, e.g., to shift all the GRanges objects in a GRangesList object, or calculate the coverage. Both of these operations are also carried out across each GRanges list member. shift(grl, 20) #&gt; GRangesList object of length 2: #&gt; $txA #&gt; GRanges object with 1 range and 2 metadata columns: #&gt; seqnames ranges strand | score GC #&gt; &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;integer&gt; &lt;numeric&gt; #&gt; [1] chr2 123-126 + | 5 0.45 #&gt; #&gt; $txB #&gt; GRanges object with 2 ranges and 2 metadata columns: #&gt; seqnames ranges strand | score GC #&gt; [1] chr1 127-129 + | 3 0.3 #&gt; [2] chr1 133-135 - | 4 0.5 #&gt; #&gt; ------- #&gt; seqinfo: 2 sequences from an unspecified genome; no seqlengths coverage(grl) #&gt; RleList of length 2 #&gt; $chr2 #&gt; integer-Rle of length 106 with 2 runs #&gt; Lengths: 102 4 #&gt; Values : 0 1 #&gt; #&gt; $chr1 #&gt; integer-Rle of length 115 with 4 runs #&gt; Lengths: 106 3 3 3 #&gt; Values : 0 1 0 1 7.13 Subsetting GRangesList objects A GRangesList object is behaves like a list: [ returns a GRangesList containing a subset of the original object; [[ or \\$ returns the GRanges object at that location in the list. grl[1] grl[[1]] grl[&quot;txA&quot;] grl$txB In addition, subsetting a GRangesList also accepts a second parameter to specify which of the metadata columns you wish to select. grl[1, &quot;score&quot;] #&gt; GRangesList object of length 1: #&gt; $txA #&gt; GRanges object with 1 range and 1 metadata column: #&gt; seqnames ranges strand | score #&gt; &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;integer&gt; #&gt; [1] chr2 103-106 + | 5 #&gt; #&gt; ------- #&gt; seqinfo: 2 sequences from an unspecified genome; no seqlengths grl[&quot;txB&quot;, &quot;GC&quot;] #&gt; GRangesList object of length 1: #&gt; $txB #&gt; GRanges object with 2 ranges and 1 metadata column: #&gt; seqnames ranges strand | GC #&gt; &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;numeric&gt; #&gt; [1] chr1 107-109 + | 0.3 #&gt; [2] chr1 113-115 - | 0.5 #&gt; #&gt; ------- #&gt; seqinfo: 2 sequences from an unspecified genome; no seqlengths The head, tail, rep, rev, and window methods all behave as you would expect them to for a list object. For example, the elements referred to by window are now list elements instead of GRanges elements. rep(grl[[1]], times = 3) #&gt; GRanges object with 3 ranges and 2 metadata columns: #&gt; seqnames ranges strand | score GC #&gt; &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;integer&gt; &lt;numeric&gt; #&gt; [1] chr2 103-106 + | 5 0.45 #&gt; [2] chr2 103-106 + | 5 0.45 #&gt; [3] chr2 103-106 + | 5 0.45 #&gt; ------- #&gt; seqinfo: 2 sequences from an unspecified genome; no seqlengths rev(grl) #&gt; GRangesList object of length 2: #&gt; $txB #&gt; GRanges object with 2 ranges and 2 metadata columns: #&gt; seqnames ranges strand | score GC #&gt; &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;integer&gt; &lt;numeric&gt; #&gt; [1] chr1 107-109 + | 3 0.3 #&gt; [2] chr1 113-115 - | 4 0.5 #&gt; #&gt; $txA #&gt; GRanges object with 1 range and 2 metadata columns: #&gt; seqnames ranges strand | score GC #&gt; [1] chr2 103-106 + | 5 0.45 #&gt; #&gt; ------- #&gt; seqinfo: 2 sequences from an unspecified genome; no seqlengths head(grl, n=1) #&gt; GRangesList object of length 1: #&gt; $txA #&gt; GRanges object with 1 range and 2 metadata columns: #&gt; seqnames ranges strand | score GC #&gt; &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;integer&gt; &lt;numeric&gt; #&gt; [1] chr2 103-106 + | 5 0.45 #&gt; #&gt; ------- #&gt; seqinfo: 2 sequences from an unspecified genome; no seqlengths tail(grl, n=1) #&gt; GRangesList object of length 1: #&gt; $txB #&gt; GRanges object with 2 ranges and 2 metadata columns: #&gt; seqnames ranges strand | score GC #&gt; &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;integer&gt; &lt;numeric&gt; #&gt; [1] chr1 107-109 + | 3 0.3 #&gt; [2] chr1 113-115 - | 4 0.5 #&gt; #&gt; ------- #&gt; seqinfo: 2 sequences from an unspecified genome; no seqlengths window(grl, start=1, end=1) #&gt; GRangesList object of length 1: #&gt; $txA #&gt; GRanges object with 1 range and 2 metadata columns: #&gt; seqnames ranges strand | score GC #&gt; &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;integer&gt; &lt;numeric&gt; #&gt; [1] chr2 103-106 + | 5 0.45 #&gt; #&gt; ------- #&gt; seqinfo: 2 sequences from an unspecified genome; no seqlengths grl[IRanges(start=2, end=2)] #&gt; GRangesList object of length 1: #&gt; $txB #&gt; GRanges object with 2 ranges and 2 metadata columns: #&gt; seqnames ranges strand | score GC #&gt; &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;integer&gt; &lt;numeric&gt; #&gt; [1] chr1 107-109 + | 3 0.3 #&gt; [2] chr1 113-115 - | 4 0.5 #&gt; #&gt; ------- #&gt; seqinfo: 2 sequences from an unspecified genome; no seqlengths 7.14 Looping over GRangesList objects For GRangesList objects there is also a family of apply methods. These include lapply, sapply, mapply, endoapply, mendoapply, Map, and Reduce. The different looping methods defined for GRangesList objects are useful for returning different kinds of results. The standard lapply and sapply behave according to convention, with the lapply method returning a list and sapply returning a more simplified output. lapply(grl, length) #&gt; $txA #&gt; [1] 1 #&gt; #&gt; $txB #&gt; [1] 2 sapply(grl, length) #&gt; txA txB #&gt; 1 2 As with IRanges objects, there is also a multivariate version of sapply, called mapply, defined for GRangesList objects. And, if you don’t want the results simplified, you can call the Map method, which does the same things as mapply but without simplifying the output. grl2 &lt;- shift(grl, 10) names(grl2) &lt;- c(&quot;shiftTxA&quot;, &quot;shiftTxB&quot;) mapply(c, grl, grl2) #&gt; $txA #&gt; GRanges object with 2 ranges and 2 metadata columns: #&gt; seqnames ranges strand | score GC #&gt; &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;integer&gt; &lt;numeric&gt; #&gt; [1] chr2 103-106 + | 5 0.45 #&gt; [2] chr2 113-116 + | 5 0.45 #&gt; ------- #&gt; seqinfo: 2 sequences from an unspecified genome; no seqlengths #&gt; #&gt; $txB #&gt; GRanges object with 4 ranges and 2 metadata columns: #&gt; seqnames ranges strand | score GC #&gt; &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;integer&gt; &lt;numeric&gt; #&gt; [1] chr1 107-109 + | 3 0.3 #&gt; [2] chr1 113-115 - | 4 0.5 #&gt; [3] chr1 117-119 + | 3 0.3 #&gt; [4] chr1 123-125 - | 4 0.5 #&gt; ------- #&gt; seqinfo: 2 sequences from an unspecified genome; no seqlengths Map(c, grl, grl2) #&gt; $txA #&gt; GRanges object with 2 ranges and 2 metadata columns: #&gt; seqnames ranges strand | score GC #&gt; &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;integer&gt; &lt;numeric&gt; #&gt; [1] chr2 103-106 + | 5 0.45 #&gt; [2] chr2 113-116 + | 5 0.45 #&gt; ------- #&gt; seqinfo: 2 sequences from an unspecified genome; no seqlengths #&gt; #&gt; $txB #&gt; GRanges object with 4 ranges and 2 metadata columns: #&gt; seqnames ranges strand | score GC #&gt; &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;integer&gt; &lt;numeric&gt; #&gt; [1] chr1 107-109 + | 3 0.3 #&gt; [2] chr1 113-115 - | 4 0.5 #&gt; [3] chr1 117-119 + | 3 0.3 #&gt; [4] chr1 123-125 - | 4 0.5 #&gt; ------- #&gt; seqinfo: 2 sequences from an unspecified genome; no seqlengths Sometimes you will want to get back a modified version of the GRangesList that you originally passed in. An endomorphism is a transformation of an object to another instance of the same class . This is achieved using the endoapply method, which will return the results as a GRangesList object. endoapply(grl, rev) #&gt; GRangesList object of length 2: #&gt; $txA #&gt; GRanges object with 1 range and 2 metadata columns: #&gt; seqnames ranges strand | score GC #&gt; &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;integer&gt; &lt;numeric&gt; #&gt; [1] chr2 103-106 + | 5 0.45 #&gt; #&gt; $txB #&gt; GRanges object with 2 ranges and 2 metadata columns: #&gt; seqnames ranges strand | score GC #&gt; [1] chr1 113-115 - | 4 0.5 #&gt; [2] chr1 107-109 + | 3 0.3 #&gt; #&gt; ------- #&gt; seqinfo: 2 sequences from an unspecified genome; no seqlengths mendoapply(c, grl, grl2) #&gt; GRangesList object of length 2: #&gt; $txA #&gt; GRanges object with 2 ranges and 2 metadata columns: #&gt; seqnames ranges strand | score GC #&gt; &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;integer&gt; &lt;numeric&gt; #&gt; [1] chr2 103-106 + | 5 0.45 #&gt; [2] chr2 113-116 + | 5 0.45 #&gt; #&gt; $txB #&gt; GRanges object with 4 ranges and 2 metadata columns: #&gt; seqnames ranges strand | score GC #&gt; [1] chr1 107-109 + | 3 0.3 #&gt; [2] chr1 113-115 - | 4 0.5 #&gt; [3] chr1 117-119 + | 3 0.3 #&gt; [4] chr1 123-125 - | 4 0.5 #&gt; #&gt; ------- #&gt; seqinfo: 2 sequences from an unspecified genome; no seqlengths The Reduce method will allow the GRanges objects to be collapsed across the whole of the GRangesList object. % Again, this seems like a sub-optimal example to me. Reduce(c, grl) #&gt; GRanges object with 3 ranges and 2 metadata columns: #&gt; seqnames ranges strand | score GC #&gt; &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;integer&gt; &lt;numeric&gt; #&gt; [1] chr2 103-106 + | 5 0.45 #&gt; [2] chr1 107-109 + | 3 0.3 #&gt; [3] chr1 113-115 - | 4 0.5 #&gt; ------- #&gt; seqinfo: 2 sequences from an unspecified genome; no seqlengths Explicit element-wise operations (lapply() and friends) on GRangesList objects with many elements can be slow. It is therefore beneficial to explore operations that work on *List objects directly (e.g., many of the group generic' operators, see?S4groupGeneric, and the set and parallel set operators (e.g.,union,punion). A useful and fast strategy is tounlistthe *GRangesList* to a *GRanges* object, operate on the *GRanges* object, thenrelist` the result, e.g., gr &lt;- unlist(grl) gr$log_score &lt;- log(gr$score) grl &lt;- relist(gr, grl) grl #&gt; GRangesList object of length 2: #&gt; $txA #&gt; GRanges object with 1 range and 3 metadata columns: #&gt; seqnames ranges strand | score GC log_score #&gt; &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;integer&gt; &lt;numeric&gt; &lt;numeric&gt; #&gt; txA chr2 103-106 + | 5 0.45 1.6094379124341 #&gt; #&gt; $txB #&gt; GRanges object with 2 ranges and 3 metadata columns: #&gt; seqnames ranges strand | score GC log_score #&gt; txB chr1 107-109 + | 3 0.3 1.09861228866811 #&gt; txB chr1 113-115 - | 4 0.5 1.38629436111989 #&gt; #&gt; ------- #&gt; seqinfo: 2 sequences from an unspecified genome; no seqlengths See also ?extractList. For more information on the GRangesList classes be sure to consult the manual page and available methods ?GRangesList methods(class=&quot;GRangesList&quot;) # _partial_ list Interval overlapping is the process of comparing the ranges in two objects to determine if and when they overlap. As such, it is perhaps the most common operation performed on GRanges and GRangesList objects. To this end, the GenomicRanges package provides a family of interval overlap functions. The most general of these functions is findOverlaps, which takes a query and a subject as inputs and returns a Hits object containing the index pairings for the overlapping elements. mtch &lt;- findOverlaps(gr, grl) as.matrix(mtch) #&gt; queryHits subjectHits #&gt; [1,] 1 1 #&gt; [2,] 2 2 #&gt; [3,] 3 2 As suggested in the sections discussing the nature of the GRanges and GRangesList classes, the index in the above matrix of hits for a GRanges object is a single range while for a GRangesList object it is the set of ranges that define a “feature”. Another function in the overlaps family is countOverlaps, which tabulates the number of overlaps for each element in the query. countOverlaps(gr, grl) #&gt; txA txB txB #&gt; 1 1 1 A third function in this family is subsetByOverlaps, which extracts the elements in the query that overlap at least one element in the subject. subsetByOverlaps(gr,grl) #&gt; GRanges object with 3 ranges and 3 metadata columns: #&gt; seqnames ranges strand | score GC log_score #&gt; &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;integer&gt; &lt;numeric&gt; &lt;numeric&gt; #&gt; txA chr2 103-106 + | 5 0.45 1.6094379124341 #&gt; txB chr1 107-109 + | 3 0.3 1.09861228866811 #&gt; txB chr1 113-115 - | 4 0.5 1.38629436111989 #&gt; ------- #&gt; seqinfo: 2 sequences from an unspecified genome; no seqlengths Finally, you can use the select argument to get the index of the first overlapping element in the subject for each element in the query. findOverlaps(gr, grl, select=&quot;first&quot;) #&gt; [1] 1 2 2 findOverlaps(grl, gr, select=&quot;first&quot;) #&gt; [1] 1 2 "],
["fluent-genomic-data-analysis-with-plyranges.html", "8 Fluent genomic data analysis with plyranges 8.1 Instructor(s) name(s) and contact information 8.2 Workshop Description 8.3 Workshop goals and objectives 8.4 Workshop 8.5 Introduction 8.6 Setup 8.7 What are GRanges objects? 8.8 The Grammar 8.9 Data import and creating pipelines 8.10 What’s next? 8.11 Appendix", " 8 Fluent genomic data analysis with plyranges 8.1 Instructor(s) name(s) and contact information Stuart Lee (lee.s@wehi.edu.au) Michael Lawrence (lawremi@gmail.com) 8.2 Workshop Description In this workshop, we will give an overview of how to perform low-level analyses of genomic data using the grammar of genomic data transformation defined in the plyranges package. We will cover: introduction to GRanges overview of the core verbs for arithmetic, restriction, and aggregation of GRanges objects performing joins between GRanges objects designing pipelines to quickly explore data from AnnotationHub reading BAM and other file types as GRanges objects The workshop will be a computer lab, in which the participants will be able to ask questions and interact with the instructors. 8.2.1 Pre-requisites This workshop is self-contained however familiarity with the following would be useful: plyranges vignette the GenomicRanges and IRanges packages tidyverse approaches to data analysis 8.2.2 Workshop Participation Students will work through an Rmarkdown document while the instructors respond to any questions they have. 8.2.3 R / Bioconductor packages used plyranges airway AnnotationHub GenomicRanges IRanges S4Vectors 8.2.4 Time outline Activity Time Overview of GRanges 5m The plyranges grammar 20m I/O and data pipelines 20m 8.3 Workshop goals and objectives 8.3.1 Learning goals Understand that GRanges follows tidy data principles Apply the plyranges grammar to genomic data analysis 8.3.2 Learning objectives Use AnnotationHub to find and summarise data Read files into R as GRanges objects Perform coverage analysis Build data pipelines for analysis based on GRanges 8.4 Workshop 8.5 Introduction 8.5.1 What is plyranges? The plyranges package is a domain specific language (DSL) built on top of the IRanges and GenomicRanges packages (Lee, Cook, and Lawrence (2018); Lawrence et al. (2013)). It is designed to quickly and coherently analyse genomic data in the form of GRanges objects (more on those later!) and from a wide variety of genomic data file types. For users who are familiar with the tidyverse, the grammar that plyranges implements will look familiar but with a few modifications for genomic specific tasks. 8.5.2 Why use plyranges? The grammar that plyranges develops is helpful for reasoning about genomics data analysis, and provides a way of developing short readable analysis pipelines. We have tried to emphasise consistency and code readability by following the design principles outlined by Green and Petre (1996). One of the goals of plyranges is to provide an alternative entry point to analysing genomics data with Bioconductor, especially for R beginners and R users who are more familiar with the tidyverse approach to data analysis. As a result, we have de-emphasised the use of more complicated data structures provided by core Bioconductor packages that are useful for programming with. 8.5.3 Who is this workshop for? This workshop is intended for new users of Bioconductor, users who are interested to learn about grammar based approaches for data analysis, and users who are interested in learning how to use R to perform analyses like those available in the command line packages BEDTools (Quinlan and Hall (2010)). If that’s you, let’s begin! 8.6 Setup To participate in this workshop you’ll need to have R &gt;= 3.5 and install the plyranges, AnnotationHub, and airway Bioconductor 3.7 packages (Morgan (2018); Love (2018)). You can achieve this by installing the BiocManager package from CRAN, loading it then running the install command: install.packages(&quot;BiocManager&quot;) library(BiocManager) install(c(&quot;plyranges&quot;, &quot;AnnotationHub&quot;, &quot;airway&quot;)) 8.7 What are GRanges objects? Figure 8.1: An illustration of a GRanges data object for a single sample from an RNA-seq experiment. The core components of the object include a seqname column (representing the chromosome), a ranges column which consists of start and end coordinates for a genomic region, and a strand identifier (either positive, negative, or unstranded). Metadata are included as columns to the right of the dotted line as annotations (gene_id) or range level covariates (score). The plyranges package is built on the core Bioconductor data structure GRanges. It is very similar to the base R data.frame but with appropriate semantics for a genomics experiment: it has fixed columns for the chromosome, start and end coordinates, and the strand, along with an arbitrary set of additional columns, consisting of measurements or metadata specific to the data type or experiment (figure 8.1). GRanges balances flexibility with formal constraints, so that it is applicable to virtually any genomic workflow, while also being semantically rich enough to support high-level operations on genomic ranges. As a core data structure, GRanges enables compatibility between plyranges and the rest of Bioconductor. Since a GRanges object is similar to a data.frame, we can use plyranges to construct a GRanges object from a data.frame. We’ll start by supposing we have a data.frame of genes from the yeast genome: library(plyranges, quietly = TRUE) genes &lt;- data.frame(seqnames = &quot;VI&quot;, start = c(3322, 3030, 1437, 5066, 6426, 836), end = c(3846, 3338, 2615, 5521, 7565, 1363), strand = c(&quot;-&quot;, &quot;-&quot;, &quot;-&quot;, &quot;+&quot;, &quot;+&quot;, &quot;+&quot;), gene_id=c(&quot;YFL064C&quot;, &quot;YFL065C&quot;, &quot;YFL066C&quot;, &quot;YFL063W&quot;, &quot;YFL062W&quot;, &quot;YFL067W&quot;), stringsAsFactors = FALSE) gr &lt;- as_granges(genes) gr #&gt; GRanges object with 6 ranges and 1 metadata column: #&gt; seqnames ranges strand | gene_id #&gt; &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;character&gt; #&gt; [1] VI 3322-3846 - | YFL064C #&gt; [2] VI 3030-3338 - | YFL065C #&gt; [3] VI 1437-2615 - | YFL066C #&gt; [4] VI 5066-5521 + | YFL063W #&gt; [5] VI 6426-7565 + | YFL062W #&gt; [6] VI 836-1363 + | YFL067W #&gt; ------- #&gt; seqinfo: 1 sequence from an unspecified genome; no seqlengths The as_granges method takes a data.frame and allows you to quickly convert it to a GRanges object (and can you can also specify which columns in the data.frame correspond to the columns in the GRanges). A GRanges object follows tidy data principles: it is a rectangular table corresponding to a single biological context (Wickham (2014)). Each row contains a single observation and each column is a variable describing the observations. In the example above, each row corresponds to a single gene, and each column contains information about those genes. As GRanges are tidy, we have constructed plyranges to follow and extend the grammar in the R package dplyr. 8.8 The Grammar Here we provide a quick overview of the functions available in plyranges and illustrate their use with some toy examples (see 8.11 for an overview). In the final section we provide two worked examples (with exercises) that show you can use plyranges to explore publicly available genomics data and perform coverage analysis of BAM files. 8.8.1 Core verbs The plyranges grammar is simply a set of verbs that define actions to be performed on a GRanges (for a complete list see the appendix). Verbs can be composed together using the pipe operator, %&gt;%, which can be read as ‘then’. Here’s a simple pipeline: first we will add two columns, one corresponding to the gene_type and another with the GC content (which we make up by drawing from a uniform distribution). Second we will remove genes if they have a width less than 400bp. set.seed(2018-07-28) gr2 &lt;- gr %&gt;% mutate(gene_type = &quot;ORF&quot;, gc_content = runif(n())) %&gt;% filter(width &gt; 400) gr2 #&gt; GRanges object with 5 ranges and 3 metadata columns: #&gt; seqnames ranges strand | gene_id gene_type #&gt; &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;character&gt; &lt;character&gt; #&gt; [1] VI 3322-3846 - | YFL064C ORF #&gt; [2] VI 1437-2615 - | YFL066C ORF #&gt; [3] VI 5066-5521 + | YFL063W ORF #&gt; [4] VI 6426-7565 + | YFL062W ORF #&gt; [5] VI 836-1363 + | YFL067W ORF #&gt; gc_content #&gt; &lt;numeric&gt; #&gt; [1] 0.49319754820317 #&gt; [2] 0.216616344172508 #&gt; [3] 0.747259315103292 #&gt; [4] 0.907683959929273 #&gt; [5] 0.221016310621053 #&gt; ------- #&gt; seqinfo: 1 sequence from an unspecified genome; no seqlengths The mutate() function is used to add columns, here we’ve added one column called gene_type where all values are set to “ORF” (standing for open reading frame) and another called gc_content with random uniform values. The n() operator returns the number of ranges in GRanges object, but can only be evaluated inside of one of the plyranges verbs. The filter() operation returns ranges if the expression evaluates to TRUE. Multiple expressions can be composed together and will be evaluated as &amp; gr2 %&gt;% filter(strand == &quot;+&quot;, gc_content &gt; 0.5) #&gt; GRanges object with 2 ranges and 3 metadata columns: #&gt; seqnames ranges strand | gene_id gene_type #&gt; &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;character&gt; &lt;character&gt; #&gt; [1] VI 5066-5521 + | YFL063W ORF #&gt; [2] VI 6426-7565 + | YFL062W ORF #&gt; gc_content #&gt; &lt;numeric&gt; #&gt; [1] 0.747259315103292 #&gt; [2] 0.907683959929273 #&gt; ------- #&gt; seqinfo: 1 sequence from an unspecified genome; no seqlengths # is the same as using `&amp;` gr2 %&gt;% filter(strand == &quot;+&quot; &amp; gc_content &gt; 0.5) #&gt; GRanges object with 2 ranges and 3 metadata columns: #&gt; seqnames ranges strand | gene_id gene_type #&gt; &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;character&gt; &lt;character&gt; #&gt; [1] VI 5066-5521 + | YFL063W ORF #&gt; [2] VI 6426-7565 + | YFL062W ORF #&gt; gc_content #&gt; &lt;numeric&gt; #&gt; [1] 0.747259315103292 #&gt; [2] 0.907683959929273 #&gt; ------- #&gt; seqinfo: 1 sequence from an unspecified genome; no seqlengths # but different from using or &#39;|&#39; gr2 %&gt;% filter(strand == &quot;+&quot; | gc_content &gt; 0.5) #&gt; GRanges object with 3 ranges and 3 metadata columns: #&gt; seqnames ranges strand | gene_id gene_type #&gt; &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;character&gt; &lt;character&gt; #&gt; [1] VI 5066-5521 + | YFL063W ORF #&gt; [2] VI 6426-7565 + | YFL062W ORF #&gt; [3] VI 836-1363 + | YFL067W ORF #&gt; gc_content #&gt; &lt;numeric&gt; #&gt; [1] 0.747259315103292 #&gt; [2] 0.907683959929273 #&gt; [3] 0.221016310621053 #&gt; ------- #&gt; seqinfo: 1 sequence from an unspecified genome; no seqlengths Now that we have some measurements over our genes, we are most likely interested in performing the favourite tasks of a biological data scientist: taking averages and counting. This is achieved with the summarise() verb which will return a DataFrame object (Why is this the case?). gr2 %&gt;% summarise(avg_gc = mean(gc_content), n = n()) #&gt; DataFrame with 1 row and 2 columns #&gt; avg_gc n #&gt; &lt;numeric&gt; &lt;integer&gt; #&gt; 1 0.517154695605859 5 which isn’t very exciting when performed without summarise()’s best friend the group_by() operator: gr2 %&gt;% group_by(strand) %&gt;% summarise(avg_gc = mean(gc_content), n = n()) #&gt; DataFrame with 2 rows and 3 columns #&gt; strand avg_gc n #&gt; &lt;Rle&gt; &lt;numeric&gt; &lt;integer&gt; #&gt; 1 + 0.625319861884539 3 #&gt; 2 - 0.354906946187839 2 The group_by() operator causes plyranges verbs to behave differently. Instead of acting on all the ranges in a GRanges object, the verbs act within each group of ranges defined by the values in the grouping column(s). The group_by() operator does not change the appearance the of a GRanges object (well for the most part): by_strand &lt;- gr2 %&gt;% group_by(strand) by_strand #&gt; GRanges object with 5 ranges and 3 metadata columns: #&gt; Groups: strand [2] #&gt; seqnames ranges strand | gene_id gene_type #&gt; &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;character&gt; &lt;character&gt; #&gt; [1] VI 3322-3846 - | YFL064C ORF #&gt; [2] VI 1437-2615 - | YFL066C ORF #&gt; [3] VI 5066-5521 + | YFL063W ORF #&gt; [4] VI 6426-7565 + | YFL062W ORF #&gt; [5] VI 836-1363 + | YFL067W ORF #&gt; gc_content #&gt; &lt;numeric&gt; #&gt; [1] 0.49319754820317 #&gt; [2] 0.216616344172508 #&gt; [3] 0.747259315103292 #&gt; [4] 0.907683959929273 #&gt; [5] 0.221016310621053 #&gt; ------- #&gt; seqinfo: 1 sequence from an unspecified genome; no seqlengths Now any verb we apply to our grouped GRanges, acts on each partition: by_strand %&gt;% filter(n() &gt; 2) #&gt; GRanges object with 3 ranges and 3 metadata columns: #&gt; Groups: strand [1] #&gt; seqnames ranges strand | gene_id gene_type #&gt; &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;character&gt; &lt;character&gt; #&gt; [1] VI 5066-5521 + | YFL063W ORF #&gt; [2] VI 6426-7565 + | YFL062W ORF #&gt; [3] VI 836-1363 + | YFL067W ORF #&gt; gc_content #&gt; &lt;numeric&gt; #&gt; [1] 0.747259315103292 #&gt; [2] 0.907683959929273 #&gt; [3] 0.221016310621053 #&gt; ------- #&gt; seqinfo: 1 sequence from an unspecified genome; no seqlengths by_strand %&gt;% mutate(avg_gc_strand = mean(gc_content)) #&gt; GRanges object with 5 ranges and 4 metadata columns: #&gt; Groups: strand [2] #&gt; seqnames ranges strand | gene_id gene_type #&gt; &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;character&gt; &lt;character&gt; #&gt; [1] VI 3322-3846 - | YFL064C ORF #&gt; [2] VI 1437-2615 - | YFL066C ORF #&gt; [3] VI 5066-5521 + | YFL063W ORF #&gt; [4] VI 6426-7565 + | YFL062W ORF #&gt; [5] VI 836-1363 + | YFL067W ORF #&gt; gc_content avg_gc_strand #&gt; &lt;numeric&gt; &lt;numeric&gt; #&gt; [1] 0.49319754820317 0.354906946187839 #&gt; [2] 0.216616344172508 0.354906946187839 #&gt; [3] 0.747259315103292 0.625319861884539 #&gt; [4] 0.907683959929273 0.625319861884539 #&gt; [5] 0.221016310621053 0.625319861884539 #&gt; ------- #&gt; seqinfo: 1 sequence from an unspecified genome; no seqlengths To remove grouping use the ungroup() verb: by_strand %&gt;% ungroup() #&gt; GRanges object with 5 ranges and 3 metadata columns: #&gt; seqnames ranges strand | gene_id gene_type #&gt; &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;character&gt; &lt;character&gt; #&gt; [1] VI 3322-3846 - | YFL064C ORF #&gt; [2] VI 1437-2615 - | YFL066C ORF #&gt; [3] VI 5066-5521 + | YFL063W ORF #&gt; [4] VI 6426-7565 + | YFL062W ORF #&gt; [5] VI 836-1363 + | YFL067W ORF #&gt; gc_content #&gt; &lt;numeric&gt; #&gt; [1] 0.49319754820317 #&gt; [2] 0.216616344172508 #&gt; [3] 0.747259315103292 #&gt; [4] 0.907683959929273 #&gt; [5] 0.221016310621053 #&gt; ------- #&gt; seqinfo: 1 sequence from an unspecified genome; no seqlengths Finally, metadata columns can be selected using the select() verb: gr2 %&gt;% select(gene_id, gene_type) #&gt; GRanges object with 5 ranges and 2 metadata columns: #&gt; seqnames ranges strand | gene_id gene_type #&gt; &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;character&gt; &lt;character&gt; #&gt; [1] VI 3322-3846 - | YFL064C ORF #&gt; [2] VI 1437-2615 - | YFL066C ORF #&gt; [3] VI 5066-5521 + | YFL063W ORF #&gt; [4] VI 6426-7565 + | YFL062W ORF #&gt; [5] VI 836-1363 + | YFL067W ORF #&gt; ------- #&gt; seqinfo: 1 sequence from an unspecified genome; no seqlengths # is the same as not selecting gc_content gr2 %&gt;% select(-gc_content) #&gt; GRanges object with 5 ranges and 2 metadata columns: #&gt; seqnames ranges strand | gene_id gene_type #&gt; &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;character&gt; &lt;character&gt; #&gt; [1] VI 3322-3846 - | YFL064C ORF #&gt; [2] VI 1437-2615 - | YFL066C ORF #&gt; [3] VI 5066-5521 + | YFL063W ORF #&gt; [4] VI 6426-7565 + | YFL062W ORF #&gt; [5] VI 836-1363 + | YFL067W ORF #&gt; ------- #&gt; seqinfo: 1 sequence from an unspecified genome; no seqlengths # you can also select by metadata column index gr2 %&gt;% select(1:2) #&gt; GRanges object with 5 ranges and 2 metadata columns: #&gt; seqnames ranges strand | gene_id gene_type #&gt; &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;character&gt; &lt;character&gt; #&gt; [1] VI 3322-3846 - | YFL064C ORF #&gt; [2] VI 1437-2615 - | YFL066C ORF #&gt; [3] VI 5066-5521 + | YFL063W ORF #&gt; [4] VI 6426-7565 + | YFL062W ORF #&gt; [5] VI 836-1363 + | YFL067W ORF #&gt; ------- #&gt; seqinfo: 1 sequence from an unspecified genome; no seqlengths 8.8.2 Verbs specific to GRanges We have seen how you can perform restriction and aggregation on GRanges, but what about specific actions for genomics data analysis, like arithmetic, nearest neighbours or finding overlaps? 8.8.2.1 Arithmetic Arithmetic operations transform range coordinates, as defined by their start, end and width columns. These three variables are mutually dependent so we have to take care when modifying them. For example, changing the width column needs to change either the start, end or both to preserve integrity of the GRanges: # by default setting width will fix the starting coordinate gr %&gt;% mutate(width = width + 1) #&gt; GRanges object with 6 ranges and 1 metadata column: #&gt; seqnames ranges strand | gene_id #&gt; &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;character&gt; #&gt; [1] VI 3322-3847 - | YFL064C #&gt; [2] VI 3030-3339 - | YFL065C #&gt; [3] VI 1437-2616 - | YFL066C #&gt; [4] VI 5066-5522 + | YFL063W #&gt; [5] VI 6426-7566 + | YFL062W #&gt; [6] VI 836-1364 + | YFL067W #&gt; ------- #&gt; seqinfo: 1 sequence from an unspecified genome; no seqlengths We introduce the anchor_direction() operator to clarify these modifications. Supported anchor points include the start anchor_start(), end anchor_end() and midpoint anchor_center(): gr %&gt;% anchor_end() %&gt;% mutate(width = width * 2) #&gt; GRanges object with 6 ranges and 1 metadata column: #&gt; seqnames ranges strand | gene_id #&gt; &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;character&gt; #&gt; [1] VI 2797-3846 - | YFL064C #&gt; [2] VI 2721-3338 - | YFL065C #&gt; [3] VI 258-2615 - | YFL066C #&gt; [4] VI 4610-5521 + | YFL063W #&gt; [5] VI 5286-7565 + | YFL062W #&gt; [6] VI 308-1363 + | YFL067W #&gt; ------- #&gt; seqinfo: 1 sequence from an unspecified genome; no seqlengths gr %&gt;% anchor_center() %&gt;% mutate(width = width * 2) #&gt; GRanges object with 6 ranges and 1 metadata column: #&gt; seqnames ranges strand | gene_id #&gt; &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;character&gt; #&gt; [1] VI 3059-4108 - | YFL064C #&gt; [2] VI 2875-3492 - | YFL065C #&gt; [3] VI 847-3204 - | YFL066C #&gt; [4] VI 4838-5749 + | YFL063W #&gt; [5] VI 5856-8135 + | YFL062W #&gt; [6] VI 572-1627 + | YFL067W #&gt; ------- #&gt; seqinfo: 1 sequence from an unspecified genome; no seqlengths Note that the anchoring modifier introduces an important departure from the IRanges and GenomicRanges packages: by default we ignore the strandedness of a GRanges object, and instead we provide verbs that make stranded actions explicit. In this case of anchoring we provide the anchor_3p() and anchor_5p() to perform anchoring on the 3’ and 5’ ends of a range. The table in the appendix provides a complete list of arithmetic options available in plyranges. 8.8.2.2 Genomic aggregation There are two verbs that can be used to aggregate over nearest neighbours: reduce_ranges() and disjoin_ranges(). The reduce verb merges overlapping and neighbouring ranges: gr %&gt;% reduce_ranges() #&gt; GRanges object with 5 ranges and 0 metadata columns: #&gt; seqnames ranges strand #&gt; &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; #&gt; [1] VI 836-1363 * #&gt; [2] VI 1437-2615 * #&gt; [3] VI 3030-3846 * #&gt; [4] VI 5066-5521 * #&gt; [5] VI 6426-7565 * #&gt; ------- #&gt; seqinfo: 1 sequence from an unspecified genome; no seqlengths We could find out which genes are overlapping each other by aggregating over the gene_id column and storing the result in a List column: gr %&gt;% reduce_ranges(gene_id = List(gene_id)) #&gt; GRanges object with 5 ranges and 1 metadata column: #&gt; seqnames ranges strand | gene_id #&gt; &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;CharacterList&gt; #&gt; [1] VI 836-1363 * | YFL067W #&gt; [2] VI 1437-2615 * | YFL066C #&gt; [3] VI 3030-3846 * | YFL065C,YFL064C #&gt; [4] VI 5066-5521 * | YFL063W #&gt; [5] VI 6426-7565 * | YFL062W #&gt; ------- #&gt; seqinfo: 1 sequence from an unspecified genome; no seqlengths The disjoin verb takes the union of end points over all ranges, and results in an expanded range gr %&gt;% disjoin_ranges(gene_id = List(gene_id)) #&gt; GRanges object with 7 ranges and 1 metadata column: #&gt; seqnames ranges strand | gene_id #&gt; &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;CharacterList&gt; #&gt; [1] VI 836-1363 * | YFL067W #&gt; [2] VI 1437-2615 * | YFL066C #&gt; [3] VI 3030-3321 * | YFL065C #&gt; [4] VI 3322-3338 * | YFL064C,YFL065C #&gt; [5] VI 3339-3846 * | YFL064C #&gt; [6] VI 5066-5521 * | YFL063W #&gt; [7] VI 6426-7565 * | YFL062W #&gt; ------- #&gt; seqinfo: 1 sequence from an unspecified genome; no seqlengths You may have noticed that the resulting range are now unstranded, to take into account stranded features use the directed prefix. 8.8.2.3 Overlaps Another important class of operations for genomics data analysis is finding overlaps or nearest neighbours. Here’s where we will introduce the plyranges join operators and the overlap aggregation operators. Now let’s now suppose we have some additional measurements that we have obtained from a new experiment on yeast. These measurements are for three different replicates and represent single nucleotide or insertion deletion intensities from an array. Our collaborator has given us three different data.frames with the data but they all have names inconsistent with the GRanges data structure. Our goal is to unify these into a single GRanges object with column for each measurement and column for the sample identifier. Here’s our data: set.seed(66+105+111+99+49+56) pos &lt;- sample(1:10000, size = 100) size &lt;- sample(1:3, size = 100, replace = TRUE) rep1 &lt;- data.frame(chr = &quot;VI&quot;, pos = pos, size = size, X = rnorm(100, mean = 2), Y = rnorm(100, mean = 1)) rep2 &lt;- data.frame(chrom = &quot;VI&quot;, st = pos, width = size, X = rnorm(100, mean = 0.5, sd = 3), Y = rnorm(100, sd = 2)) rep3 &lt;- data.frame(chromosome = &quot;VI&quot;, start = pos, width = size, X = rnorm(100, mean = 2, sd = 3), Y = rnorm(100, mean = 4, sd = 0.5)) For each replicate we want to construct a GRanges object: # we can tell as_granges which columns in the data.frame # are the seqnames, and range coordinates rep1 &lt;- as_granges(rep1, seqnames = chr, start = pos, width = size) rep2 &lt;- as_granges(rep2, seqnames = chrom, start = st) rep3 &lt;- as_granges(rep3, seqnames = chromosome) And to construct our final GRanges object we can bind all our replicates together: intensities &lt;- bind_ranges(rep1, rep2, rep3, .id = &quot;replicate&quot;) # sort by the starting coordinate arrange(intensities, start) #&gt; GRanges object with 300 ranges and 3 metadata columns: #&gt; seqnames ranges strand | X Y #&gt; &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;numeric&gt; &lt;numeric&gt; #&gt; [1] VI 99-100 * | 2.18077108319727 1.15893283880961 #&gt; [2] VI 99-100 * | -1.14331853023759 -1.84545382593297 #&gt; [3] VI 99-100 * | 4.42535734042167 3.53884540635964 #&gt; [4] VI 110-111 * | 1.41581829875993 -0.262026041514519 #&gt; [5] VI 110-111 * | 0.0203313104969627 -1.18095384044377 #&gt; ... ... ... ... . ... ... #&gt; [296] VI 9671-9673 * | 0.756423808063998 -0.24544579405238 #&gt; [297] VI 9671-9673 * | 0.715559817063897 4.6963376859667 #&gt; [298] VI 9838-9839 * | 1.83836043312615 0.267996156074214 #&gt; [299] VI 9838-9839 * | -4.62774336616852 -3.45271032367217 #&gt; [300] VI 9838-9839 * | -0.285141455604857 4.16118336728783 #&gt; replicate #&gt; &lt;character&gt; #&gt; [1] 1 #&gt; [2] 2 #&gt; [3] 3 #&gt; [4] 1 #&gt; [5] 2 #&gt; ... ... #&gt; [296] 2 #&gt; [297] 3 #&gt; [298] 1 #&gt; [299] 2 #&gt; [300] 3 #&gt; ------- #&gt; seqinfo: 1 sequence from an unspecified genome; no seqlengths Now we would like to filter our positions if they overlap one of the genes we have, one way we could achieve this is with the filter_by_overlaps() operator: olap &lt;- filter_by_overlaps(intensities, gr) olap #&gt; GRanges object with 108 ranges and 3 metadata columns: #&gt; seqnames ranges strand | X Y #&gt; &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;numeric&gt; &lt;numeric&gt; #&gt; [1] VI 3300-3302 * | 2.26035109119553 1.06568454447289 #&gt; [2] VI 1045-1047 * | 2.21864775104592 1.08876098679654 #&gt; [3] VI 3791-3793 * | 2.64672161626967 1.49683387927811 #&gt; [4] VI 6503 * | 2.97614069143102 -0.842974371427135 #&gt; [5] VI 2613-2615 * | 0.829706619102562 1.00867596057383 #&gt; ... ... ... ... . ... ... #&gt; [104] VI 2288 * | 4.51377823089056 3.98977444171162 #&gt; [105] VI 7191 * | -3.91180888573709 5.0451068476909 #&gt; [106] VI 5490 * | 6.8026659440345 4.71157047258809 #&gt; [107] VI 5268-5270 * | -1.40753324511308 4.48936193681021 #&gt; [108] VI 7333 * | -0.807795033496545 4.12171733927051 #&gt; replicate #&gt; &lt;character&gt; #&gt; [1] 1 #&gt; [2] 1 #&gt; [3] 1 #&gt; [4] 1 #&gt; [5] 1 #&gt; ... ... #&gt; [104] 3 #&gt; [105] 3 #&gt; [106] 3 #&gt; [107] 3 #&gt; [108] 3 #&gt; ------- #&gt; seqinfo: 1 sequence from an unspecified genome; no seqlengths Another option would be to perform a join operation. A join acts on two GRanges objects, a query and a subject. The join operator retains the metadata from the query and subject ranges. All join operators generate a set of hits based on overlap or proximity of ranges and use those hits to merge the two datasets in different ways (figure , provides an overview of the overlap joins). We can further restrict the matching by whether the query is completely within the subject, and adding the directed suffix ensures that matching ranges have the same direction (strand). Figure 8.2: Illustration of the three overlap join operators. Each join takes query and subject range as input (black and light gray rectangles, respectively). An index for the join is computed, returning a Hits object, which contains the indices of where the subject overlaps the query range. This index is used to expand the query ranges by where it was ‘hit’ by the subject ranges. The join semantics alter what is returned: for an join the query range is returned for each match, for an the intersection is taken between overlapping ranges, and for a join all query ranges are returned even if the subject range does not overlap them. This principle is gnerally applied through the plyranges package for both overlaps and nearest neighbour operations. Going back to our example, the overlap inner join will return all intensities that overlap a gene and propagate which gene_id a given intensity belongs to: olap &lt;- join_overlap_inner(intensities, gr) If we wanted to return all intensities regardless of overlap we could use the left join, and a missing value will be propagated to the gene_id column if there isn’t any overlap. join_overlap_left(intensities, gr) #&gt; GRanges object with 300 ranges and 4 metadata columns: #&gt; seqnames ranges strand | X Y #&gt; &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;numeric&gt; &lt;numeric&gt; #&gt; [1] VI 3300-3302 * | 2.26035109119553 1.06568454447289 #&gt; [2] VI 1045-1047 * | 2.21864775104592 1.08876098679654 #&gt; [3] VI 4206-4207 * | 3.08931723239393 2.4388720191285 #&gt; [4] VI 3791-3793 * | 2.64672161626967 1.49683387927811 #&gt; [5] VI 6503 * | 2.97614069143102 -0.842974371427135 #&gt; ... ... ... ... . ... ... #&gt; [296] VI 8881-8882 * | 4.15079125018189 4.47576275354234 #&gt; [297] VI 7333 * | -0.807795033496545 4.12171733927051 #&gt; [298] VI 715-716 * | -0.988759384492962 3.53496809806709 #&gt; [299] VI 426-428 * | 10.5245928564545 3.52355010049711 #&gt; [300] VI 9187-9188 * | 1.15204426681652 4.12867380190036 #&gt; replicate gene_id #&gt; &lt;character&gt; &lt;character&gt; #&gt; [1] 1 YFL065C #&gt; [2] 1 YFL067W #&gt; [3] 1 &lt;NA&gt; #&gt; [4] 1 YFL064C #&gt; [5] 1 YFL062W #&gt; ... ... ... #&gt; [296] 3 &lt;NA&gt; #&gt; [297] 3 YFL062W #&gt; [298] 3 &lt;NA&gt; #&gt; [299] 3 &lt;NA&gt; #&gt; [300] 3 &lt;NA&gt; #&gt; ------- #&gt; seqinfo: 2 sequences from an unspecified genome; no seqlengths If we are interested in finding how much overlap there is we could use an intersect join. For example we could compute the fraction of overlap of the genes with themselves: gr %&gt;% mutate(gene_length = width) %&gt;% join_overlap_intersect(gr, suffix = c(&quot;.query&quot;, &quot;.subject&quot;)) %&gt;% filter(gene_id.query != gene_id.subject) %&gt;% mutate(folap = width / gene_length) #&gt; GRanges object with 2 ranges and 4 metadata columns: #&gt; seqnames ranges strand | gene_id.query gene_length #&gt; &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;character&gt; &lt;integer&gt; #&gt; [1] VI 3322-3338 - | YFL064C 525 #&gt; [2] VI 3322-3338 - | YFL065C 309 #&gt; gene_id.subject folap #&gt; &lt;character&gt; &lt;numeric&gt; #&gt; [1] YFL065C 0.0323809523809524 #&gt; [2] YFL064C 0.0550161812297735 #&gt; ------- #&gt; seqinfo: 1 sequence from an unspecified genome; no seqlengths 8.8.3 Exercises There are of course many more functions available in plyranges but hopefully the previous examples are sufficient to give you an idea of how to incorporate plyranges into your genomic workflows. Here’s a few exercises to help you familiar with the verbs: Find the average intensity of the X and Y measurements for each each replicate over all positions in the intensities object Add a new column to the intensities object that is the distance from each position to its closest gene (hint IRanges::distance) Find flanking regions downstream of the genes in gr that have width of 8bp (hint: type: flank_ and see what comes up!) Are any of the intensities positions within the flanking region? (use an overlap join to find out!) 8.9 Data import and creating pipelines Here we provide some realistic examples of using plyranges to import genomic data and perform exploratory analyses. 8.9.1 Worked example: exploring BigWig files from AnnotationHub In the workflow of ChIP-seq data analysis, we are often interested in finding peaks from islands of coverage over a chromosome. Here we will use plyranges to explore ChiP-seq data from the Human Epigenome Roadmap project Roadmap Epigenomics Consortium et al. (2015). 8.9.1.1 Extracting data from AnnotationHub This data is available on Bioconductor’s AnnotationHub. First we construct an AnnotationHub, and then query() for all bigWigFiles related to the project that correspond to the following conditions: are from methylation marks (H3K4ME in the title) correspond to primary T CD8+ memory cells from peripheral blood correspond to unimputed log10 P-values First we construct a hub that contains all references to the EpigenomeRoadMap data and extract the metadata as a data.frame: library(AnnotationHub) library(magrittr) ah &lt;- AnnotationHub() #&gt; snapshotDate(): 2018-06-27 roadmap_hub &lt;- ah %&gt;% query(&quot;EpigenomeRoadMap&quot;) # extract2 is just a call to `[[` metadata &lt;- ah %&gt;% query(&quot;Metadata&quot;) %&gt;% extract2(names(.)) #&gt; downloading 0 resources #&gt; loading from cache #&gt; &#39;/home/mramos//.AnnotationHub/47270&#39; head(metadata) #&gt; EID GROUP COLOR MNEMONIC #&gt; 1 E001 ESC #924965 ESC.I3 #&gt; 2 E002 ESC #924965 ESC.WA7 #&gt; 3 E003 ESC #924965 ESC.H1 #&gt; 4 E004 ES-deriv #4178AE ESDR.H1.BMP4.MESO #&gt; 5 E005 ES-deriv #4178AE ESDR.H1.BMP4.TROP #&gt; 6 E006 ES-deriv #4178AE ESDR.H1.MSC #&gt; STD_NAME #&gt; 1 ES-I3 Cells #&gt; 2 ES-WA7 Cells #&gt; 3 H1 Cells #&gt; 4 H1 BMP4 Derived Mesendoderm Cultured Cells #&gt; 5 H1 BMP4 Derived Trophoblast Cultured Cells #&gt; 6 H1 Derived Mesenchymal Stem Cells #&gt; EDACC_NAME ANATOMY TYPE #&gt; 1 ES-I3_Cell_Line ESC PrimaryCulture #&gt; 2 ES-WA7_Cell_Line ESC PrimaryCulture #&gt; 3 H1_Cell_Line ESC PrimaryCulture #&gt; 4 H1_BMP4_Derived_Mesendoderm_Cultured_Cells ESC_DERIVED ESCDerived #&gt; 5 H1_BMP4_Derived_Trophoblast_Cultured_Cells ESC_DERIVED ESCDerived #&gt; 6 H1_Derived_Mesenchymal_Stem_Cells ESC_DERIVED ESCDerived #&gt; AGE SEX SOLID_LIQUID ETHNICITY SINGLEDONOR_COMPOSITE #&gt; 1 CL Female &lt;NA&gt; &lt;NA&gt; SD #&gt; 2 CL Female &lt;NA&gt; &lt;NA&gt; SD #&gt; 3 CL Male &lt;NA&gt; &lt;NA&gt; SD #&gt; 4 CL Male &lt;NA&gt; &lt;NA&gt; SD #&gt; 5 CL Male &lt;NA&gt; &lt;NA&gt; SD #&gt; 6 CL Male &lt;NA&gt; &lt;NA&gt; SD To find out the name of the sample corresponding to primary memory T-cells we can filter the data.frame. We extract the sample ID corresponding to our filter. primary_tcells &lt;- metadata %&gt;% filter(ANATOMY == &quot;BLOOD&quot;) %&gt;% filter(TYPE == &quot;PrimaryCell&quot;) %&gt;% filter(EDACC_NAME == &quot;CD8_Memory_Primary_Cells&quot;) %&gt;% extract2(&quot;EID&quot;) %&gt;% as.character() primary_tcells #&gt; [1] &quot;E048&quot; Now we can take our roadmap hub and query it based on our other conditions: methylation_files &lt;- roadmap_hub %&gt;% query(&quot;BigWig&quot;) %&gt;% query(primary_tcells) %&gt;% query(&quot;H3K4ME[1-3]&quot;) %&gt;% query(&quot;pval.signal&quot;) methylation_files #&gt; AnnotationHub with 5 records #&gt; # snapshotDate(): 2018-06-27 #&gt; # $dataprovider: BroadInstitute #&gt; # $species: Homo sapiens #&gt; # $rdataclass: BigWigFile #&gt; # additional mcols(): taxonomyid, genome, description, #&gt; # coordinate_1_based, maintainer, rdatadateadded, preparerclass, #&gt; # tags, rdatapath, sourceurl, sourcetype #&gt; # retrieve records with, e.g., &#39;object[[&quot;AH33454&quot;]]&#39; #&gt; #&gt; title #&gt; AH33454 | E048-H3K4me1.pval.signal.bigwig #&gt; AH33455 | E048-H3K4me3.pval.signal.bigwig #&gt; AH39974 | E048-H3K4me1.imputed.pval.signal.bigwig #&gt; AH40101 | E048-H3K4me2.imputed.pval.signal.bigwig #&gt; AH40228 | E048-H3K4me3.imputed.pval.signal.bigwig So we’ll take the first two entries and download them as BigWigFiles: bw_files &lt;- lapply(c(&quot;AH33454&quot;, &quot;AH33455&quot;), function(id) ah[[id]]) #&gt; downloading 0 resources #&gt; loading from cache #&gt; &#39;/home/mramos//.AnnotationHub/38894&#39; #&gt; downloading 0 resources #&gt; loading from cache #&gt; &#39;/home/mramos//.AnnotationHub/38895&#39; names(bw_files) &lt;- c(&quot;HK34ME1&quot;, &quot;HK34ME3&quot;) We have our desired BigWig files so now we can we can start analysing them. 8.9.1.2 Reading BigWig files For this analysis, we will call peaks from islands of scores over chromosome 10. First, we extract the genome information from the first BigWig file and filter to get the range for chromosome 10. This range will be used as a filter when reading the file. chr10_ranges &lt;- bw_files %&gt;% extract2(1L) %&gt;% get_genome_info() %&gt;% filter(seqnames == &quot;chr10&quot;) Then we read the BigWig file only extracting scores if they overlap chromosome 10. We also add the genome build information to the resulting ranges. This book-keeping is good practice as it ensures the integrity of any downstream operations such as finding overlaps. # a function to read our bigwig files read_chr10_scores &lt;- function(file) { read_bigwig(file, overlap_ranges = chr10_ranges) %&gt;% set_genome_info(genome = &quot;hg19&quot;) } # apply the function to each file chr10_scores &lt;- lapply(bw_files, read_chr10_scores) # bind the ranges to a single GRAnges object # and add a column to identify the ranges by signal type chr10_scores &lt;- bind_ranges(chr10_scores, .id = &quot;signal_type&quot;) chr10_scores #&gt; GRanges object with 11268683 ranges and 2 metadata columns: #&gt; seqnames ranges strand | score #&gt; &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;numeric&gt; #&gt; [1] chr10 1-60612 * | 0.0394200012087822 #&gt; [2] chr10 60613-60784 * | 0.154219999909401 #&gt; [3] chr10 60785-60832 * | 0.354730010032654 #&gt; [4] chr10 60833-61004 * | 0.154219999909401 #&gt; [5] chr10 61005-61455 * | 0.0394200012087822 #&gt; ... ... ... ... . ... #&gt; [11268679] chr10 135524731-135524739 * | 0.0704099982976913 #&gt; [11268680] chr10 135524740-135524780 * | 0.132530003786087 #&gt; [11268681] chr10 135524781-135524789 * | 0.245049998164177 #&gt; [11268682] chr10 135524790-135524811 * | 0.450120002031326 #&gt; [11268683] chr10 135524812-135524842 * | 0.619729995727539 #&gt; signal_type #&gt; &lt;character&gt; #&gt; [1] HK34ME1 #&gt; [2] HK34ME1 #&gt; [3] HK34ME1 #&gt; [4] HK34ME1 #&gt; [5] HK34ME1 #&gt; ... ... #&gt; [11268679] HK34ME3 #&gt; [11268680] HK34ME3 #&gt; [11268681] HK34ME3 #&gt; [11268682] HK34ME3 #&gt; [11268683] HK34ME3 #&gt; ------- #&gt; seqinfo: 25 sequences from hg19 genome Since we want to call peaks over each signal type, we will create a grouped GRanges object: chr10_scores_by_signal &lt;- chr10_scores %&gt;% group_by(signal_type) We can then filter to find the coordinates of the peak containing the maximum score for each signal. We can then find a 5000 nt region centred around the maximum position by anchoring and modifying the width. chr10_max_score_region &lt;- chr10_scores_by_signal %&gt;% filter(score == max(score)) %&gt;% ungroup() %&gt;% anchor_center() %&gt;% mutate(width = 5000) Finally, the overlap inner join is used to restrict the chromosome 10 coverage islands, to the islands that are contained in the 5000nt region that surrounds the max peak for each signal type. peak_region &lt;- chr10_scores %&gt;% join_overlap_inner(chr10_max_score_region) %&gt;% filter(signal_type.x == signal_type.y) # the filter ensures overlapping correct methlyation signal 8.9.1.3 Exercises Use the reduce_ranges() function to find all peaks for each signal type. How could you annotate the scores to find out which genes overlap each peak found in 1.? Plot a 1000nt window centred around the maximum scores for each signal type using the ggbio or Gviz package. 8.9.2 Worked example: coverage analysis of BAM files A common quality control check in a genomics workflow is to perform coverage analysis over features of interest or over the entire genome (again we see the bioinformatician’s love of counting things). Here we use the airway package to compute coverage histograms and show how you can read BAM files into memory as GRanges objects with plyranges. First let’s gather all the BAM files available to use in airway (see browseVignettes(&quot;airway&quot;) for more information about the data and how it was prepared): bfs &lt;- system.file(&quot;extdata&quot;, package = &quot;airway&quot;) %&gt;% dir(pattern = &quot;.bam&quot;, full.names = TRUE) # get sample names (everything after the underscore) names(bfs) &lt;- bfs %&gt;% basename() %&gt;% sub(&quot;_[^_]+$&quot;, &quot;&quot;, .) To start let’s look at a single BAM file, we can compute the coverage of the alignments over all contigs in the BAM as follows: first_bam_cvg &lt;- bfs %&gt;% extract2(1) %&gt;% compute_coverage() first_bam_cvg #&gt; GRanges object with 11423 ranges and 1 metadata column: #&gt; seqnames ranges strand | score #&gt; &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;integer&gt; #&gt; [1] 1 1-11053772 * | 0 #&gt; [2] 1 11053773-11053835 * | 1 #&gt; [3] 1 11053836-11053839 * | 0 #&gt; [4] 1 11053840-11053902 * | 1 #&gt; [5] 1 11053903-11067865 * | 0 #&gt; ... ... ... ... . ... #&gt; [11419] GL000210.1 1-27682 * | 0 #&gt; [11420] GL000231.1 1-27386 * | 0 #&gt; [11421] GL000229.1 1-19913 * | 0 #&gt; [11422] GL000226.1 1-15008 * | 0 #&gt; [11423] GL000207.1 1-4262 * | 0 #&gt; ------- #&gt; seqinfo: 84 sequences from an unspecified genome Here the coverage is computed without the entire BAM file being read into memory. Notice that the score here is the count of the number of alignments that coverage a range. To compute a coverage histogram, that is the number of number of bases that have a given coverage score for each contig we can simply use summarise(): first_bam_cvg %&gt;% group_by(seqnames, score) %&gt;% summarise(n_bases_covered = sum(width)) #&gt; DataFrame with 277 rows and 3 columns #&gt; seqnames score n_bases_covered #&gt; &lt;Rle&gt; &lt;integer&gt; &lt;integer&gt; #&gt; 1 1 0 249202844 #&gt; 2 10 0 135534747 #&gt; 3 11 0 135006516 #&gt; 4 12 0 133851895 #&gt; 5 13 0 115169878 #&gt; ... ... ... ... #&gt; 273 1 189 3 #&gt; 274 1 191 3 #&gt; 275 1 192 3 #&gt; 276 1 193 2 #&gt; 277 1 194 1 For RNA-seq experiments we are often interested in splitting up alignments based on whether the alignment has skipped a region from the reference ( that is, there is an “N” in the cigar string, indicating an intron). In plyranges this can be achieved with the chop_by_introns(), that will split up an alignment if there’s an intron. This results in a grouped ranges object. To begin we can read the BAM file using read_bam(), this does not read the entire BAM into memory but instead waits for further functions to be applied to it. # no index present in directory so we use index = NULL split_bam &lt;- bfs %&gt;% extract2(1) %&gt;% read_bam(index = NULL) # nothing has been read split_bam #&gt; DeferredGenomicRanges object with 0 ranges and 0 metadata columns: #&gt; seqnames ranges strand #&gt; &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; #&gt; ------- #&gt; seqinfo: no sequences For example we can select elements from the BAM file to be included in the resulting GRanges to load alignments into memory: split_bam %&gt;% select(flag) #&gt; DeferredGenomicRanges object with 14282 ranges and 4 metadata columns: #&gt; seqnames ranges strand | flag cigar #&gt; &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;integer&gt; &lt;character&gt; #&gt; [1] 1 11053773-11053835 + | 99 63M #&gt; [2] 1 11053840-11053902 - | 147 63M #&gt; [3] 1 11067866-11067928 + | 163 63M #&gt; [4] 1 11067931-11067993 - | 83 63M #&gt; [5] 1 11072708-11072770 + | 99 63M #&gt; ... ... ... ... . ... ... #&gt; [14278] 1 11364733-11364795 - | 147 63M #&gt; [14279] 1 11365866-11365928 + | 163 63M #&gt; [14280] 1 11365987-11366049 - | 83 63M #&gt; [14281] 1 11386063-11386123 + | 99 2S61M #&gt; [14282] 1 11386132-11386194 - | 147 63M #&gt; qwidth njunc #&gt; &lt;integer&gt; &lt;integer&gt; #&gt; [1] 63 0 #&gt; [2] 63 0 #&gt; [3] 63 0 #&gt; [4] 63 0 #&gt; [5] 63 0 #&gt; ... ... ... #&gt; [14278] 63 0 #&gt; [14279] 63 0 #&gt; [14280] 63 0 #&gt; [14281] 63 0 #&gt; [14282] 63 0 #&gt; ------- #&gt; seqinfo: 84 sequences from an unspecified genome Finally, we can split our alignments using the chop_by_introns(): split_bam &lt;- split_bam %&gt;% chop_by_introns() split_bam #&gt; GRanges object with 18124 ranges and 4 metadata columns: #&gt; Groups: introns [14282] #&gt; seqnames ranges strand | cigar qwidth #&gt; &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;character&gt; &lt;integer&gt; #&gt; [1] 1 11053773-11053835 + | 63M 63 #&gt; [2] 1 11053840-11053902 - | 63M 63 #&gt; [3] 1 11067866-11067928 + | 63M 63 #&gt; [4] 1 11067931-11067993 - | 63M 63 #&gt; [5] 1 11072708-11072770 + | 63M 63 #&gt; ... ... ... ... . ... ... #&gt; [18120] 1 11364733-11364795 - | 63M 63 #&gt; [18121] 1 11365866-11365928 + | 63M 63 #&gt; [18122] 1 11365987-11366049 - | 63M 63 #&gt; [18123] 1 11386063-11386123 + | 2S61M 63 #&gt; [18124] 1 11386132-11386194 - | 63M 63 #&gt; njunc introns #&gt; &lt;integer&gt; &lt;integer&gt; #&gt; [1] 0 1 #&gt; [2] 0 2 #&gt; [3] 0 3 #&gt; [4] 0 4 #&gt; [5] 0 5 #&gt; ... ... ... #&gt; [18120] 0 14278 #&gt; [18121] 0 14279 #&gt; [18122] 0 14280 #&gt; [18123] 0 14281 #&gt; [18124] 0 14282 #&gt; ------- #&gt; seqinfo: 84 sequences from an unspecified genome # look at the junction reads split_bam %&gt;% filter(n() &gt; 2) #&gt; GRanges object with 27 ranges and 4 metadata columns: #&gt; Groups: introns [9] #&gt; seqnames ranges strand | cigar qwidth #&gt; &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;character&gt; &lt;integer&gt; #&gt; [1] 1 11137495-11137500 - | 6M157N51M2059N6M 63 #&gt; [2] 1 11137658-11137708 - | 6M157N51M2059N6M 63 #&gt; [3] 1 11139768-11139773 - | 6M157N51M2059N6M 63 #&gt; [4] 1 11137496-11137500 + | 5M157N51M2059N7M 63 #&gt; [5] 1 11137658-11137708 + | 5M157N51M2059N7M 63 #&gt; ... ... ... ... . ... ... #&gt; [23] 1 11140556-11140606 + | 5M676N51M214N7M 63 #&gt; [24] 1 11140821-11140827 + | 5M676N51M214N7M 63 #&gt; [25] 1 11139876-11139879 + | 4M676N51M214N8M 63 #&gt; [26] 1 11140556-11140606 + | 4M676N51M214N8M 63 #&gt; [27] 1 11140821-11140828 + | 4M676N51M214N8M 63 #&gt; njunc introns #&gt; &lt;integer&gt; &lt;integer&gt; #&gt; [1] 2 8850 #&gt; [2] 2 8850 #&gt; [3] 2 8850 #&gt; [4] 2 8851 #&gt; [5] 2 8851 #&gt; ... ... ... #&gt; [23] 2 9058 #&gt; [24] 2 9058 #&gt; [25] 2 9059 #&gt; [26] 2 9059 #&gt; [27] 2 9059 #&gt; ------- #&gt; seqinfo: 84 sequences from an unspecified genome 8.9.2.1 Exercises Compute the total depth of coverage across all features. How could you compute the proportion of bases covered over an entire genome? (hint: get_genome_info and S4Vectors::merge) How could you compute the strand specific genome wide coverage? Create a workflow for computing the strand specific coverage for all BAM files. For each sample plot total breadth of coverage against the number of bases covered faceted by each sample name. 8.10 What’s next? The grammar based approach for analysing data provides a consistent approach for analysing genomics experiments with Bioconductor. We have explored how plyranges can enable you to perform common analysis tasks required of a bioinformatician. As plyranges is still a new and growing package, there is definite room for improvement (and likely bugs), if you have any problems using it or think things could be easier or clearer please file an issue on github. Contributions from the Bioconductor community are also more than welcome! 8.11 Appendix Overview of the plyranges grammar. The core verbs are briefly described and categorised into one of: aggregation, unary or binary arithmetic, merging, modifier, or restriction. A verb is given bold text if its origin is from the dplyr grammar. Category Verb Description summarise() aggregate over column(s) Aggregation disjoin_ranges() aggregate column(s) over the union of end coordinates reduce_ranges() aggregate column(s) by merging overlapping and neighbouring ranges mutate() modifies any column select() select columns Arithmetic (Unary) arrange() sort by columns stretch() extend range by fixed amount shift_(direction) shift coordinates flank_(direction) generate flanking regions %intersection% row-wise intersection %union% row-wise union compute_coverage coverage over all ranges Arithmetic (Binary) %setdiff% row-wise set difference between() row-wise gap range span() row-wise spanning range join_overlap_() merge by overlapping ranges join_nearest merge by nearest neighbour ranges join_follow merge by following ranges Merging join_precedes merge by preceding ranges union_ranges range-wise union intersect_ranges range-wise intersect setdiff_ranges range-wise set difference complement_ranges range-wise union anchor_direction() fix coordinates at direction Modifier group_by() partition by column(s) group_by_overlaps() partition by overlaps filter() subset rows Restriction filter_by_overlaps() subset by overlap filter_by_non_overlaps() subset by no overlap "],
["introduction-to-bioconductor-annotation-resources.html", "9 Introduction to Bioconductor annotation resources 9.1 Instructors 9.2 Workshop Description 9.3 Workshop goals and objectives 9.4 Annotation Workshop", " 9 Introduction to Bioconductor annotation resources 9.1 Instructors James W. MacDonald (jmacdon@uw.edu) Lori Shepherd (lori.shepherd@roswellpark.org) 9.2 Workshop Description There are various annotation packages provided by the Bioconductor project that can be used to incorporate additional information to results from high-throughput experiments. This can be as simple as mapping Ensembl IDs to corresponding HUGO gene symbols, to much more complex queries involving multiple data sources. In this workshop we will cover the various classes of annotation packages, what they contain, and how to use them efficiently. 9.2.1 Prerequisites Basic knowledge of R syntax Basic understanding of the various annotation sources (NCBI, EBI/EMBL) Useful background reading The AnnotationDbi vignette. The biomaRt vignette. The GenomicFeatures vignette. 9.2.2 Workshop Participation After each type of annotation package is introduced, students will be given the opportunity to practice making their own queries. 9.2.3 R / Bioconductor packages used AnnotationDbi AnnotationHub BSgenome biomaRt ensembldb org.Hs.eg.db TxDb.Hsapiens.UCSC.hg19.knownGene EnsDb.Hsapiens.v79 EnsDb.Mmusculus.v79 Homo.sapiens BSgenome.Hsapiens.UCSC.hg19 hugene20sttranscriptcluster.db 9.3 Workshop goals and objectives Annotating data is a complex task. For any high-throughput experiment the analyst usually starts with a set of identifiers for each thing that was measured, and in order to make the results useful to collaborators these identifiers need to be mapped to other identifiers that are either more familiar to collaborators, or that can be used for further analyses. As an example, RNA-Seq data may only have Entrez Gene IDs for each gene measured, and as part of the output you may want to include the gene symbols, which are more likely to be familiar to a Biologist. 9.3.1 Learning goals Understand what sort of annotation data are available Understand the difference between annotation sources (NCBI and EBI/EMBL) Gain familiarity with the various ways to query annotation packages Get some practice making queries 9.3.2 Learning objectives Be able to use select and mapIds to map between identifiers Be able to extract data from TxDb and EnsDb packages Be able to make queries using biomaRt Extract and utilize various data from AnnotationHub 9.4 Annotation Workshop 9.4.1 Goals for this workshop Learn about various annotation package types Learn the basics of querying these resources Discuss annotations in regard to Bioc data structures Get in some practice 9.4.2 What do we mean by annotation? Map a known ID to other functional or positional information 9.4.3 Specific goal We have data and statistics, and we want to add other useful information The end result might be as simple as a data.frame or HTML table, or as complex as a RangedSummarizedExperiment 9.4.4 Data containers 9.4.5 ExpressionSet load(system.file(&quot;extdata/eset.Rdata&quot;, package = &quot;Bioc2018Anno&quot;)) eset #&gt; ExpressionSet (storageMode: lockedEnvironment) #&gt; assayData: 33552 features, 6 samples #&gt; element names: exprs #&gt; protocolData: none #&gt; phenoData #&gt; sampleNames: GSM2194079 GSM2194080 ... GSM2194084 (6 total) #&gt; varLabels: title characteristics_ch1.1 #&gt; varMetadata: labelDescription #&gt; featureData #&gt; featureNames: 16657436 16657440 ... 17118478 (33552 total) #&gt; fvarLabels: PROBEID ENTREZID SYMBOL GENENAME #&gt; fvarMetadata: labelDescription #&gt; experimentData: use &#39;experimentData(object)&#39; #&gt; Annotation: pd.hugene.2.0.st 9.4.6 ExpressionSet (continued) head(exprs(eset)) #&gt; GSM2194079 GSM2194080 GSM2194081 GSM2194082 GSM2194083 GSM2194084 #&gt; 16657436 8.505158 9.046577 8.382674 9.115481 8.715343 8.566301 #&gt; 16657440 7.948860 8.191222 7.901911 8.459781 8.191793 8.219658 #&gt; 16657450 10.932934 11.228553 10.948120 11.462231 11.300046 11.300886 #&gt; 16657469 9.172462 9.344630 9.193450 9.465584 9.464020 9.135715 #&gt; 16657473 6.222049 6.551035 6.000246 6.398798 5.892654 5.592125 #&gt; 16657476 8.514300 8.474073 8.407196 8.811238 8.780833 8.874606 head(pData(phenoData(eset))) #&gt; title characteristics_ch1.1 #&gt; GSM2194079 SW620-miR625-rep1 shRNA: miR-625-3p #&gt; GSM2194080 SW620-miR625-rep2 shRNA: miR-625-3p #&gt; GSM2194081 SW620-miR625-rep3 shRNA: miR-625-3p #&gt; GSM2194082 SW620-scramble-rep1 shRNA: scramble #&gt; GSM2194083 SW620-scramble-rep2 shRNA: scramble #&gt; GSM2194084 SW620-scramble-rep3 shRNA: scramble 9.4.7 ExpressionSet (continued) head(pData(featureData(eset))) #&gt; PROBEID ENTREZID SYMBOL #&gt; 16657436 16657436 84771 DDX11L2 #&gt; 16657440 16657440 100302278 MIR1302-2 #&gt; 16657450 16657450 402483 LINC01000 #&gt; 16657469 16657469 140849 LINC00266-1 #&gt; 16657473 16657473 729759 OR4F29 #&gt; 16657476 16657476 388574 RPL23AP87 #&gt; GENENAME #&gt; 16657436 DEAD/H-box helicase 11 like 2 #&gt; 16657440 microRNA 1302-2 #&gt; 16657450 long intergenic non-protein coding RNA 1000 #&gt; 16657469 long intergenic non-protein coding RNA 266-1 #&gt; 16657473 olfactory receptor family 4 subfamily F member 29 #&gt; 16657476 ribosomal protein L23a pseudogene 87 9.4.8 BioC containers vs basic structures 9.4.8.1 Pros Validity checking Subsetting Function dispatch Automatic behaviors 9.4.8.2 Cons Difficult to create Cumbersome to extract data by hand Useful only within R 9.4.9 Annotation sources Package type Example ChipDb hugene20sttranscriptcluster.db OrgDb org.Hs.eg.db TxDb/EnsDb TxDb.Hsapiens.UCSC.hg19.knownGene; EnsDb.Hsapiens.v75 OrganismDb Homo.sapiens BSgenome BSgenome.Hsapiens.UCSC.hg19 Others GO.db; KEGG.db AnnotationHub Online resource biomaRt Online resource 9.4.10 Interacting with AnnoDb packages The main function is select: select(annopkg, keys, columns, keytype) Where annopkg is the annotation package keys are the IDs that we know columns are the values we want keytype is the type of key used if the keytype is the central key, it can remain unspecified 9.4.11 Simple example Say we have analyzed data from an Affymetrix Human Gene ST 2.0 array and want to know what the genes are. For purposes of this lab, we just select some IDs at random. library(hugene20sttranscriptcluster.db) set.seed(12345) ids &lt;- featureNames(eset)[sample(1:25000, 5)] ids #&gt; [1] &quot;16908472&quot; &quot;16962185&quot; &quot;16920686&quot; &quot;16965513&quot; &quot;16819952&quot; select(hugene20sttranscriptcluster.db, ids, &quot;SYMBOL&quot;) #&gt; &#39;select()&#39; returned 1:1 mapping between keys and columns #&gt; PROBEID SYMBOL #&gt; 1 16908472 LINC01494 #&gt; 2 16962185 ALG3 #&gt; 3 16920686 &lt;NA&gt; #&gt; 4 16965513 &lt;NA&gt; #&gt; 5 16819952 CBFB 9.4.12 Questions! How do you know what the central keys are? If it’s a ChipDb, the central key are the manufacturer’s probe IDs It’s sometimes in the name - org.Hs.eg.db, where ‘eg’ means Entrez Gene ID You can see examples using e.g., head(keys(annopkg)), and infer from that But note that it’s never necessary to know the central key, as long as you specify the keytype 9.4.13 More questions! What keytypes or columns are available for a given annotation package? keytypes(hugene20sttranscriptcluster.db) #&gt; [1] &quot;ACCNUM&quot; &quot;ALIAS&quot; &quot;ENSEMBL&quot; &quot;ENSEMBLPROT&quot; #&gt; [5] &quot;ENSEMBLTRANS&quot; &quot;ENTREZID&quot; &quot;ENZYME&quot; &quot;EVIDENCE&quot; #&gt; [9] &quot;EVIDENCEALL&quot; &quot;GENENAME&quot; &quot;GO&quot; &quot;GOALL&quot; #&gt; [13] &quot;IPI&quot; &quot;MAP&quot; &quot;OMIM&quot; &quot;ONTOLOGY&quot; #&gt; [17] &quot;ONTOLOGYALL&quot; &quot;PATH&quot; &quot;PFAM&quot; &quot;PMID&quot; #&gt; [21] &quot;PROBEID&quot; &quot;PROSITE&quot; &quot;REFSEQ&quot; &quot;SYMBOL&quot; #&gt; [25] &quot;UCSCKG&quot; &quot;UNIGENE&quot; &quot;UNIPROT&quot; columns(hugene20sttranscriptcluster.db) #&gt; [1] &quot;ACCNUM&quot; &quot;ALIAS&quot; &quot;ENSEMBL&quot; &quot;ENSEMBLPROT&quot; #&gt; [5] &quot;ENSEMBLTRANS&quot; &quot;ENTREZID&quot; &quot;ENZYME&quot; &quot;EVIDENCE&quot; #&gt; [9] &quot;EVIDENCEALL&quot; &quot;GENENAME&quot; &quot;GO&quot; &quot;GOALL&quot; #&gt; [13] &quot;IPI&quot; &quot;MAP&quot; &quot;OMIM&quot; &quot;ONTOLOGY&quot; #&gt; [17] &quot;ONTOLOGYALL&quot; &quot;PATH&quot; &quot;PFAM&quot; &quot;PMID&quot; #&gt; [21] &quot;PROBEID&quot; &quot;PROSITE&quot; &quot;REFSEQ&quot; &quot;SYMBOL&quot; #&gt; [25] &quot;UCSCKG&quot; &quot;UNIGENE&quot; &quot;UNIPROT&quot; 9.4.14 Another example There is one issue with select however. ids &lt;- c(&#39;16737401&#39;,&#39;16657436&#39; ,&#39;16678303&#39;) select(hugene20sttranscriptcluster.db, ids, c(&quot;SYMBOL&quot;,&quot;MAP&quot;)) #&gt; &#39;select()&#39; returned 1:many mapping between keys and columns #&gt; PROBEID SYMBOL MAP #&gt; 1 16737401 TRAF6 11p12 #&gt; 2 16657436 DDX11L1 1p36.33 #&gt; 3 16657436 LOC102725121 1p36.33 #&gt; 4 16657436 DDX11L2 2q14.1 #&gt; 5 16657436 DDX11L9 15q26.3 #&gt; 6 16657436 DDX11L10 16p13.3 #&gt; 7 16657436 DDX11L5 9p24.3 #&gt; 8 16657436 DDX11L16 Xq28 #&gt; 9 16657436 DDX11L16 Yq12 #&gt; 10 16678303 ARF1 1q42.13 9.4.15 The mapIds function An alternative to select is mapIds, which gives control of duplicates Same arguments as select with slight differences The columns argument can only specify one column The keytype argument must be specified An additional argument, multiVals used to control duplicates mapIds(hugene20sttranscriptcluster.db, ids, &quot;SYMBOL&quot;, &quot;PROBEID&quot;) #&gt; &#39;select()&#39; returned 1:many mapping between keys and columns #&gt; 16737401 16657436 16678303 #&gt; &quot;TRAF6&quot; &quot;DDX11L1&quot; &quot;ARF1&quot; 9.4.16 Choices for multiVals Default is first, where we just choose the first of the duplicates. Other choices are list, CharacterList, filter, asNA or a user-specified function. mapIds(hugene20sttranscriptcluster.db, ids, &quot;SYMBOL&quot;, &quot;PROBEID&quot;, multiVals = &quot;list&quot;) #&gt; &#39;select()&#39; returned 1:many mapping between keys and columns #&gt; $`16737401` #&gt; [1] &quot;TRAF6&quot; #&gt; #&gt; $`16657436` #&gt; [1] &quot;DDX11L1&quot; &quot;LOC102725121&quot; &quot;DDX11L2&quot; &quot;DDX11L9&quot; #&gt; [5] &quot;DDX11L10&quot; &quot;DDX11L5&quot; &quot;DDX11L16&quot; #&gt; #&gt; $`16678303` #&gt; [1] &quot;ARF1&quot; 9.4.17 Choices for multiVals (continued) mapIds(hugene20sttranscriptcluster.db, ids, &quot;SYMBOL&quot;, &quot;PROBEID&quot;, multiVals = &quot;CharacterList&quot;) #&gt; &#39;select()&#39; returned 1:many mapping between keys and columns #&gt; CharacterList of length 3 #&gt; [[&quot;16737401&quot;]] TRAF6 #&gt; [[&quot;16657436&quot;]] DDX11L1 LOC102725121 DDX11L2 DDX11L9 DDX11L10 DDX11L5 DDX11L16 #&gt; [[&quot;16678303&quot;]] ARF1 mapIds(hugene20sttranscriptcluster.db, ids, &quot;SYMBOL&quot;, &quot;PROBEID&quot;, multiVals = &quot;filter&quot;) #&gt; &#39;select()&#39; returned 1:many mapping between keys and columns #&gt; 16737401 16678303 #&gt; &quot;TRAF6&quot; &quot;ARF1&quot; mapIds(hugene20sttranscriptcluster.db, ids, &quot;SYMBOL&quot;, &quot;PROBEID&quot;, multiVals = &quot;asNA&quot;) #&gt; &#39;select()&#39; returned 1:many mapping between keys and columns #&gt; 16737401 16657436 16678303 #&gt; &quot;TRAF6&quot; NA &quot;ARF1&quot; 9.4.18 ChipDb/OrgDb questions Using either the hugene20sttranscriptcluster.db or org.Hs.eg.db package, What gene symbol corresponds to Entrez Gene ID 1000? What is the Ensembl Gene ID for PPARG? What is the UniProt ID for GAPDH? How many of the probesets from the ExpressionSet (eset) we loaded map to a single gene? How many don’t map to a gene at all? 9.4.19 TxDb packages TxDb packages contain positional information; the contents can be inferred by the package name TxDb.Species.Source.Build.Table TxDb.Hsapiens.UCSC.hg19.knownGene Homo sapiens UCSC genome browser hg19 (their version of GRCh37) knownGene table TxDb.Dmelanogaster.UCSC.dm3.ensGene TxDb.Athaliana.BioMart.plantsmart22 9.4.20 EnsDb packages EnsDb packages are similar to TxDb packages, but based on Ensembl mappings EnsDb.Hsapiens.v79 EnsDb.Mmusculus.v79 EnsDb.Rnorvegicus.v79 9.4.21 Transcript packages As with ChipDb and OrgDb packages, select and mapIds can be used to make queries select(TxDb.Hsapiens.UCSC.hg19.knownGene, c(&quot;1&quot;,&quot;10&quot;), c(&quot;TXNAME&quot;,&quot;TXCHROM&quot;,&quot;TXSTART&quot;,&quot;TXEND&quot;), &quot;GENEID&quot;) #&gt; &#39;select()&#39; returned 1:many mapping between keys and columns #&gt; GENEID TXNAME TXCHROM TXSTART TXEND #&gt; 1 1 uc002qsd.4 chr19 58858172 58864865 #&gt; 2 1 uc002qsf.2 chr19 58859832 58874214 #&gt; 3 10 uc003wyw.1 chr8 18248755 18258723 select(EnsDb.Hsapiens.v79, c(&quot;1&quot;, &quot;10&quot;), c(&quot;GENEID&quot;,&quot;GENENAME&quot;,&quot;SEQNAME&quot;,&quot;GENESEQSTART&quot;,&quot;GENESEQEND&quot;), &quot;ENTREZID&quot;) #&gt; ENTREZID GENEID GENENAME SEQNAME GENESEQSTART GENESEQEND #&gt; 1 1 ENSG00000121410 A1BG 19 58345178 58353499 #&gt; 2 10 ENSG00000156006 NAT2 8 18391245 18401218 But this is not how one normally uses them… 9.4.22 GRanges The normal use case for transcript packages is to extract positional information into a GRanges or GRangesList object. An example is the genomic position of all genes: gns &lt;- genes(TxDb.Hsapiens.UCSC.hg19.knownGene) gns #&gt; GRanges object with 23056 ranges and 1 metadata column: #&gt; seqnames ranges strand | gene_id #&gt; &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;character&gt; #&gt; 1 chr19 58858172-58874214 - | 1 #&gt; 10 chr8 18248755-18258723 + | 10 #&gt; 100 chr20 43248163-43280376 - | 100 #&gt; 1000 chr18 25530930-25757445 - | 1000 #&gt; 10000 chr1 243651535-244006886 - | 10000 #&gt; ... ... ... ... . ... #&gt; 9991 chr9 114979995-115095944 - | 9991 #&gt; 9992 chr21 35736323-35743440 + | 9992 #&gt; 9993 chr22 19023795-19109967 - | 9993 #&gt; 9994 chr6 90539619-90584155 + | 9994 #&gt; 9997 chr22 50961997-50964905 - | 9997 #&gt; ------- #&gt; seqinfo: 93 sequences (1 circular) from hg19 genome 9.4.23 GRangesList Or the genomic position of all transcripts by gene: txs &lt;- transcriptsBy(TxDb.Hsapiens.UCSC.hg19.knownGene) txs #&gt; GRangesList object of length 23459: #&gt; $1 #&gt; GRanges object with 2 ranges and 2 metadata columns: #&gt; seqnames ranges strand | tx_id tx_name #&gt; &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;integer&gt; &lt;character&gt; #&gt; [1] chr19 58858172-58864865 - | 70455 uc002qsd.4 #&gt; [2] chr19 58859832-58874214 - | 70456 uc002qsf.2 #&gt; #&gt; $10 #&gt; GRanges object with 1 range and 2 metadata columns: #&gt; seqnames ranges strand | tx_id tx_name #&gt; [1] chr8 18248755-18258723 + | 31944 uc003wyw.1 #&gt; #&gt; $100 #&gt; GRanges object with 1 range and 2 metadata columns: #&gt; seqnames ranges strand | tx_id tx_name #&gt; [1] chr20 43248163-43280376 - | 72132 uc002xmj.3 #&gt; #&gt; ... #&gt; &lt;23456 more elements&gt; #&gt; ------- #&gt; seqinfo: 93 sequences (1 circular) from hg19 genome 9.4.24 Other accessors Positional information can be extracted for transcripts, genes, coding sequences (cds), promoters and exons. Positional information can be extracted for most of the above, grouped by a second element. For example, our transcriptsBy call was all transcripts, grouped by gene. More detail on these *Ranges objects is beyond the scope of this workshop, but why we want them is not. 9.4.25 Why *Ranges objects The main rationale for *Ranges objects is to allow us to easily select and subset data based on genomic position information. This is really powerful! GRanges and GRangesLists act like data.frames and lists, and can be subsetted using the [ function. As a really artificial example: txs[txs %over% gns[1:2,]] #&gt; GRangesList object of length 3: #&gt; $1 #&gt; GRanges object with 2 ranges and 2 metadata columns: #&gt; seqnames ranges strand | tx_id tx_name #&gt; &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;integer&gt; &lt;character&gt; #&gt; [1] chr19 58858172-58864865 - | 70455 uc002qsd.4 #&gt; [2] chr19 58859832-58874214 - | 70456 uc002qsf.2 #&gt; #&gt; $10 #&gt; GRanges object with 1 range and 2 metadata columns: #&gt; seqnames ranges strand | tx_id tx_name #&gt; [1] chr8 18248755-18258723 + | 31944 uc003wyw.1 #&gt; #&gt; $162968 #&gt; GRanges object with 2 ranges and 2 metadata columns: #&gt; seqnames ranges strand | tx_id tx_name #&gt; [1] chr19 58865723-58874214 - | 70457 uc002qsh.2 #&gt; [2] chr19 58865723-58874214 - | 70458 uc002qsi.2 #&gt; #&gt; ------- #&gt; seqinfo: 93 sequences (1 circular) from hg19 genome 9.4.26 *Ranges use cases Gene expression changes near differentially methylated CpG islands Closest genes to a set of interesting SNPs Genes near DNAseI hypersensitivity clusters Number of CpGs measured over Gene X by Chip Y 9.4.27 SummarizedExperiment objects SummarizedExperiment objects are like ExpressionSets, but the row-wise annotations are GRanges, so you can subset by genomic locations: SummarizedExperiment objects are popular objects for representing expression data and other rectangular data (feature x sample data). Incoming packages are now strongly recommended to use this class representation instead of ExpressionSet. 9.4.28 TxDb exercises How many transcripts does PPARG have, according to UCSC? Does Ensembl agree? How many genes are between 2858473 and 3271812 on chr2 in the hg19 genome? Hint: you make a GRanges like this - GRanges(&quot;chr2&quot;, IRanges(2858473,3271812)) 9.4.29 OrganismDb packages OrganismDb packages are meta-packages that contain an OrgDb, a TxDb, and a GO.db package and allow cross-queries between those packages. All previous accessors work; select, mapIds, transcripts, etc. library(Homo.sapiens) Homo.sapiens #&gt; OrganismDb Object: #&gt; # Includes GODb Object: GO.db #&gt; # With data about: Gene Ontology #&gt; # Includes OrgDb Object: org.Hs.eg.db #&gt; # Gene data about: Homo sapiens #&gt; # Taxonomy Id: 9606 #&gt; # Includes TxDb Object: TxDb.Hsapiens.UCSC.hg19.knownGene #&gt; # Transcriptome data about: Homo sapiens #&gt; # Based on genome: hg19 #&gt; # The OrgDb gene id ENTREZID is mapped to the TxDb gene id GENEID . 9.4.30 OrganismDb packages Updateable - can change TxDb object columns and keytypes span all underlying objects Calls to TxDb accessors include a ‘columns’ argument head(genes(Homo.sapiens, columns = c(&quot;ENTREZID&quot;,&quot;ALIAS&quot;,&quot;UNIPROT&quot;)),4) #&gt; &#39;select()&#39; returned 1:many mapping between keys and columns #&gt; GRanges object with 4 ranges and 3 metadata columns: #&gt; seqnames ranges strand | ALIAS #&gt; &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;CharacterList&gt; #&gt; 1 chr19 58858172-58874214 - | A1B,ABG,GAB,... #&gt; 10 chr8 18248755-18258723 + | AAC2,NAT-2,PNAT,... #&gt; 100 chr20 43248163-43280376 - | ADA #&gt; 1000 chr18 25530930-25757445 - | CD325,CDHN,CDw325,... #&gt; UNIPROT ENTREZID #&gt; &lt;CharacterList&gt; &lt;FactorList&gt; #&gt; 1 P04217,V9HWD8 1 #&gt; 10 A4Z6T7,P11245 10 #&gt; 100 A0A0S2Z381,P00813,F5GWI4 100 #&gt; 1000 P19022,A0A024RC42 1000 #&gt; ------- #&gt; seqinfo: 93 sequences (1 circular) from hg19 genome 9.4.31 OrganismDb exercises Get all the GO terms for BRCA1 What gene does the UCSC transcript ID uc002fai.3 map to? How many other transcripts does that gene have? Get all the transcripts from the hg19 genome build, along with their Ensembl gene ID, UCSC transcript ID and gene symbol 9.4.32 Organism.dplyr package Combines the data from TxDb and Org.Db associated packages into local database. Allows functions from both org.* and TxDb.* keytypes(), select(), … exons(), promoters(), … Allows for filtering and display of combined TxDb and Org.Db information through dplyr functions. library(Organism.dplyr) # src = src_organism(&quot;TxDb.Hsapiens.UCSC.hg19.knownGene&quot;) src &lt;- src_organism(dbpath = hg38light()) src #&gt; src: sqlite 3.22.0 [/usr/local/lib/R/site-library/Organism.dplyr/extdata/light.hg38.knownGene.sqlite] #&gt; tbls: id, id_accession, id_go, id_go_all, id_omim_pm, id_protein, #&gt; id_transcript, ranges_cds, ranges_exon, ranges_gene, ranges_tx 9.4.33 Organism.dply example # TxTb function promoters(src) #&gt; &lt;SQL&gt; #&gt; SELECT * #&gt; FROM `ranges_tx` #&gt; GRanges object with 88 ranges and 2 metadata columns: #&gt; seqnames ranges strand | tx_id #&gt; &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;integer&gt; #&gt; uc001hzz.2 chr1 243843037-243845236 - | 15880 #&gt; uc021plu.1 chr1 243843385-243845584 - | 15881 #&gt; uc001iab.3 chr1 243843083-243845282 - | 15882 #&gt; uc057qvr.1 chr1 243849929-243852128 - | 15883 #&gt; uc057qvt.1 chr1 243614947-243617146 - | 15884 #&gt; ... ... ... ... . ... #&gt; uc064xqh.1 chrUn_GL000220v1 110025-112224 + | 197741 #&gt; uc064xqi.1 chrUn_GL000220v1 112151-114350 + | 197742 #&gt; uc064xqj.1 chrUn_GL000220v1 115428-117627 + | 197743 #&gt; uc064xqk.1 chrUn_GL000220v1 116197-118396 + | 197744 #&gt; uc033dnj.2 chrUn_GL000220v1 153997-156196 + | 197750 #&gt; tx_name #&gt; &lt;character&gt; #&gt; uc001hzz.2 uc001hzz.2 #&gt; uc021plu.1 uc021plu.1 #&gt; uc001iab.3 uc001iab.3 #&gt; uc057qvr.1 uc057qvr.1 #&gt; uc057qvt.1 uc057qvt.1 #&gt; ... ... #&gt; uc064xqh.1 uc064xqh.1 #&gt; uc064xqi.1 uc064xqi.1 #&gt; uc064xqj.1 uc064xqj.1 #&gt; uc064xqk.1 uc064xqk.1 #&gt; uc033dnj.2 uc033dnj.2 #&gt; ------- #&gt; seqinfo: 455 sequences (1 circular) from hg38 genome # see a table in database tbl(src, &quot;id&quot;) #&gt; # Source: table&lt;id&gt; [?? x 6] #&gt; # Database: sqlite 3.22.0 [] #&gt; entrez map ensembl symbol genename alias #&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 1 19q13.4 ENSG00000121410 A1BG alpha-1-B glycoprotein A1B #&gt; 2 1 19q13.4 ENSG00000121410 A1BG alpha-1-B glycoprotein ABG #&gt; 3 1 19q13.4 ENSG00000121410 A1BG alpha-1-B glycoprotein GAB #&gt; 4 1 19q13.4 ENSG00000121410 A1BG alpha-1-B glycoprotein HYST2477 #&gt; 5 1 19q13.4 ENSG00000121410 A1BG alpha-1-B glycoprotein A1BG #&gt; 6 10 8p22 ENSG00000156006 NAT2 N-acetyltransferase 2 AAC2 #&gt; 7 10 8p22 ENSG00000156006 NAT2 N-acetyltransferase 2 NAT-2 #&gt; 8 10 8p22 ENSG00000156006 NAT2 N-acetyltransferase 2 PNAT #&gt; 9 10 8p22 ENSG00000156006 NAT2 N-acetyltransferase 2 NAT2 #&gt; 10 100 20q13.12 ENSG00000196839 ADA adenosine deaminase ADA #&gt; # ... with more rows # information from two tables inner_join(tbl(src, &quot;id&quot;), tbl(src, &quot;ranges_gene&quot;)) %&gt;% filter(symbol %in% c(&quot;ADA&quot;, &quot;NAT2&quot;)) %&gt;% dplyr::select(gene_chrom, gene_start, gene_end, gene_strand, symbol, alias, map) #&gt; Joining, by = &quot;entrez&quot; #&gt; # Source: lazy query [?? x 7] #&gt; # Database: sqlite 3.22.0 [] #&gt; gene_chrom gene_start gene_end gene_strand symbol alias map #&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 chr8 18391245 18401218 + NAT2 AAC2 8p22 #&gt; 2 chr8 18391245 18401218 + NAT2 NAT-2 8p22 #&gt; 3 chr8 18391245 18401218 + NAT2 PNAT 8p22 #&gt; 4 chr8 18391245 18401218 + NAT2 NAT2 8p22 #&gt; 5 chr20 44619522 44651742 - ADA ADA 20q13.12 9.4.34 Organism.dplyr exercises How many supported organisms are implemented in Organism.dplyr? Display the ensembl Id and genename description for symbol “NAT2”. Show all the alias for “NAT2” in the database. Display Gene ontology (GO) information for gene symbol “NAT2”. 9.4.35 BSgenome packages BSgenome packages contain sequence information for a given species/build. There are many such packages - you can get a listing using available.genomes library(BSgenome) head(available.genomes()) #&gt; [1] &quot;BSgenome.Alyrata.JGI.v1&quot; #&gt; [2] &quot;BSgenome.Amellifera.BeeBase.assembly4&quot; #&gt; [3] &quot;BSgenome.Amellifera.UCSC.apiMel2&quot; #&gt; [4] &quot;BSgenome.Amellifera.UCSC.apiMel2.masked&quot; #&gt; [5] &quot;BSgenome.Athaliana.TAIR.04232008&quot; #&gt; [6] &quot;BSgenome.Athaliana.TAIR.TAIR9&quot; 9.4.36 BSgenome packages We can load and inspect a BSgenome package library(BSgenome.Hsapiens.UCSC.hg19) Hsapiens #&gt; Human genome: #&gt; # organism: Homo sapiens (Human) #&gt; # provider: UCSC #&gt; # provider version: hg19 #&gt; # release date: Feb. 2009 #&gt; # release name: Genome Reference Consortium GRCh37 #&gt; # 93 sequences: #&gt; # chr1 chr2 chr3 #&gt; # chr4 chr5 chr6 #&gt; # chr7 chr8 chr9 #&gt; # chr10 chr11 chr12 #&gt; # chr13 chr14 chr15 #&gt; # ... ... ... #&gt; # chrUn_gl000235 chrUn_gl000236 chrUn_gl000237 #&gt; # chrUn_gl000238 chrUn_gl000239 chrUn_gl000240 #&gt; # chrUn_gl000241 chrUn_gl000242 chrUn_gl000243 #&gt; # chrUn_gl000244 chrUn_gl000245 chrUn_gl000246 #&gt; # chrUn_gl000247 chrUn_gl000248 chrUn_gl000249 #&gt; # (use &#39;seqnames()&#39; to see all the sequence names, use the &#39;$&#39; or &#39;[[&#39; #&gt; # operator to access a given sequence) 9.4.37 BSgenome packages The main accessor is getSeq, and you can get data by sequence (e.g., entire chromosome or unplaced scaffold), or by passing in a GRanges object, to get just a region. getSeq(Hsapiens, &quot;chr1&quot;) #&gt; 249250621-letter &quot;DNAString&quot; instance #&gt; seq: NNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN...NNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN getSeq(Hsapiens, gns[&quot;5467&quot;,]) #&gt; A DNAStringSet instance of length 1 #&gt; width seq names #&gt; [1] 85634 GCGGAGCGTGTGACGCTGCGG...TATTTAAGAGCTGACTGGAA 5467 The Biostrings package contains most of the code for dealing with these *StringSet objects - please see the Biostrings vignettes and help pages for more information. 9.4.38 BSgenome exercises Get the sequences for all transcripts of the TP53 gene 9.4.39 AnnotationHub AnnotationHub is a package that allows us to query and download many different annotation objects, without having to explicitly install them. library(AnnotationHub) hub &lt;- AnnotationHub() #&gt; snapshotDate(): 2018-06-27 hub #&gt; AnnotationHub with 44925 records #&gt; # snapshotDate(): 2018-06-27 #&gt; # $dataprovider: BroadInstitute, Ensembl, UCSC, ftp://ftp.ncbi.nlm.nih.... #&gt; # $species: Homo sapiens, Mus musculus, Drosophila melanogaster, Bos ta... #&gt; # $rdataclass: GRanges, BigWigFile, FaFile, TwoBitFile, Rle, OrgDb, Cha... #&gt; # additional mcols(): taxonomyid, genome, description, #&gt; # coordinate_1_based, maintainer, rdatadateadded, preparerclass, #&gt; # tags, rdatapath, sourceurl, sourcetype #&gt; # retrieve records with, e.g., &#39;object[[&quot;AH2&quot;]]&#39; #&gt; #&gt; title #&gt; AH2 | Ailuropoda_melanoleuca.ailMel1.69.dna.toplevel.fa #&gt; AH3 | Ailuropoda_melanoleuca.ailMel1.69.dna_rm.toplevel.fa #&gt; AH4 | Ailuropoda_melanoleuca.ailMel1.69.dna_sm.toplevel.fa #&gt; AH5 | Ailuropoda_melanoleuca.ailMel1.69.ncrna.fa #&gt; AH6 | Ailuropoda_melanoleuca.ailMel1.69.pep.all.fa #&gt; ... ... #&gt; AH63655 | phastCons46wayPrimates.UCSC.hg19.chrX.rds #&gt; AH63656 | phastCons46wayPrimates.UCSC.hg19.chrY.rds #&gt; AH63657 | Alternative Splicing Annotation for Homo sapiens (Human) #&gt; AH63658 | Allele data from the IPD IMGT/HLA database #&gt; AH63659 | Allele data from the IPD KIR database 9.4.40 Querying AnnotationHub Finding the ‘right’ resource on AnnotationHub is like using Google - a well posed query is necessary to find what you are after. Useful queries are based on Data provider Data class Species Data source names(mcols(hub)) #&gt; [1] &quot;title&quot; &quot;dataprovider&quot; &quot;species&quot; #&gt; [4] &quot;taxonomyid&quot; &quot;genome&quot; &quot;description&quot; #&gt; [7] &quot;coordinate_1_based&quot; &quot;maintainer&quot; &quot;rdatadateadded&quot; #&gt; [10] &quot;preparerclass&quot; &quot;tags&quot; &quot;rdataclass&quot; #&gt; [13] &quot;rdatapath&quot; &quot;sourceurl&quot; &quot;sourcetype&quot; 9.4.41 AnnotationHub Data providers unique(hub$dataprovider) #&gt; [1] &quot;Ensembl&quot; #&gt; [2] &quot;UCSC&quot; #&gt; [3] &quot;RefNet&quot; #&gt; [4] &quot;Inparanoid8&quot; #&gt; [5] &quot;NHLBI&quot; #&gt; [6] &quot;ChEA&quot; #&gt; [7] &quot;Pazar&quot; #&gt; [8] &quot;NIH Pathway Interaction Database&quot; #&gt; [9] &quot;Haemcode&quot; #&gt; [10] &quot;BroadInstitute&quot; #&gt; [11] &quot;PRIDE&quot; #&gt; [12] &quot;Gencode&quot; #&gt; [13] &quot;CRIBI&quot; #&gt; [14] &quot;Genoscope&quot; #&gt; [15] &quot;MISO, VAST-TOOLS, UCSC&quot; #&gt; [16] &quot;UWashington&quot; #&gt; [17] &quot;Stanford&quot; #&gt; [18] &quot;dbSNP&quot; #&gt; [19] &quot;BioMart&quot; #&gt; [20] &quot;GeneOntology&quot; #&gt; [21] &quot;KEGG&quot; #&gt; [22] &quot;URGI&quot; #&gt; [23] &quot;ftp://ftp.ncbi.nlm.nih.gov/gene/DATA/&quot; #&gt; [24] &quot;EMBL-EBI&quot; 9.4.42 AnnotationHub Data classes unique(hub$rdataclass) #&gt; [1] &quot;FaFile&quot; #&gt; [2] &quot;GRanges&quot; #&gt; [3] &quot;data.frame&quot; #&gt; [4] &quot;Inparanoid8Db&quot; #&gt; [5] &quot;TwoBitFile&quot; #&gt; [6] &quot;ChainFile&quot; #&gt; [7] &quot;SQLiteConnection&quot; #&gt; [8] &quot;biopax&quot; #&gt; [9] &quot;BigWigFile&quot; #&gt; [10] &quot;AAStringSet&quot; #&gt; [11] &quot;MSnSet&quot; #&gt; [12] &quot;mzRpwiz&quot; #&gt; [13] &quot;mzRident&quot; #&gt; [14] &quot;list&quot; #&gt; [15] &quot;TxDb&quot; #&gt; [16] &quot;Rle&quot; #&gt; [17] &quot;EnsDb&quot; #&gt; [18] &quot;VcfFile&quot; #&gt; [19] &quot;igraph&quot; #&gt; [20] &quot;OrgDb&quot; #&gt; [21] &quot;data.frame, DNAStringSet, GRanges&quot; 9.4.43 AnnotationHub Species head(unique(hub$species)) #&gt; [1] &quot;Ailuropoda melanoleuca&quot; &quot;Anolis carolinensis&quot; #&gt; [3] &quot;Bos taurus&quot; &quot;Caenorhabditis elegans&quot; #&gt; [5] &quot;Callithrix jacchus&quot; &quot;Canis familiaris&quot; length(unique(hub$species)) #&gt; [1] 1971 9.4.44 AnnotationHub Data sources unique(hub$sourcetype) #&gt; [1] &quot;FASTA&quot; &quot;UCSC track&quot; &quot;GTF&quot; &quot;TSV&quot; #&gt; [5] &quot;Inparanoid&quot; &quot;TwoBit&quot; &quot;Chain&quot; &quot;GRASP&quot; #&gt; [9] &quot;Zip&quot; &quot;CSV&quot; &quot;BioPax&quot; &quot;BioPaxLevel2&quot; #&gt; [13] &quot;RData&quot; &quot;BED&quot; &quot;BigWig&quot; &quot;tab&quot; #&gt; [17] &quot;mzTab&quot; &quot;mzML&quot; &quot;mzid&quot; &quot;GFF&quot; #&gt; [21] &quot;ensembl&quot; &quot;VCF&quot; &quot;NCBI/ensembl&quot; &quot;NCBI/UniProt&quot; 9.4.45 AnnotationHub query qry &lt;- query(hub, c(&quot;granges&quot;,&quot;homo sapiens&quot;,&quot;ensembl&quot;)) qry #&gt; AnnotationHub with 56 records #&gt; # snapshotDate(): 2018-06-27 #&gt; # $dataprovider: Ensembl, UCSC #&gt; # $species: Homo sapiens #&gt; # $rdataclass: GRanges #&gt; # additional mcols(): taxonomyid, genome, description, #&gt; # coordinate_1_based, maintainer, rdatadateadded, preparerclass, #&gt; # tags, rdatapath, sourceurl, sourcetype #&gt; # retrieve records with, e.g., &#39;object[[&quot;AH5046&quot;]]&#39; #&gt; #&gt; title #&gt; AH5046 | Ensembl Genes #&gt; AH5160 | Ensembl Genes #&gt; AH5311 | Ensembl Genes #&gt; AH5434 | Ensembl Genes #&gt; AH5435 | Ensembl EST Genes #&gt; ... ... #&gt; AH60085 | Homo_sapiens.GRCh38.91.gtf #&gt; AH61125 | Homo_sapiens.GRCh38.92.abinitio.gtf #&gt; AH61126 | Homo_sapiens.GRCh38.92.chr.gtf #&gt; AH61127 | Homo_sapiens.GRCh38.92.chr_patch_hapl_scaff.gtf #&gt; AH61128 | Homo_sapiens.GRCh38.92.gtf 9.4.46 AnnotationHub query qry$sourceurl #&gt; [1] &quot;rtracklayer://hgdownload.cse.ucsc.edu/goldenpath/hg19/database/ensGene&quot; #&gt; [2] &quot;rtracklayer://hgdownload.cse.ucsc.edu/goldenpath/hg18/database/ensGene&quot; #&gt; [3] &quot;rtracklayer://hgdownload.cse.ucsc.edu/goldenpath/hg17/database/ensGene&quot; #&gt; [4] &quot;rtracklayer://hgdownload.cse.ucsc.edu/goldenpath/hg16/database/ensGene&quot; #&gt; [5] &quot;rtracklayer://hgdownload.cse.ucsc.edu/goldenpath/hg16/database/ensEstGene&quot; #&gt; [6] &quot;ftp://ftp.ensembl.org/pub/release-70/gtf/homo_sapiens/Homo_sapiens.GRCh37.70.gtf.gz&quot; #&gt; [7] &quot;ftp://ftp.ensembl.org/pub/release-69/gtf/homo_sapiens/Homo_sapiens.GRCh37.69.gtf.gz&quot; #&gt; [8] &quot;ftp://ftp.ensembl.org/pub/release-71/gtf/homo_sapiens/Homo_sapiens.GRCh37.71.gtf.gz&quot; #&gt; [9] &quot;ftp://ftp.ensembl.org/pub/release-72/gtf/homo_sapiens/Homo_sapiens.GRCh37.72.gtf.gz&quot; #&gt; [10] &quot;ftp://ftp.ensembl.org/pub/release-73/gtf/homo_sapiens/Homo_sapiens.GRCh37.73.gtf.gz&quot; #&gt; [11] &quot;ftp://ftp.ensembl.org/pub/release-74/gtf/homo_sapiens/Homo_sapiens.GRCh37.74.gtf.gz&quot; #&gt; [12] &quot;ftp://ftp.ensembl.org/pub/release-75/gtf/homo_sapiens/Homo_sapiens.GRCh37.75.gtf.gz&quot; #&gt; [13] &quot;ftp://ftp.ensembl.org/pub/release-78/gtf/homo_sapiens/Homo_sapiens.GRCh38.78.gtf.gz&quot; #&gt; [14] &quot;ftp://ftp.ensembl.org/pub/release-76/gtf/homo_sapiens/Homo_sapiens.GRCh38.76.gtf.gz&quot; #&gt; [15] &quot;ftp://ftp.ensembl.org/pub/release-79/gtf/homo_sapiens/Homo_sapiens.GRCh38.79.gtf.gz&quot; #&gt; [16] &quot;ftp://ftp.ensembl.org/pub/release-77/gtf/homo_sapiens/Homo_sapiens.GRCh38.77.gtf.gz&quot; #&gt; [17] &quot;ftp://ftp.ensembl.org/pub/release-80/gtf/homo_sapiens/Homo_sapiens.GRCh38.80.gtf.gz&quot; #&gt; [18] &quot;ftp://ftp.ensembl.org/pub/release-81/gtf/homo_sapiens/Homo_sapiens.GRCh38.81.gtf.gz&quot; #&gt; [19] &quot;ftp://ftp.ensembl.org/pub/release-82/gtf/homo_sapiens/Homo_sapiens.GRCh38.82.gtf.gz&quot; #&gt; [20] &quot;ftp://ftp.ensembl.org/pub/release-83/gtf/homo_sapiens/Homo_sapiens.GRCh38.83.gtf.gz&quot; #&gt; [21] &quot;ftp://ftp.ensembl.org/pub/release-84/gtf/homo_sapiens/Homo_sapiens.GRCh38.84.abinitio.gtf.gz&quot; #&gt; [22] &quot;ftp://ftp.ensembl.org/pub/release-84/gtf/homo_sapiens/Homo_sapiens.GRCh38.84.chr.gtf.gz&quot; #&gt; [23] &quot;ftp://ftp.ensembl.org/pub/release-84/gtf/homo_sapiens/Homo_sapiens.GRCh38.84.chr_patch_hapl_scaff.gtf.gz&quot; #&gt; [24] &quot;ftp://ftp.ensembl.org/pub/release-84/gtf/homo_sapiens/Homo_sapiens.GRCh38.84.gtf.gz&quot; #&gt; [25] &quot;ftp://ftp.ensembl.org/pub/release-85/gtf/homo_sapiens/Homo_sapiens.GRCh38.85.abinitio.gtf.gz&quot; #&gt; [26] &quot;ftp://ftp.ensembl.org/pub/release-85/gtf/homo_sapiens/Homo_sapiens.GRCh38.85.chr.gtf.gz&quot; #&gt; [27] &quot;ftp://ftp.ensembl.org/pub/release-85/gtf/homo_sapiens/Homo_sapiens.GRCh38.85.chr_patch_hapl_scaff.gtf.gz&quot; #&gt; [28] &quot;ftp://ftp.ensembl.org/pub/release-85/gtf/homo_sapiens/Homo_sapiens.GRCh38.85.gtf.gz&quot; #&gt; [29] &quot;ftp://ftp.ensembl.org/pub/release-86/gtf/homo_sapiens/Homo_sapiens.GRCh38.86.abinitio.gtf.gz&quot; #&gt; [30] &quot;ftp://ftp.ensembl.org/pub/release-86/gtf/homo_sapiens/Homo_sapiens.GRCh38.86.chr.gtf.gz&quot; #&gt; [31] &quot;ftp://ftp.ensembl.org/pub/release-86/gtf/homo_sapiens/Homo_sapiens.GRCh38.86.chr_patch_hapl_scaff.gtf.gz&quot; #&gt; [32] &quot;ftp://ftp.ensembl.org/pub/release-86/gtf/homo_sapiens/Homo_sapiens.GRCh38.86.gtf.gz&quot; #&gt; [33] &quot;ftp://ftp.ensembl.org/pub/release-87/gtf/homo_sapiens/Homo_sapiens.GRCh38.87.abinitio.gtf.gz&quot; #&gt; [34] &quot;ftp://ftp.ensembl.org/pub/release-87/gtf/homo_sapiens/Homo_sapiens.GRCh38.87.chr.gtf.gz&quot; #&gt; [35] &quot;ftp://ftp.ensembl.org/pub/release-87/gtf/homo_sapiens/Homo_sapiens.GRCh38.87.chr_patch_hapl_scaff.gtf.gz&quot; #&gt; [36] &quot;ftp://ftp.ensembl.org/pub/release-87/gtf/homo_sapiens/Homo_sapiens.GRCh38.87.gtf.gz&quot; #&gt; [37] &quot;ftp://ftp.ensembl.org/pub/release-88/gtf/homo_sapiens/Homo_sapiens.GRCh38.88.abinitio.gtf.gz&quot; #&gt; [38] &quot;ftp://ftp.ensembl.org/pub/release-88/gtf/homo_sapiens/Homo_sapiens.GRCh38.88.chr.gtf.gz&quot; #&gt; [39] &quot;ftp://ftp.ensembl.org/pub/release-88/gtf/homo_sapiens/Homo_sapiens.GRCh38.88.chr_patch_hapl_scaff.gtf.gz&quot; #&gt; [40] &quot;ftp://ftp.ensembl.org/pub/release-88/gtf/homo_sapiens/Homo_sapiens.GRCh38.88.gtf.gz&quot; #&gt; [41] &quot;ftp://ftp.ensembl.org/pub/release-89/gtf/homo_sapiens/Homo_sapiens.GRCh38.89.abinitio.gtf.gz&quot; #&gt; [42] &quot;ftp://ftp.ensembl.org/pub/release-89/gtf/homo_sapiens/Homo_sapiens.GRCh38.89.chr.gtf.gz&quot; #&gt; [43] &quot;ftp://ftp.ensembl.org/pub/release-89/gtf/homo_sapiens/Homo_sapiens.GRCh38.89.chr_patch_hapl_scaff.gtf.gz&quot; #&gt; [44] &quot;ftp://ftp.ensembl.org/pub/release-89/gtf/homo_sapiens/Homo_sapiens.GRCh38.89.gtf.gz&quot; #&gt; [45] &quot;ftp://ftp.ensembl.org/pub/release-90/gtf/homo_sapiens/Homo_sapiens.GRCh38.90.abinitio.gtf.gz&quot; #&gt; [46] &quot;ftp://ftp.ensembl.org/pub/release-90/gtf/homo_sapiens/Homo_sapiens.GRCh38.90.chr.gtf.gz&quot; #&gt; [47] &quot;ftp://ftp.ensembl.org/pub/release-90/gtf/homo_sapiens/Homo_sapiens.GRCh38.90.chr_patch_hapl_scaff.gtf.gz&quot; #&gt; [48] &quot;ftp://ftp.ensembl.org/pub/release-90/gtf/homo_sapiens/Homo_sapiens.GRCh38.90.gtf.gz&quot; #&gt; [49] &quot;ftp://ftp.ensembl.org/pub/release-91/gtf/homo_sapiens/Homo_sapiens.GRCh38.91.abinitio.gtf.gz&quot; #&gt; [50] &quot;ftp://ftp.ensembl.org/pub/release-91/gtf/homo_sapiens/Homo_sapiens.GRCh38.91.chr.gtf.gz&quot; #&gt; [51] &quot;ftp://ftp.ensembl.org/pub/release-91/gtf/homo_sapiens/Homo_sapiens.GRCh38.91.chr_patch_hapl_scaff.gtf.gz&quot; #&gt; [52] &quot;ftp://ftp.ensembl.org/pub/release-91/gtf/homo_sapiens/Homo_sapiens.GRCh38.91.gtf.gz&quot; #&gt; [53] &quot;ftp://ftp.ensembl.org/pub/release-92/gtf/homo_sapiens/Homo_sapiens.GRCh38.92.abinitio.gtf.gz&quot; #&gt; [54] &quot;ftp://ftp.ensembl.org/pub/release-92/gtf/homo_sapiens/Homo_sapiens.GRCh38.92.chr.gtf.gz&quot; #&gt; [55] &quot;ftp://ftp.ensembl.org/pub/release-92/gtf/homo_sapiens/Homo_sapiens.GRCh38.92.chr_patch_hapl_scaff.gtf.gz&quot; #&gt; [56] &quot;ftp://ftp.ensembl.org/pub/release-92/gtf/homo_sapiens/Homo_sapiens.GRCh38.92.gtf.gz&quot; 9.4.47 Selecting AnnotationHub resource whatIwant &lt;- qry[[&quot;AH50377&quot;]] We can use these data as they are, or convert to a TxDb format: GRCh38TxDb &lt;- makeTxDbFromGRanges(whatIwant) GRCh38TxDb #&gt; TxDb object: #&gt; # Db type: TxDb #&gt; # Supporting package: GenomicFeatures #&gt; # Genome: GRCh38 #&gt; # transcript_nrow: 199184 #&gt; # exon_nrow: 675836 #&gt; # cds_nrow: 270225 #&gt; # Db created by: GenomicFeatures package from Bioconductor #&gt; # Creation time: 2018-07-16 15:54:15 +0000 (Mon, 16 Jul 2018) #&gt; # GenomicFeatures version at creation time: 1.33.0 #&gt; # RSQLite version at creation time: 2.1.1 #&gt; # DBSCHEMAVERSION: 1.2 9.4.48 AnnotationHub exercises How many resources are on AnnotationHub for Atlantic salmon (Salmo salar)? Get the most recent Ensembl build for domesticated dog (Canis familiaris) and make a TxDb 9.4.49 biomaRt The biomaRt package allows queries to an Ensembl Biomart server. We can see the choices of servers that we can use: library(biomaRt) listMarts() #&gt; biomart version #&gt; 1 ENSEMBL_MART_ENSEMBL Ensembl Genes 92 #&gt; 2 ENSEMBL_MART_MOUSE Mouse strains 92 #&gt; 3 ENSEMBL_MART_SNP Ensembl Variation 92 #&gt; 4 ENSEMBL_MART_FUNCGEN Ensembl Regulation 92 9.4.50 biomaRt data sets And we can then check for the available data sets on a particular server. mart &lt;- useMart(&quot;ENSEMBL_MART_ENSEMBL&quot;) head(listDatasets(mart)) #&gt; dataset description #&gt; 1 acarolinensis_gene_ensembl Anole lizard genes (AnoCar2.0) #&gt; 2 amelanoleuca_gene_ensembl Panda genes (ailMel1) #&gt; 3 amexicanus_gene_ensembl Cave fish genes (AstMex102) #&gt; 4 anancymaae_gene_ensembl Ma&#39;s night monkey genes (Anan_2.0) #&gt; 5 aplatyrhynchos_gene_ensembl Duck genes (BGI_duck_1.0) #&gt; 6 btaurus_gene_ensembl Cow genes (UMD3.1) #&gt; version #&gt; 1 AnoCar2.0 #&gt; 2 ailMel1 #&gt; 3 AstMex102 #&gt; 4 Anan_2.0 #&gt; 5 BGI_duck_1.0 #&gt; 6 UMD3.1 9.4.51 biomaRt queries After setting up a mart object pointing to the server and data set that we care about, we can make queries. We first set up the mart object. mart &lt;- useMart(&quot;ENSEMBL_MART_ENSEMBL&quot;,&quot;hsapiens_gene_ensembl&quot;) Queries are of the form getBM(attributes, filters, values, mart) where attributes are the things we want filters are the types of IDs we have values are the IDs we have mart is the mart object we set up 9.4.52 biomaRt attributes and filters Both attributes and filters have rather inscrutable names, but a listing can be accessed using atrib &lt;- listAttributes(mart) filts &lt;- listFilters(mart) head(atrib) #&gt; name description page #&gt; 1 ensembl_gene_id Gene stable ID feature_page #&gt; 2 ensembl_gene_id_version Gene stable ID version feature_page #&gt; 3 ensembl_transcript_id Transcript stable ID feature_page #&gt; 4 ensembl_transcript_id_version Transcript stable ID version feature_page #&gt; 5 ensembl_peptide_id Protein stable ID feature_page #&gt; 6 ensembl_peptide_id_version Protein stable ID version feature_page head(filts) #&gt; name description #&gt; 1 chromosome_name Chromosome/scaffold name #&gt; 2 start Start #&gt; 3 end End #&gt; 4 band_start Band Start #&gt; 5 band_end Band End #&gt; 6 marker_start Marker Start 9.4.53 biomaRt query A simple example query afyids &lt;- c(&quot;1000_at&quot;,&quot;1001_at&quot;,&quot;1002_f_at&quot;,&quot;1007_s_at&quot;) getBM(c(&quot;affy_hg_u95av2&quot;, &quot;hgnc_symbol&quot;), c(&quot;affy_hg_u95av2&quot;), afyids, mart) #&gt; affy_hg_u95av2 hgnc_symbol #&gt; 1 1000_at MAPK3 #&gt; 2 1007_s_at DDR1 #&gt; 3 1002_f_at #&gt; 4 1002_f_at CYP2C19 #&gt; 5 1001_at TIE1 9.4.54 biomaRt exercises Get the Ensembl gene IDs and HUGO symbol for Entrez Gene IDs 672, 5468 and 7157 What do you get if you query for the ‘gene_exon’ for GAPDH? "],
["workflow-for-multi-omics-analysis-with-multiassayexperiment.html", "10 Workflow for Multi-omics Analysis with MultiAssayExperiment 10.1 Instructor names and contact information 10.2 Workshop Description 10.3 Workshop goals and objectives 10.4 Overview of key data classes 10.5 Working with RaggedExperiment 10.6 Working with MultiAssayExperiment 10.7 API cheat sheet 10.8 MultiAssayExperiment Subsetting 10.9 Complete cases 10.10 Row names that are common across assays 10.11 Extraction 10.12 Summary of slots and accessors 10.13 Transformation / reshaping 10.14 MultiAssayExperiment class construction and concatenation 10.15 The Cancer Genome Atlas (TCGA) as MultiAssayExperiment objects 10.16 Utilities for TCGA 10.17 Plotting, correlation, and other analyses", " 10 Workflow for Multi-omics Analysis with MultiAssayExperiment 10.1 Instructor names and contact information Marcel Ramos56 (marcel.ramos@roswellpark.org) Ludwig Geistlinger7 Levi Waldron8 10.2 Workshop Description This workshop demonstrates data management and analyses of multiple assays associated with a single set of biological specimens, using the MultiAssayExperiment data class and methods. It introduces the RaggedExperiment data class, which provides efficient and powerful operations for representation of copy number and mutation and variant data that are represented by different genomic ranges for each specimen. 10.2.1 Pre-requisites List any workshop prerequisites, for example: Basic knowledge of R syntax Familiarity with the GRanges and SummarizedExperiment classes Familiarity with ’omics data types including copy number and gene expression 10.2.2 Workshop Participation Students will have a chance to build a MultiAssayExperiment object from scratch, and will also work with more complex objects provided by the curatedTCGAData package. 10.2.3 R/Bioconductor packages used MultiAssayExperiment GenomicRanges RaggedExperiment curatedTCGAData SummarizedExperiment TCGAutils UpSetR AnnotationFilter EnsDb.Hsapiens.v86 survival survminer pheatmap library(MultiAssayExperiment) library(GenomicRanges) library(RaggedExperiment) library(curatedTCGAData) library(GenomicDataCommons) library(SummarizedExperiment) library(SingleCellExperiment) library(TCGAutils) library(UpSetR) library(mirbase.db) library(AnnotationFilter) library(EnsDb.Hsapiens.v86) library(survival) library(survminer) library(pheatmap) 10.2.4 Time outline 1h 45m total Activity Time Overview of key data classes 25m Working with RaggedExperiment 20m Building a MultiAssayExperiment from scratch 10m TCGA multi-assay dataset 10m Subsetting and reshaping multi-assay data 20m Plotting, correlation, and other analyses 20m 10.3 Workshop goals and objectives 10.3.1 Learning goals identify appropriate data structures for different ’omics data types gain familiarity with GRangesList and RaggedExperiment 10.3.2 Learning objectives use curatedTCGAData to create custom TCGA MultiAssayExperiment objects create a MultiAssayExperiment for TCGA or other multi’omics data perform subsetting, reshaping, growing, and extraction of a MultiAssayExperiment link MultiAssayExperiment data with packages for differential expression, machine learning, and plotting 10.4 Overview of key data classes This section summarizes three fundamental data classes for the representation of multi-omics experiments. 10.4.1 (Ranged)SummarizedExperiment Figure 10.1: A matrix-like container where rows represent features of interest and columns represent samples. The objects contain one or more assays, each represented by a matrix-like object of numeric or other mode. SummarizedExperiment is the most important Bioconductor class for matrix-like experimental data, including from RNA sequencing and microarray experiments. It can store multiple experimental data matrices of identical dimensions, with associated metadata on the rows/genes/transcripts/other measurements (rowData), column/sample phenotype or clinical data (colData), and the overall experiment (metadata). The derivative class RangedSummarizedExperiment associates a GRanges or GRangesList vector with the rows. These classes supersede the use of ExpressionSet. Note that many other classes for experimental data are actually derived from SummarizedExperiment; for example, the SingleCellExperiment class for single-cell RNA sequencing experiments extends RangedSummarizedExperiment, which in turn extends SummarizedExperiment: library(SingleCellExperiment) extends(&quot;SingleCellExperiment&quot;) #&gt; [1] &quot;SingleCellExperiment&quot; &quot;RangedSummarizedExperiment&quot; #&gt; [3] &quot;SummarizedExperiment&quot; &quot;Vector&quot; #&gt; [5] &quot;Annotated&quot; Thus, although SingleCellExperiment provides additional methods over RangedSummarizedExperiment, it also inherits all the methods of SummarizedExperiment and RangedSummarizedExperiment, so everything you learn about SummarizedExperiment will be applicable to SingleCellExperiment. 10.4.2 RaggedExperiment RaggedExperiment is a flexible data representation for segmented copy number, somatic mutations such as represented in .vcf files, and other ragged array schema for genomic location data. Like the GRangesList class from GenomicRanges, RaggedExperiment can be used to represent differing genomic ranges on each of a set of samples. In fact, RaggedExperiment contains a GRangesList: showClass(&quot;RaggedExperiment&quot;) #&gt; Class &quot;RaggedExperiment&quot; [package &quot;RaggedExperiment&quot;] #&gt; #&gt; Slots: #&gt; #&gt; Name: assays rowidx colidx metadata #&gt; Class: GRangesList integer integer list #&gt; #&gt; Extends: &quot;Annotated&quot; However, RaggedExperiment provides a flexible set of Assay methods to support transformation of such data to matrix format. Figure 10.2: RaggedExperiment object schematic. Rows and columns represent genomic ranges and samples, respectively. Assay operations can be performed with (from left to right) compactAssay, qreduceAssay, and sparseAssay. 10.4.3 MultiAssayExperiment MultiAssayExperiment is an integrative container for coordinating multi-omics experiment data on a set of biological specimens. As much as possible, its methods adopt the same vocabulary as SummarizedExperiment. A MultiAssayExperiment can contain any number of assays with different representations. Assays may be ID-based, where measurements are indexed identifiers of genes, microRNA, proteins, microbes, etc. Alternatively, assays may be range-based, where measurements correspond to genomic ranges that can be represented as GRanges objects, such as gene expression or copy number. For ID-based assays, there is no requirement that the same IDs be present for different experiments. For range-based assays, there is also no requirement that the same ranges be present for different experiments; furthermore, it is possible for different samples within an experiment to be represented by different ranges. The following data classes have been tested to work as elements of a MultiAssayExperiment: matrix: the most basic class for ID-based datasets, could be used for example for gene expression summarized per-gene, microRNA, metabolomics, or microbiome data. SummarizedExperiment and derived methods: described above, could be used for miRNA, gene expression, proteomics, or any matrix-like data where measurements are represented by IDs. RangedSummarizedExperiment: described above, could be used for gene expression, methylation, or other data types referring to genomic positions. ExpressionSet: Another rich representation for ID-based datasets, supported only for legacy reasons RaggedExperiment: described above, for non-rectangular (ragged) ranged-based datasets such as segmented copy number, where segmentation of copy number alterations occurs and different genomic locations in each sample. RangedVcfStack: For VCF archives broken up by chromosome (see VcfStack class defined in the GenomicFiles package) DelayedMatrix: An on-disk representation of matrix-like objects for large datasets. It reduces memory usage and optimizes performance with delayed operations. This class is part of the DelayedArray package. Note that any data class extending these classes, and in fact any data class supporting row and column names and subsetting can be used as an element of a MultiAssayExperiment. Figure 10.3: MultiAssayExperiment object schematic. colData provides data about the patients, cell lines, or other biological units, with one row per unit and one column per variable. The experiments are a list of assay datasets of arbitrary class. The sampleMap relates each column (observation) in ExperimentList to exactly one row (biological unit) in colData; however, one row of colData may map to zero, one, or more columns per assay, allowing for missing and replicate assays. sampleMap allows for per-assay sample naming conventions. Metadata can be used to store information in arbitrary format about the MultiAssayExperiment. Green stripes indicate a mapping of one subject to multiple observations across experiments. 10.5 Working with RaggedExperiment You can skip this section if you prefer to focus on the functionality of MultiAssayExperiment. In most use cases, you would likely convert a RaggedExperiment to matrix or RangedSummarizedExperiment using one of the Assay functions below, and either concatenate this rectangular object to the MultiAssayExperiment or use it to replace the RaggedExperiment. 10.5.1 Constructing a RaggedExperiment object We start with a toy example of two GRanges objects, providing ranges on two chromosomes in two samples: sample1 &lt;- GRanges( c(A = &quot;chr1:1-10:-&quot;, B = &quot;chr1:8-14:+&quot;, C = &quot;chr1:15-18:+&quot;), score = 3:5, type=c(&quot;germline&quot;, &quot;somatic&quot;, &quot;germline&quot;)) sample2 &lt;- GRanges( c(D = &quot;chr1:1-10:-&quot;, E = &quot;chr1:11-18:+&quot;), score = 11:12, type=c(&quot;germline&quot;, &quot;somatic&quot;)) Include column data colData to describe the samples: colDat &lt;- DataFrame(id=1:2, status = factor(c(&quot;control&quot;, &quot;case&quot;))) The RaggedExperiment can be constructed from individual Granges: (ragexp &lt;- RaggedExperiment( sample1 = sample1, sample2 = sample2, colData = colDat)) #&gt; class: RaggedExperiment #&gt; dim: 5 2 #&gt; assays(2): score type #&gt; rownames(5): A B C D E #&gt; colnames(2): sample1 sample2 #&gt; colData names(2): id status Or from a GRangesList: grl &lt;- GRangesList(sample1=sample1, sample2=sample2) ragexp2 &lt;- RaggedExperiment(grl, colData = colDat) identical(ragexp, ragexp2) #&gt; [1] TRUE Note that the original ranges are is represented as the rowRanges of the RaggedExperiment: rowRanges(ragexp) #&gt; GRanges object with 5 ranges and 0 metadata columns: #&gt; seqnames ranges strand #&gt; &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; #&gt; A chr1 1-10 - #&gt; B chr1 8-14 + #&gt; C chr1 15-18 + #&gt; D chr1 1-10 - #&gt; E chr1 11-18 + #&gt; ------- #&gt; seqinfo: 1 sequence from an unspecified genome; no seqlengths 10.5.2 *Assay functions A suite of *Assay operations allow users to resize the matrix-like representation of ranges to varying row dimensions (see RaggedExperiment Figure for a visual example). The four main Assay functions for converting to matrix are: sparseAssay: leave ranges exactly as-is compactAssay: combine identical ranges disjoinAssay: disjoin ranges that overlap across samples qreduceAssay: find overlaps with provided “query” ranges These each have a corresponding function for conversion to RangedSummarizedExperiment. 10.5.2.1 sparseAssay The most straightforward matrix representation of a RaggedExperiment will return a matrix with the number of rows equal to the total number of ranges defined across all samples. i.e. the 5 rows of the sparseAssay result: sparseAssay(ragexp) #&gt; sample1 sample2 #&gt; A 3 NA #&gt; B 4 NA #&gt; C 5 NA #&gt; D NA 11 #&gt; E NA 12 correspond to the ranges of the unlisted GRangesList: unlist(grl) #&gt; GRanges object with 5 ranges and 2 metadata columns: #&gt; seqnames ranges strand | score type #&gt; &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;integer&gt; &lt;character&gt; #&gt; sample1.A chr1 1-10 - | 3 germline #&gt; sample1.B chr1 8-14 + | 4 somatic #&gt; sample1.C chr1 15-18 + | 5 germline #&gt; sample2.D chr1 1-10 - | 11 germline #&gt; sample2.E chr1 11-18 + | 12 somatic #&gt; ------- #&gt; seqinfo: 1 sequence from an unspecified genome; no seqlengths The rownames of the sparseAssay result are equal to the names of the GRanges elements. The values in the matrix returned by sparseAssay correspond to the first columns of the mcols of each GRangesList element, in this case the “score” column. Note, this is the default assay() method of RaggedExperiment: assay(ragexp, &quot;score&quot;) #&gt; sample1 sample2 #&gt; A 3 NA #&gt; B 4 NA #&gt; C 5 NA #&gt; D NA 11 #&gt; E NA 12 assay(ragexp, &quot;type&quot;) #&gt; sample1 sample2 #&gt; A &quot;germline&quot; NA #&gt; B &quot;somatic&quot; NA #&gt; C &quot;germline&quot; NA #&gt; D NA &quot;germline&quot; #&gt; E NA &quot;somatic&quot; 10.5.2.2 compactAssay The dimensions of the compactAssay result differ from that of the sparseAssay result only if there are identical ranges in different samples. Identical ranges are placed in the same row in the output. Ranges with any difference in start, end, or strand, will be kept on different rows. Non-disjoint ranges are not collapsed. compactAssay(ragexp) #&gt; sample1 sample2 #&gt; chr1:8-14:+ 4 NA #&gt; chr1:11-18:+ NA 12 #&gt; chr1:15-18:+ 5 NA #&gt; chr1:1-10:- 3 11 compactAssay(ragexp, &quot;type&quot;) #&gt; sample1 sample2 #&gt; chr1:8-14:+ &quot;somatic&quot; NA #&gt; chr1:11-18:+ NA &quot;somatic&quot; #&gt; chr1:15-18:+ &quot;germline&quot; NA #&gt; chr1:1-10:- &quot;germline&quot; &quot;germline&quot; Note that row names are constructed from the ranges, and the names of the GRanges vectors are lost, unlike in the sparseAssay result. 10.5.2.3 disjoinAssay This function is similar to compactAssay except the rows are disjoint9 ranges. Elements of the matrix are summarized by applying the simplifyDisjoin functional argument to assay values of overlapping ranges. disjoinAssay(ragexp, simplifyDisjoin = mean) #&gt; sample1 sample2 #&gt; chr1:8-10:+ 4 NA #&gt; chr1:11-14:+ 4 12 #&gt; chr1:15-18:+ 5 12 #&gt; chr1:1-10:- 3 11 10.5.2.4 qreduceAssay The qreduceAssay function is the most complicated but likely the most useful of the RaggedExperiment Assay functions. It requires you to provide a query argument that is a GRanges vector, and the rows of the resulting matrix correspond to the elements of this GRanges. The returned matrix will have dimensions length(query) by ncol(x). Elements of the resulting matrix correspond to the overlap of the i th query range in the j th sample, summarized according to the simplifyReduce functional argument. This can be useful, for example, to calculate per-gene copy number or mutation status by providing the genomic ranges of every gene as the query. The simplifyReduce argument in qreduceAssay allows the user to summarize overlapping regions with a custom method for the given “query” region of interest. We provide one for calculating a weighted average score per query range, where the weight is proportional to the overlap widths between overlapping ranges and a query range. Note that there are three arguments to this function. See the documentation for additional details. weightedmean &lt;- function(scores, ranges, qranges) { isects &lt;- pintersect(ranges, qranges) sum(scores * width(isects)) / sum(width(isects)) } The call to qreduceAssay calculates the overlaps between the ranges of each sample: grl #&gt; GRangesList object of length 2: #&gt; $sample1 #&gt; GRanges object with 3 ranges and 2 metadata columns: #&gt; seqnames ranges strand | score type #&gt; &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;integer&gt; &lt;character&gt; #&gt; A chr1 1-10 - | 3 germline #&gt; B chr1 8-14 + | 4 somatic #&gt; C chr1 15-18 + | 5 germline #&gt; #&gt; $sample2 #&gt; GRanges object with 2 ranges and 2 metadata columns: #&gt; seqnames ranges strand | score type #&gt; D chr1 1-10 - | 11 germline #&gt; E chr1 11-18 + | 12 somatic #&gt; #&gt; ------- #&gt; seqinfo: 1 sequence from an unspecified genome; no seqlengths with the query ranges (an arbitrary set is defined here for demonstration): First create a demonstration “query” region of interest: (query &lt;- GRanges(c(&quot;chr1:1-14:-&quot;, &quot;chr1:15-18:+&quot;))) #&gt; GRanges object with 2 ranges and 0 metadata columns: #&gt; seqnames ranges strand #&gt; &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; #&gt; [1] chr1 1-14 - #&gt; [2] chr1 15-18 + #&gt; ------- #&gt; seqinfo: 1 sequence from an unspecified genome; no seqlengths using the simplifyReduce function to resolve overlapping ranges and return a matrix with rows corresponding to the query: qreduceAssay(ragexp, query, simplifyReduce = weightedmean) #&gt; sample1 sample2 #&gt; chr1:1-14:- 3 11 #&gt; chr1:15-18:+ 5 12 10.5.3 Conversion to RangedSummarizedExperiment These methods all have corresponding methods to return a RangedSummarizedExperiment and preserve the colData: sparseSummarizedExperiment(ragexp) compactSummarizedExperiment(ragexp) disjoinSummarizedExperiment(ragexp, simplify = mean) qreduceSummarizedExperiment(ragexp, query=query, simplify=weightedmean) 10.6 Working with MultiAssayExperiment 10.7 API cheat sheet Figure 10.4: The MultiAssayExperiment API for construction, access, subsetting, management, and reshaping to formats for application of R/Bioconductor graphics and analysis packages. 10.7.1 The MultiAssayExperiment miniACC demo object Get started by trying out MultiAssayExperiment using a subset of the TCGA adrenocortical carcinoma (ACC) dataset provided with the package. This dataset provides five assays on 92 patients, although all five assays were not performed for every patient: RNASeq2GeneNorm: gene mRNA abundance by RNA-seq gistict: GISTIC genomic copy number by gene RPPAArray: protein abundance by Reverse Phase Protein Array Mutations: non-silent somatic mutations by gene miRNASeqGene: microRNA abundance by microRNA-seq. data(miniACC) miniACC #&gt; A MultiAssayExperiment object of 5 listed #&gt; experiments with user-defined names and respective classes. #&gt; Containing an ExperimentList class object of length 5: #&gt; [1] RNASeq2GeneNorm: SummarizedExperiment with 198 rows and 79 columns #&gt; [2] gistict: SummarizedExperiment with 198 rows and 90 columns #&gt; [3] RPPAArray: SummarizedExperiment with 33 rows and 46 columns #&gt; [4] Mutations: matrix with 97 rows and 90 columns #&gt; [5] miRNASeqGene: SummarizedExperiment with 471 rows and 80 columns #&gt; Features: #&gt; experiments() - obtain the ExperimentList instance #&gt; colData() - the primary/phenotype DataFrame #&gt; sampleMap() - the sample availability DataFrame #&gt; `$`, `[`, `[[` - extract colData columns, subset, or experiment #&gt; *Format() - convert into a long or wide DataFrame #&gt; assays() - convert ExperimentList to a SimpleList of matrices 10.7.2 colData - information biological units This slot is a DataFrame describing the characteristics of biological units, for example clinical data for patients. In the prepared datasets from [The Cancer Genome Atlas][], each row is one patient and each column is a clinical, pathological, subtype, or other variable. The $ function provides a shortcut for accessing or setting colData columns. colData(miniACC)[1:4, 1:4] #&gt; DataFrame with 4 rows and 4 columns #&gt; patientID years_to_birth vital_status days_to_death #&gt; &lt;character&gt; &lt;integer&gt; &lt;integer&gt; &lt;integer&gt; #&gt; TCGA-OR-A5J1 TCGA-OR-A5J1 58 1 1355 #&gt; TCGA-OR-A5J2 TCGA-OR-A5J2 44 1 1677 #&gt; TCGA-OR-A5J3 TCGA-OR-A5J3 23 0 NA #&gt; TCGA-OR-A5J4 TCGA-OR-A5J4 23 1 423 table(miniACC$race) #&gt; #&gt; asian black or african american #&gt; 2 1 #&gt; white #&gt; 78 Key points about the colData: Each row maps to zero or more observations in each experiment in the ExperimentList, below. One row per biological unit MultiAssayExperiment supports both missing observations and replicate observations, ie one row of colData can map to 0, 1, or more columns of any of the experimental data matrices. therefore you could treat replicate observations as one or multiple rows of colData, and this will result in different behaviors of functions you will learn later like subsetting, duplicated(), and wideFormat(). multiple time points, or distinct biological replicates, should probably be separate rows of the colData. 10.7.3 ExperimentList - experiment data A base list or ExperimentList object containing the experimental datasets for the set of samples collected. This gets converted into a class ExperimentList during construction. experiments(miniACC) #&gt; ExperimentList class object of length 5: #&gt; [1] RNASeq2GeneNorm: SummarizedExperiment with 198 rows and 79 columns #&gt; [2] gistict: SummarizedExperiment with 198 rows and 90 columns #&gt; [3] RPPAArray: SummarizedExperiment with 33 rows and 46 columns #&gt; [4] Mutations: matrix with 97 rows and 90 columns #&gt; [5] miRNASeqGene: SummarizedExperiment with 471 rows and 80 columns Key points: One matrix-like dataset per list element (although they do not even need to be matrix-like, see for example the RaggedExperiment package) One matrix column per assayed specimen. Each matrix column must correspond to exactly one row of colData: in other words, you must know which patient or cell line the observation came from. However, multiple columns can come from the same patient, or there can be no data for that patient. Matrix rows correspond to variables, e.g. genes or genomic ranges ExperimentList elements can be genomic range-based (e.g. SummarizedExperiment::RangedSummarizedExperiment-class or RaggedExperiment::RaggedExperiment-class) or ID-based data (e.g. SummarizedExperiment::SummarizedExperiment-class, Biobase::eSet-class base::matrix-class, DelayedArray::DelayedArray-class, and derived classes) Any data class can be included in the ExperimentList, as long as it supports: single-bracket subsetting ([), dimnames, and dim. Most data classes defined in Bioconductor meet these requirements. 10.7.4 sampleMap - relationship graph sampleMap is a graph representation of the relationship between biological units and experimental results. In simple cases where the column names of ExperimentList data matrices match the row names of colData, the user won’t need to specify or think about a sample map, it can be created automatically by the MultiAssayExperiment constructor. sampleMap is a simple three-column DataFrame: assay column: the name of the assay, and found in the names of ExperimentList list names primary column: identifiers of patients or biological units, and found in the row names of colData colname column: identifiers of assay results, and found in the column names of ExperimentList elements Helper functions are available for creating a map from a list. See ?listToMap sampleMap(miniACC) #&gt; DataFrame with 385 rows and 3 columns #&gt; assay primary colname #&gt; &lt;factor&gt; &lt;character&gt; &lt;character&gt; #&gt; 1 RNASeq2GeneNorm TCGA-OR-A5J1 TCGA-OR-A5J1-01A-11R-A29S-07 #&gt; 2 RNASeq2GeneNorm TCGA-OR-A5J2 TCGA-OR-A5J2-01A-11R-A29S-07 #&gt; 3 RNASeq2GeneNorm TCGA-OR-A5J3 TCGA-OR-A5J3-01A-11R-A29S-07 #&gt; 4 RNASeq2GeneNorm TCGA-OR-A5J5 TCGA-OR-A5J5-01A-11R-A29S-07 #&gt; 5 RNASeq2GeneNorm TCGA-OR-A5J6 TCGA-OR-A5J6-01A-31R-A29S-07 #&gt; ... ... ... ... #&gt; 381 miRNASeqGene TCGA-PA-A5YG TCGA-PA-A5YG-01A-11R-A29W-13 #&gt; 382 miRNASeqGene TCGA-PK-A5H8 TCGA-PK-A5H8-01A-11R-A29W-13 #&gt; 383 miRNASeqGene TCGA-PK-A5H9 TCGA-PK-A5H9-01A-11R-A29W-13 #&gt; 384 miRNASeqGene TCGA-PK-A5HA TCGA-PK-A5HA-01A-11R-A29W-13 #&gt; 385 miRNASeqGene TCGA-PK-A5HB TCGA-PK-A5HB-01A-11R-A29W-13 Key points: relates experimental observations (colnames) to colData permits experiment-specific sample naming, missing, and replicate observations back to top 10.7.5 metadata Metadata can be used to keep additional information about patients, assays performed on individuals or on the entire cohort, or features such as genes, proteins, and genomic ranges. There are many options available for storing metadata. First, MultiAssayExperiment has its own metadata for describing the entire experiment: metadata(miniACC) #&gt; $title #&gt; [1] &quot;Comprehensive Pan-Genomic Characterization of Adrenocortical Carcinoma&quot; #&gt; #&gt; $PMID #&gt; [1] &quot;27165744&quot; #&gt; #&gt; $sourceURL #&gt; [1] &quot;http://s3.amazonaws.com/multiassayexperiments/accMAEO.rds&quot; #&gt; #&gt; $RPPAfeatureDataURL #&gt; [1] &quot;http://genomeportal.stanford.edu/pan-tcga/show_target_selection_file?filename=Allprotein.txt&quot; #&gt; #&gt; $colDataExtrasURL #&gt; [1] &quot;http://www.cell.com/cms/attachment/2062093088/2063584534/mmc3.xlsx&quot; Additionally, the DataFrame class used by sampleMap and colData, as well as the ExperimentList class, similarly support metadata. Finally, many experimental data objects that can be used in the ExperimentList support metadata. These provide flexible options to users and to developers of derived classes. 10.8 MultiAssayExperiment Subsetting 10.8.1 Single bracket [ In pseudo code below, the subsetting operations work on the rows of the following indices: 1. i experimental data rows 2. j the primary names or the column names (entered as a list or List) 3. k assay multiassayexperiment[i = rownames, j = primary or colnames, k = assay] Subsetting operations always return another MultiAssayExperiment. For example, the following will return any rows named “MAPK14” or “IGFBP2”, and remove any assays where no rows match: miniACC[c(&quot;MAPK14&quot;, &quot;IGFBP2&quot;), , ] The following will keep only patients of pathological stage iv, and all their associated assays: miniACC[, miniACC$pathologic_stage == &quot;stage iv&quot;, ] #&gt; harmonizing input: #&gt; removing 311 sampleMap rows with &#39;colname&#39; not in colnames of experiments #&gt; removing 74 colData rownames not in sampleMap &#39;primary&#39; And the following will keep only the RNA-seq dataset, and only patients for which this assay is available: miniACC[, , &quot;RNASeq2GeneNorm&quot;] #&gt; harmonizing input: #&gt; removing 13 colData rownames not in sampleMap &#39;primary&#39; 10.8.2 Subsetting by genomic ranges If any ExperimentList objects have features represented by genomic ranges (e.g. RangedSummarizedExperiment, RaggedExperiment), then a GRanges object in the first subsetting position will subset these objects as in GenomicRanges::findOverlaps(). Any non-ranged ExperimentList element will be subset to zero rows. 10.8.3 Double bracket [[ The “double bracket” method ([[) is a convenience function for extracting a single element of the MultiAssayExperiment ExperimentList. It avoids the use of experiments(mae)[[1L]]. For example, both of the following extract the ExpressionSet object containing RNA-seq data: miniACC[[1L]] #or equivalently, miniACC[[&quot;RNASeq2GeneNorm&quot;]] #&gt; class: SummarizedExperiment #&gt; dim: 198 79 #&gt; metadata(3): experimentData annotation protocolData #&gt; assays(1): exprs #&gt; rownames(198): DIRAS3 MAPK14 ... SQSTM1 KCNJ13 #&gt; rowData names(0): #&gt; colnames(79): TCGA-OR-A5J1-01A-11R-A29S-07 #&gt; TCGA-OR-A5J2-01A-11R-A29S-07 ... TCGA-PK-A5HA-01A-11R-A29S-07 #&gt; TCGA-PK-A5HB-01A-11R-A29S-07 #&gt; colData names(0): 10.9 Complete cases complete.cases() shows which patients have complete data for all assays: summary(complete.cases(miniACC)) #&gt; Mode FALSE TRUE #&gt; logical 49 43 The above logical vector could be used for patient subsetting. More simply, intersectColumns() will select complete cases and rearrange each ExperimentList element so its columns correspond exactly to rows of colData in the same order: accmatched = intersectColumns(miniACC) #&gt; harmonizing input: #&gt; removing 170 sampleMap rows with &#39;colname&#39; not in colnames of experiments #&gt; removing 49 colData rownames not in sampleMap &#39;primary&#39; Note, the column names of the assays in accmatched are not the same because of assay-specific identifiers, but they have been automatically re-arranged to correspond to the same patients. In these TCGA assays, the first three - delimited positions correspond to patient, ie the first patient is TCGA-OR-A5J2: colnames(accmatched) #&gt; CharacterList of length 5 #&gt; [[&quot;RNASeq2GeneNorm&quot;]] TCGA-OR-A5J2-01A-11R-A29S-07 ... #&gt; [[&quot;gistict&quot;]] TCGA-OR-A5J2-01A-11D-A29H-01 ... #&gt; [[&quot;RPPAArray&quot;]] TCGA-OR-A5J2-01A-21-A39K-20 ... #&gt; [[&quot;Mutations&quot;]] TCGA-OR-A5J2-01A-11D-A29I-10 ... #&gt; [[&quot;miRNASeqGene&quot;]] TCGA-OR-A5J2-01A-11R-A29W-13 ... 10.10 Row names that are common across assays intersectRows() keeps only rows that are common to each assay, and aligns them in identical order. For example, to keep only genes where data are available for RNA-seq, GISTIC copy number, and somatic mutations: accmatched2 &lt;- intersectRows(miniACC[, , c(&quot;RNASeq2GeneNorm&quot;, &quot;gistict&quot;, &quot;Mutations&quot;)]) rownames(accmatched2) #&gt; CharacterList of length 3 #&gt; [[&quot;RNASeq2GeneNorm&quot;]] DIRAS3 G6PD KDR ERBB3 ... RET CDKN2A MACC1 CHGA #&gt; [[&quot;gistict&quot;]] DIRAS3 G6PD KDR ERBB3 AKT1S1 ... PREX1 RET CDKN2A MACC1 CHGA #&gt; [[&quot;Mutations&quot;]] DIRAS3 G6PD KDR ERBB3 AKT1S1 ... RET CDKN2A MACC1 CHGA back to top 10.11 Extraction 10.11.1 assay and assays The assay and assays methods follow SummarizedExperiment convention. The assay (singular) method will extract the first element of the ExperimentList and will return a matrix. class(assay(miniACC)) #&gt; [1] &quot;matrix&quot; The assays (plural) method will return a SimpleList of the data with each element being a matrix. assays(miniACC) #&gt; List of length 5 #&gt; names(5): RNASeq2GeneNorm gistict RPPAArray Mutations miRNASeqGene Key point: Whereas the [[ returned an assay as its original class, assay() and assays() convert the assay data to matrix form. back to top 10.12 Summary of slots and accessors Slot in the MultiAssayExperiment can be accessed or set using their accessor functions: Slot Accessor ExperimentList experiments() colData colData() and $ * sampleMap sampleMap() metadata metadata() __*__ The $ operator on a MultiAssayExperiment returns a single column of the colData. 10.13 Transformation / reshaping The longFormat or wideFormat functions will “reshape” and combine experiments with each other and with colData into one DataFrame. These functions provide compatibility with most of the common R/Bioconductor functions for regression, machine learning, and visualization. 10.13.1 longFormat In long format a single column provides all assay results, with additional optional colData columns whose values are repeated as necessary. Here assay is the name of the ExperimentList element, primary is the patient identifier (rowname of colData), rowname is the assay rowname (in this case genes), colname is the assay-specific identifier (column name), value is the numeric measurement (gene expression, copy number, presence of a non-silent mutation, etc), and following these are the vital_status and days_to_death colData columns that have been added: longFormat(miniACC[c(&quot;TP53&quot;, &quot;CTNNB1&quot;), , ], colDataCols = c(&quot;vital_status&quot;, &quot;days_to_death&quot;)) #&gt; DataFrame with 518 rows and 7 columns #&gt; assay primary rowname colname #&gt; &lt;character&gt; &lt;character&gt; &lt;character&gt; &lt;character&gt; #&gt; 1 RNASeq2GeneNorm TCGA-OR-A5J1 TP53 TCGA-OR-A5J1-01A-11R-A29S-07 #&gt; 2 RNASeq2GeneNorm TCGA-OR-A5J1 CTNNB1 TCGA-OR-A5J1-01A-11R-A29S-07 #&gt; 3 RNASeq2GeneNorm TCGA-OR-A5J2 TP53 TCGA-OR-A5J2-01A-11R-A29S-07 #&gt; 4 RNASeq2GeneNorm TCGA-OR-A5J2 CTNNB1 TCGA-OR-A5J2-01A-11R-A29S-07 #&gt; 5 RNASeq2GeneNorm TCGA-OR-A5J3 TP53 TCGA-OR-A5J3-01A-11R-A29S-07 #&gt; ... ... ... ... ... #&gt; 514 Mutations TCGA-PK-A5HA CTNNB1 TCGA-PK-A5HA-01A-11D-A29I-10 #&gt; 515 Mutations TCGA-PK-A5HB TP53 TCGA-PK-A5HB-01A-11D-A29I-10 #&gt; 516 Mutations TCGA-PK-A5HB CTNNB1 TCGA-PK-A5HB-01A-11D-A29I-10 #&gt; 517 Mutations TCGA-PK-A5HC TP53 TCGA-PK-A5HC-01A-11D-A30A-10 #&gt; 518 Mutations TCGA-PK-A5HC CTNNB1 TCGA-PK-A5HC-01A-11D-A30A-10 #&gt; value vital_status days_to_death #&gt; &lt;numeric&gt; &lt;integer&gt; &lt;integer&gt; #&gt; 1 563.4006 1 1355 #&gt; 2 5634.4669 1 1355 #&gt; 3 165.4811 1 1677 #&gt; 4 62658.3913 1 1677 #&gt; 5 956.3028 0 NA #&gt; ... ... ... ... #&gt; 514 0 0 NA #&gt; 515 0 0 NA #&gt; 516 0 0 NA #&gt; 517 0 0 NA #&gt; 518 0 0 NA 10.13.2 wideFormat In wide format, each feature from each assay goes in a separate column, with one row per primary identifier (patient). Here, each variable becomes a new column: wideFormat(miniACC[c(&quot;TP53&quot;, &quot;CTNNB1&quot;), , ], colDataCols = c(&quot;vital_status&quot;, &quot;days_to_death&quot;)) #&gt; DataFrame with 92 rows and 9 columns #&gt; primary vital_status days_to_death RNASeq2GeneNorm_CTNNB1 #&gt; &lt;character&gt; &lt;integer&gt; &lt;integer&gt; &lt;numeric&gt; #&gt; 1 TCGA-OR-A5J1 1 1355 5634.4669 #&gt; 2 TCGA-OR-A5J2 1 1677 62658.3913 #&gt; 3 TCGA-OR-A5J3 0 NA 6337.4256 #&gt; 4 TCGA-OR-A5J4 1 423 NA #&gt; 5 TCGA-OR-A5J5 1 365 5979.055 #&gt; ... ... ... ... ... #&gt; 88 TCGA-PK-A5H9 0 NA 5258.9863 #&gt; 89 TCGA-PK-A5HA 0 NA 8120.1654 #&gt; 90 TCGA-PK-A5HB 0 NA 5257.8148 #&gt; 91 TCGA-PK-A5HC 0 NA NA #&gt; 92 TCGA-P6-A5OG 1 383 6390.0997 #&gt; RNASeq2GeneNorm_TP53 gistict_CTNNB1 gistict_TP53 Mutations_CTNNB1 #&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; #&gt; 1 563.4006 0 0 0 #&gt; 2 165.4811 1 0 1 #&gt; 3 956.3028 0 0 0 #&gt; 4 NA 0 1 0 #&gt; 5 1169.6359 0 0 0 #&gt; ... ... ... ... ... #&gt; 88 890.8663 0 0 0 #&gt; 89 683.5722 0 -1 0 #&gt; 90 237.3697 -1 -1 0 #&gt; 91 NA 1 1 0 #&gt; 92 815.3446 1 -1 NA #&gt; Mutations_TP53 #&gt; &lt;numeric&gt; #&gt; 1 0 #&gt; 2 1 #&gt; 3 0 #&gt; 4 0 #&gt; 5 0 #&gt; ... ... #&gt; 88 0 #&gt; 89 0 #&gt; 90 0 #&gt; 91 0 #&gt; 92 NA 10.14 MultiAssayExperiment class construction and concatenation 10.14.1 MultiAssayExperiment constructor function The MultiAssayExperiment constructor function can take three arguments: experiments - An ExperimentList or list of data colData - A DataFrame describing the patients (or cell lines, or other biological units) sampleMap - A DataFrame of assay, primary, and colname identifiers The miniACC object can be reconstructed as follows: MultiAssayExperiment(experiments=experiments(miniACC), colData=colData(miniACC), sampleMap=sampleMap(miniACC), metadata=metadata(miniACC)) #&gt; A MultiAssayExperiment object of 5 listed #&gt; experiments with user-defined names and respective classes. #&gt; Containing an ExperimentList class object of length 5: #&gt; [1] RNASeq2GeneNorm: SummarizedExperiment with 198 rows and 79 columns #&gt; [2] gistict: SummarizedExperiment with 198 rows and 90 columns #&gt; [3] RPPAArray: SummarizedExperiment with 33 rows and 46 columns #&gt; [4] Mutations: matrix with 97 rows and 90 columns #&gt; [5] miRNASeqGene: SummarizedExperiment with 471 rows and 80 columns #&gt; Features: #&gt; experiments() - obtain the ExperimentList instance #&gt; colData() - the primary/phenotype DataFrame #&gt; sampleMap() - the sample availability DataFrame #&gt; `$`, `[`, `[[` - extract colData columns, subset, or experiment #&gt; *Format() - convert into a long or wide DataFrame #&gt; assays() - convert ExperimentList to a SimpleList of matrices 10.14.2 prepMultiAssay - Constructor function helper The prepMultiAssay function allows the user to diagnose typical problems when creating a MultiAssayExperiment object. See ?prepMultiAssay for more details. 10.14.3 c - concatenate to MultiAssayExperiment The c function allows the user to concatenate an additional experiment to an existing MultiAssayExperiment. The optional sampleMap argument allows concatenating an assay whose column names do not match the row names of colData. For convenience, the mapFrom argument allows the user to map from a particular experiment provided that the order of the colnames is in the same. A warning will be issued to make the user aware of this assumption. For example, to concatenate a matrix of log2-transformed RNA-seq results: miniACC2 &lt;- c(miniACC, log2rnaseq = log2(assays(miniACC)$RNASeq2GeneNorm), mapFrom=1L) #&gt; Warning in .local(x, ...): Assuming column order in the data provided #&gt; matches the order in &#39;mapFrom&#39; experiment(s) colnames experiments(miniACC2) #&gt; ExperimentList class object of length 6: #&gt; [1] RNASeq2GeneNorm: SummarizedExperiment with 198 rows and 79 columns #&gt; [2] gistict: SummarizedExperiment with 198 rows and 90 columns #&gt; [3] RPPAArray: SummarizedExperiment with 33 rows and 46 columns #&gt; [4] Mutations: matrix with 97 rows and 90 columns #&gt; [5] miRNASeqGene: SummarizedExperiment with 471 rows and 80 columns #&gt; [6] log2rnaseq: matrix with 198 rows and 79 columns back to top 10.14.4 Building a MultiAssayExperiment from scratch To start from scratch building your own MultiAssayExperiment, see the package Coordinating Analysis of Multi-Assay Experiments vignette. The package cheat sheet is also helpful. If anything is unclear, please ask a question at https://support.bioconductor.org/ or create an issue on the MultiAssayExperiment issue tracker. 10.15 The Cancer Genome Atlas (TCGA) as MultiAssayExperiment objects Most unrestricted TCGA data are available as MultiAssayExperiment objects from the curatedTCGAData package. This represents a lot of harmonization! library(curatedTCGAData) curatedTCGAData(&quot;ACC&quot;) #&gt; ACC_CNASNP #&gt; &quot;ACC_CNASNP-20160128.rda&quot; #&gt; ACC_CNVSNP #&gt; &quot;ACC_CNVSNP-20160128.rda&quot; #&gt; ACC_GISTIC_AllByGene #&gt; &quot;ACC_GISTIC_AllByGene-20160128.rda&quot; #&gt; ACC_GISTIC_ThresholdedByGene #&gt; &quot;ACC_GISTIC_ThresholdedByGene-20160128.rda&quot; #&gt; ACC_Methylation #&gt; &quot;ACC_Methylation-20160128.rda&quot; #&gt; ACC_miRNASeqGene #&gt; &quot;ACC_miRNASeqGene-20160128.rda&quot; #&gt; ACC_Mutation #&gt; &quot;ACC_Mutation-20160128.rda&quot; #&gt; ACC_RNASeq2GeneNorm #&gt; &quot;ACC_RNASeq2GeneNorm-20160128.rda&quot; #&gt; ACC_RPPAArray #&gt; &quot;ACC_RPPAArray-20160128.rda&quot; suppressMessages({ acc &lt;- curatedTCGAData(&quot;ACC&quot;, assays = c(&quot;miRNASeqGene&quot;, &quot;RPPAArray&quot;, &quot;Mutation&quot;, &quot;RNASeq2GeneNorm&quot;, &quot;CNVSNP&quot;), dry.run = FALSE) }) acc #&gt; A MultiAssayExperiment object of 5 listed #&gt; experiments with user-defined names and respective classes. #&gt; Containing an ExperimentList class object of length 5: #&gt; [1] ACC_CNVSNP-20160128: RaggedExperiment with 21052 rows and 180 columns #&gt; [2] ACC_miRNASeqGene-20160128: SummarizedExperiment with 1046 rows and 80 columns #&gt; [3] ACC_Mutation-20160128: RaggedExperiment with 20166 rows and 90 columns #&gt; [4] ACC_RNASeq2GeneNorm-20160128: SummarizedExperiment with 20501 rows and 79 columns #&gt; [5] ACC_RPPAArray-20160128: SummarizedExperiment with 192 rows and 46 columns #&gt; Features: #&gt; experiments() - obtain the ExperimentList instance #&gt; colData() - the primary/phenotype DataFrame #&gt; sampleMap() - the sample availability DataFrame #&gt; `$`, `[`, `[[` - extract colData columns, subset, or experiment #&gt; *Format() - convert into a long or wide DataFrame #&gt; assays() - convert ExperimentList to a SimpleList of matrices These objects contain most unrestricted TCGA assay and clinical / pathological data, as well as material curated from the supplements of published TCGA primary papers at the end of the colData columns: dim(colData(acc)) #&gt; [1] 92 822 tail(colnames(colData(acc)), 10) #&gt; [1] &quot;MethyLevel&quot; &quot;miRNA.cluster&quot; &quot;SCNA.cluster&quot; #&gt; [4] &quot;protein.cluster&quot; &quot;COC&quot; &quot;OncoSign&quot; #&gt; [7] &quot;purity&quot; &quot;ploidy&quot; &quot;genome_doublings&quot; #&gt; [10] &quot;ADS&quot; The TCGAutils package provides additional helper functions, see below. 10.16 Utilities for TCGA Aside from the available reshaping functions already included in the MultiAssayExperiment package, the TCGAutils package provides additional helper functions for working with TCGA data. 10.16.1 “Simplification” of curatedTCGAData objects A number of helper functions are available for managing datasets from curatedTCGAData. These include: Conversions of SummarizedExperiment to RangedSummarizedExperiment based on TxDb.Hsapiens.UCSC.hg19.knownGene for: mirToRanges: microRNA symbolsToRanges: gene symbols qreduceTCGA: convert RaggedExperiment objects to RangedSummarizedExperiment with one row per gene symbol, for: segmented copy number datasets (“CNVSNP” and “CNASNP”) somatic mutation datasets (“Mutation”), with a value of 1 for any non-silent mutation and a value of 0 for no mutation or silent mutation The simplifyTCGA function combines all of the above operations to create a more managable MultiAssayExperiment object and using RangedSummarizedExperiment assays where possible. (simpa &lt;- TCGAutils::simplifyTCGA(acc)) #&gt; #&gt; &#39;select()&#39; returned 1:1 mapping between keys and columns #&gt; &#39;select()&#39; returned 1:many mapping between keys and columns #&gt; &#39;select()&#39; returned 1:1 mapping between keys and columns #&gt; A MultiAssayExperiment object of 7 listed #&gt; experiments with user-defined names and respective classes. #&gt; Containing an ExperimentList class object of length 7: #&gt; [1] ACC_RPPAArray-20160128: SummarizedExperiment with 192 rows and 46 columns #&gt; [2] ACC_Mutation-20160128_simplified: RangedSummarizedExperiment with 22945 rows and 90 columns #&gt; [3] ACC_CNVSNP-20160128_simplified: RangedSummarizedExperiment with 22945 rows and 180 columns #&gt; [4] ACC_miRNASeqGene-20160128_ranged: RangedSummarizedExperiment with 1002 rows and 80 columns #&gt; [5] ACC_miRNASeqGene-20160128_unranged: SummarizedExperiment with 44 rows and 80 columns #&gt; [6] ACC_RNASeq2GeneNorm-20160128_ranged: RangedSummarizedExperiment with 17594 rows and 79 columns #&gt; [7] ACC_RNASeq2GeneNorm-20160128_unranged: SummarizedExperiment with 2907 rows and 79 columns #&gt; Features: #&gt; experiments() - obtain the ExperimentList instance #&gt; colData() - the primary/phenotype DataFrame #&gt; sampleMap() - the sample availability DataFrame #&gt; `$`, `[`, `[[` - extract colData columns, subset, or experiment #&gt; *Format() - convert into a long or wide DataFrame #&gt; assays() - convert ExperimentList to a SimpleList of matrices 10.16.2 What types of samples are in the data? Solution The sampleTables function gives you an overview of samples in each assay: sampleTables(acc) #&gt; $`ACC_CNVSNP-20160128` #&gt; #&gt; 01 10 11 #&gt; 90 85 5 #&gt; #&gt; $`ACC_miRNASeqGene-20160128` #&gt; #&gt; 01 #&gt; 80 #&gt; #&gt; $`ACC_Mutation-20160128` #&gt; #&gt; 01 #&gt; 90 #&gt; #&gt; $`ACC_RNASeq2GeneNorm-20160128` #&gt; #&gt; 01 #&gt; 79 #&gt; #&gt; $`ACC_RPPAArray-20160128` #&gt; #&gt; 01 #&gt; 46 head(sampleTypes) #&gt; Code Definition Short.Letter.Code #&gt; 1 01 Primary Solid Tumor TP #&gt; 2 02 Recurrent Solid Tumor TR #&gt; 3 03 Primary Blood Derived Cancer - Peripheral Blood TB #&gt; 4 04 Recurrent Blood Derived Cancer - Bone Marrow TRBM #&gt; 5 05 Additional - New Primary TAP #&gt; 6 06 Metastatic TM 10.16.3 Curated molecular subtypes Is there subtype data available in the MultiAssayExperiment obtained from curatedTCGAData? Solution The getSubtypeMap function will show actual variable names found in colData that contain subtype information. This can only be obtained from MultiAssayExperiment objects provided by curatedTCGAData. getSubtypeMap(acc) #&gt; ACC_annotations ACC_subtype #&gt; 1 Patient_ID SAMPLE #&gt; 2 histological_subtypes Histology #&gt; 3 mrna_subtypes C1A/C1B #&gt; 4 mrna_subtypes mRNA_K4 #&gt; 5 cimp MethyLevel #&gt; 6 microrna_subtypes miRNA cluster #&gt; 7 scna_subtypes SCNA cluster #&gt; 8 protein_subtypes protein cluster #&gt; 9 integrative_subtypes COC #&gt; 10 mutation_subtypes OncoSign head(colData(acc)$Histology) #&gt; [1] &quot;Usual Type&quot; &quot;Usual Type&quot; &quot;Usual Type&quot; &quot;Usual Type&quot; &quot;Usual Type&quot; #&gt; [6] &quot;Usual Type&quot; 10.16.4 Converting TCGA UUIDs to barcodes and back TCGAutils provides a number of ID translation functions. These allow the user to translate from either file or case UUIDs to TCGA barcodes and back. These functions work by querying the Genomic Data Commons API via the GenomicDataCommons package (thanks to Sean Davis). These include: UUIDtoBarcode() barcodeToUUID() UUIDtoUUID() filenameToBarcode() See the TCGAutils help pages for details. 10.16.5 Other TCGA data types Helper functions to add TCGA exon files (legacy archive), copy number and GISTIC copy number calls to MultiAssayExperiment objects are also available in TCGAutils. 10.17 Plotting, correlation, and other analyses These provide exercises and solutions using the miniACC dataset. 10.17.1 How many miniACC samples have data for each combination of assays? Solution The built-in upsetSamples creates an “upset” Venn diagram to answer this question: upsetSamples(miniACC) In this dataset only 43 samples have all 5 assays, 32 are missing reverse-phase protein (RPPAArray), 2 are missing Mutations, 1 is missing gistict, 12 have only mutations and gistict, etc. 10.17.2 Kaplan-meier plot stratified by pathology_N_stage Create a Kaplan-meier plot, using pathology_N_stage as a stratifying variable. Solution The colData provides clinical data for things like a Kaplan-Meier plot for overall survival stratified by nodal stage. Surv(miniACC$days_to_death, miniACC$vital_status) #&gt; [1] 1355 1677 NA+ 423 365 NA+ 490 579 NA+ 922 551 #&gt; [12] 1750 NA+ 2105 NA+ 541 NA+ NA+ 490 NA+ NA+ 562 #&gt; [23] NA+ NA+ NA+ NA+ NA+ NA+ 289 NA+ NA+ NA+ 552 #&gt; [34] NA+ NA+ NA+ 994 NA+ NA+ 498 NA+ NA+ 344 NA+ #&gt; [45] NA+ NA+ NA+ NA+ NA+ NA+ NA+ NA+ NA+ 391 125 #&gt; [56] NA+ 1852 NA+ NA+ NA+ NA+ NA+ NA+ NA+ 1204 159 #&gt; [67] 1197 662 445 NA+ 2385 436 1105 NA+ 1613 NA+ NA+ #&gt; [78] 2405 NA+ NA+ NA+ NA+ NA+ 207 0 NA+ NA+ NA+ #&gt; [89] NA+ NA+ NA+ 383 And remove any patients missing overall survival information: miniACCsurv &lt;- miniACC[, complete.cases(miniACC$days_to_death, miniACC$vital_status), ] #&gt; harmonizing input: #&gt; removing 248 sampleMap rows with &#39;colname&#39; not in colnames of experiments #&gt; removing 58 colData rownames not in sampleMap &#39;primary&#39; fit &lt;- survfit(Surv(days_to_death, vital_status) ~ pathology_N_stage, data = colData(miniACCsurv)) ggsurvplot(fit, data = colData(miniACCsurv), risk.table = TRUE) 10.17.3 Multivariate Cox regression including RNA-seq, copy number, and pathology Choose the EZH2 gene for demonstration. This subsetting will drop assays with no row named EZH2: wideacc = wideFormat(miniACC[&quot;EZH2&quot;, , ], colDataCols=c(&quot;vital_status&quot;, &quot;days_to_death&quot;, &quot;pathology_N_stage&quot;)) wideacc$y = Surv(wideacc$days_to_death, wideacc$vital_status) head(wideacc) #&gt; DataFrame with 6 rows and 7 columns #&gt; primary vital_status days_to_death pathology_N_stage #&gt; &lt;character&gt; &lt;integer&gt; &lt;integer&gt; &lt;character&gt; #&gt; 1 TCGA-OR-A5J1 1 1355 n0 #&gt; 2 TCGA-OR-A5J2 1 1677 n0 #&gt; 3 TCGA-OR-A5J3 0 NA n0 #&gt; 4 TCGA-OR-A5J4 1 423 n1 #&gt; 5 TCGA-OR-A5J5 1 365 n0 #&gt; 6 TCGA-OR-A5J6 0 NA n0 #&gt; RNASeq2GeneNorm_EZH2 gistict_EZH2 y #&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;Surv&gt; #&gt; 1 75.8886 0 1355:1 #&gt; 2 326.5332 1 1677:1 #&gt; 3 190.194 1 NA:0 #&gt; 4 NA -2 423:1 #&gt; 5 366.3826 1 365:1 #&gt; 6 30.7371 1 NA:0 Perform a multivariate Cox regression with EZH2 copy number (gistict), log2-transformed EZH2 expression (RNASeq2GeneNorm), and nodal status (pathology_N_stage) as predictors: coxph(Surv(days_to_death, vital_status) ~ gistict_EZH2 + log2(RNASeq2GeneNorm_EZH2) + pathology_N_stage, data=wideacc) #&gt; Call: #&gt; coxph(formula = Surv(days_to_death, vital_status) ~ gistict_EZH2 + #&gt; log2(RNASeq2GeneNorm_EZH2) + pathology_N_stage, data = wideacc) #&gt; #&gt; coef exp(coef) se(coef) z p #&gt; gistict_EZH2 -0.0372 0.9635 0.2821 -0.13 0.89499 #&gt; log2(RNASeq2GeneNorm_EZH2) 0.9773 2.6573 0.2811 3.48 0.00051 #&gt; pathology_N_stagen1 0.3775 1.4586 0.5699 0.66 0.50774 #&gt; #&gt; Likelihood ratio test=16.28 on 3 df, p=0.001 #&gt; n= 26, number of events= 26 #&gt; (66 observations deleted due to missingness) We see that EZH2 expression is significantly associated with overal survival (p &lt; 0.001), but EZH2 copy number and nodal status are not. This analysis could easily be extended to the whole genome for discovery of prognostic features by repeated univariate regressions over columns, penalized multivariate regression, etc. For further detail, see the main MultiAssayExperiment vignette. back to top 10.17.4 Correlation between RNA-seq and copy number Part 1 For all genes where there is both recurrent copy number (gistict assay) and RNA-seq, calculate the correlation between log2(RNAseq + 1) and copy number. Create a histogram of these correlations. Compare this with the histogram of correlations between all unmatched gene - copy number pairs. Solution First, narrow down miniACC to only the assays needed: subacc &lt;- miniACC[, , c(&quot;RNASeq2GeneNorm&quot;, &quot;gistict&quot;)] Align the rows and columns, keeping only samples with both assays available: subacc &lt;- intersectColumns(subacc) #&gt; harmonizing input: #&gt; removing 15 sampleMap rows with &#39;colname&#39; not in colnames of experiments #&gt; removing 15 colData rownames not in sampleMap &#39;primary&#39; subacc &lt;- intersectRows(subacc) Create a list of numeric matrices: subacc.list &lt;- assays(subacc) Log-transform the RNA-seq assay: subacc.list[[1]] &lt;- log2(subacc.list[[1]] + 1) Transpose both, so genes are in columns: subacc.list &lt;- lapply(subacc.list, t) Calculate the correlation between columns in the first matrix and columns in the second matrix: corres &lt;- cor(subacc.list[[1]], subacc.list[[2]]) And finally, create the histograms: hist(diag(corres)) hist(corres[upper.tri(corres)]) Part 2 For the gene with highest correlation to copy number, make a box plot of log2 expression against copy number. Solution First, identify the gene with highest correlation between expression and copy number: which.max(diag(corres)) #&gt; EIF4E #&gt; 91 You could now make the plot by taking the EIF4E columns from each element of the list subacc.list list that was extracted from the subacc MultiAssayExperiment, but let’s do it by subsetting and extracting from the MultiAssayExperiment: df &lt;- wideFormat(subacc[&quot;EIF4E&quot;, , ]) head(df) #&gt; DataFrame with 6 rows and 3 columns #&gt; primary RNASeq2GeneNorm_EIF4E gistict_EIF4E #&gt; &lt;character&gt; &lt;numeric&gt; &lt;numeric&gt; #&gt; 1 TCGA-OR-A5J1 460.6148 0 #&gt; 2 TCGA-OR-A5J2 371.2252 0 #&gt; 3 TCGA-OR-A5J3 516.0717 0 #&gt; 4 TCGA-OR-A5J5 1129.3571 1 #&gt; 5 TCGA-OR-A5J6 822.0782 0 #&gt; 6 TCGA-OR-A5J7 344.5648 -1 boxplot(RNASeq2GeneNorm_EIF4E ~ gistict_EIF4E, data=df, varwidth=TRUE, xlab=&quot;GISTIC Relative Copy Number Call&quot;, ylab=&quot;RNA-seq counts&quot;) back to top 10.17.5 Identifying correlated principal components Perform Principal Components Analysis of each of the five assays, using samples available on each assay, log-transforming RNA-seq data first. Using the first 10 components, calculate Pearson correlation between all scores and plot these correlations as a heatmap to identify correlated components across assays. Solution Here’s a function to simplify doing the PCAs: getLoadings &lt;- function(x, ncomp=10, dolog=FALSE, center=TRUE, scale.=TRUE){ if(dolog){ x &lt;- log2(x + 1) } pc = prcomp(x, center=center, scale.=scale.) return(t(pc$rotation[, 1:10])) } Although it would be possible to do the following with a loop, the different data types do require different options for PCA (e.g. mutations are a 0/1 matrix with 1 meaning there is a somatic mutation, and gistict varies between -2 for homozygous loss and 2 for a genome doubling, so neither make sense to scale and center). So it is just as well to do the following one by one, concatenating each PCA results to the MultiAssayExperiment: miniACC2 &lt;- intersectColumns(miniACC) #&gt; harmonizing input: #&gt; removing 170 sampleMap rows with &#39;colname&#39; not in colnames of experiments #&gt; removing 49 colData rownames not in sampleMap &#39;primary&#39; miniACC2 &lt;- c(miniACC2, rnaseqPCA=getLoadings(assays(miniACC2)[[1]], dolog=TRUE), mapFrom=1L) #&gt; Warning in .local(x, ...): Assuming column order in the data provided #&gt; matches the order in &#39;mapFrom&#39; experiment(s) colnames miniACC2 &lt;- c(miniACC2, gistictPCA=getLoadings(assays(miniACC2)[[2]], center=FALSE, scale.=FALSE), mapFrom=2L) #&gt; Warning in .local(x, ...): Assuming column order in the data provided #&gt; matches the order in &#39;mapFrom&#39; experiment(s) colnames miniACC2 &lt;- c(miniACC2, proteinPCA=getLoadings(assays(miniACC2)[[3]]), mapFrom=3L) #&gt; Warning in .local(x, ...): Assuming column order in the data provided #&gt; matches the order in &#39;mapFrom&#39; experiment(s) colnames miniACC2 &lt;- c(miniACC2, mutationsPCA=getLoadings(assays(miniACC2)[[4]], center=FALSE, scale.=FALSE), mapFrom=4L) #&gt; Warning in .local(x, ...): Assuming column order in the data provided #&gt; matches the order in &#39;mapFrom&#39; experiment(s) colnames miniACC2 &lt;- c(miniACC2, miRNAPCA=getLoadings(assays(miniACC2)[[5]]), mapFrom=5L) #&gt; Warning in .local(x, ...): Assuming column order in the data provided #&gt; matches the order in &#39;mapFrom&#39; experiment(s) colnames Now subset to keep only the PCA results: miniACC2 &lt;- miniACC2[, , 6:10] experiments(miniACC2) #&gt; ExperimentList class object of length 5: #&gt; [1] rnaseqPCA: matrix with 10 rows and 43 columns #&gt; [2] gistictPCA: matrix with 10 rows and 43 columns #&gt; [3] proteinPCA: matrix with 10 rows and 43 columns #&gt; [4] mutationsPCA: matrix with 10 rows and 43 columns #&gt; [5] miRNAPCA: matrix with 10 rows and 43 columns Note, it would be equally easy (and maybe better) to do PCA on all samples available for each assay, then do intersectColumns at this point instead. Now, steps for calculating the correlations and plotting a heatmap: * Use wideFormat to paste these together, which has the nice property of adding assay names to the column names. * The first column always contains the sample identifier, so remove it. * Coerce to a matrix * Calculate the correlations, and take the absolute value (since signs of principal components are arbitrary) * Set the diagonals to NA (each variable has a correlation of 1 to itself). df &lt;- wideFormat(miniACC2)[, -1] mycors &lt;- cor(as.matrix(df)) mycors &lt;- abs(mycors) diag(mycors) &lt;- NA To simplify the heatmap, show only components that have at least one correlation greater than 0.5. has.high.cor &lt;- apply(mycors, 2, max, na.rm=TRUE) &gt; 0.5 mycors &lt;- mycors[has.high.cor, has.high.cor] pheatmap::pheatmap(mycors) The highest correlation present is between PC2 of the RNA-seq assay, and PC1 of the protein assay. back to top 10.17.6 Annotating with ranges This section doesn’t use the TCGAutils shortcuts, and is more generally applicable. Convert all the ExperimentList elements in miniACC to RangedSummarizedExperiment objects. Then use rowRanges to annotate these objects with genomic ranges. For the microRNA assay, annotate instead with the genomic coordinates of predicted targets. Solution The following shortcut function takes a list of human gene symbols and uses AnnotationFilter and EnsDb.Hsapiens.v86 to look up the ranges, and return these as a GRangesList which can be used to replace the rowRanges of the SummarizedExperiment objects: getrr &lt;- function(identifiers, EnsDbFilterFunc=AnnotationFilter::SymbolFilter) { edb &lt;- EnsDb.Hsapiens.v86::EnsDb.Hsapiens.v86 afl &lt;- AnnotationFilterList( EnsDbFilterFunc(identifiers), SeqNameFilter(c(1:21, &quot;X&quot;, &quot;Y&quot;)), TxBiotypeFilter(&quot;protein_coding&quot;)) gr &lt;- genes(edb, filter=afl) grl &lt;- split(gr, factor(identifiers)) grl &lt;- grl[match(identifiers, names(grl))] stopifnot(identical(names(grl), identifiers)) return(grl) } For example: getrr(rownames(miniACC)[[1]]) #&gt; GRangesList object of length 198: #&gt; $DIRAS3 #&gt; GRanges object with 1 range and 7 metadata columns: #&gt; seqnames ranges strand | gene_id #&gt; &lt;Rle&gt; &lt;IRanges&gt; &lt;Rle&gt; | &lt;character&gt; #&gt; ENSG00000116288 1 7954291-7985505 + | ENSG00000116288 #&gt; gene_name gene_biotype seq_coord_system symbol #&gt; &lt;character&gt; &lt;character&gt; &lt;character&gt; &lt;character&gt; #&gt; ENSG00000116288 PARK7 protein_coding chromosome PARK7 #&gt; entrezid tx_biotype #&gt; &lt;list&gt; &lt;character&gt; #&gt; ENSG00000116288 11315 protein_coding #&gt; #&gt; $MAPK14 #&gt; GRanges object with 1 range and 7 metadata columns: #&gt; seqnames ranges strand | gene_id #&gt; ENSG00000116285 1 8004404-8026308 - | ENSG00000116285 #&gt; gene_name gene_biotype seq_coord_system symbol #&gt; ENSG00000116285 ERRFI1 protein_coding chromosome ERRFI1 #&gt; entrezid tx_biotype #&gt; ENSG00000116285 54206 protein_coding #&gt; #&gt; $YAP1 #&gt; GRanges object with 1 range and 7 metadata columns: #&gt; seqnames ranges strand | gene_id #&gt; ENSG00000198793 1 11106535-11262507 - | ENSG00000198793 #&gt; gene_name gene_biotype seq_coord_system symbol #&gt; ENSG00000198793 MTOR protein_coding chromosome MTOR #&gt; entrezid tx_biotype #&gt; ENSG00000198793 2475 protein_coding #&gt; #&gt; ... #&gt; &lt;195 more elements&gt; #&gt; ------- #&gt; seqinfo: 22 sequences from GRCh38 genome Use this to set the rowRanges of experiments 1-4 with these GRangesList objects rseACC &lt;- miniACC withRSE &lt;- c(1:3, 5) for (i in withRSE){ rowRanges(rseACC[[i]]) &lt;- getrr(rownames(rseACC[[i]])) } Note that the class of experiments 1-4 is now RangedSummarizedExperiment: experiments(rseACC) #&gt; ExperimentList class object of length 5: #&gt; [1] RNASeq2GeneNorm: RangedSummarizedExperiment with 198 rows and 79 columns #&gt; [2] gistict: RangedSummarizedExperiment with 198 rows and 90 columns #&gt; [3] RPPAArray: RangedSummarizedExperiment with 33 rows and 46 columns #&gt; [4] Mutations: matrix with 97 rows and 90 columns #&gt; [5] miRNASeqGene: RangedSummarizedExperiment with 471 rows and 80 columns With ranged objects in the MultiAssayExperiment, you can then do subsetting by ranges. For example, select all genes on chromosome 1 for the four rangedSummarizedExperiment objects: rseACC[GRanges(seqnames=&quot;1:1-1e9&quot;), , withRSE] #&gt; A MultiAssayExperiment object of 3 listed #&gt; experiments with user-defined names and respective classes. #&gt; Containing an ExperimentList class object of length 3: #&gt; [1] RNASeq2GeneNorm: RangedSummarizedExperiment with 22 rows and 79 columns #&gt; [2] gistict: RangedSummarizedExperiment with 22 rows and 90 columns #&gt; [3] RPPAArray: RangedSummarizedExperiment with 3 rows and 46 columns #&gt; Features: #&gt; experiments() - obtain the ExperimentList instance #&gt; colData() - the primary/phenotype DataFrame #&gt; sampleMap() - the sample availability DataFrame #&gt; `$`, `[`, `[[` - extract colData columns, subset, or experiment #&gt; *Format() - convert into a long or wide DataFrame #&gt; assays() - convert ExperimentList to a SimpleList of matrices Note about microRNA: You can set ranges for the microRNA assay according to the genomic location of those microRNA, or the locations of their predicted targets, but we don’t do it here. Assigning genomic ranges of microRNA targets would be an easy way to subset them according to their targets. back to top City University of New York, New York, NY, USA↩ Roswell Park Comprehensive Cancer Center, Buffalo, NY↩ City University of New York, New York, NY, USA↩ City University of New York, New York, NY, USA↩ https://confluence.broadinstitute.org/display/GDAC/FAQ#FAQ-Q%C2%A0Whatreferencegenomebuildareyouusing↩ "],
["biomarker-discovery-from-large-pharmacogenomics-datasets.html", "11 Biomarker discovery from large pharmacogenomics datasets 11.1 Instructors: 11.2 Workshop Description 11.3 Workshop goals and objectives", " 11 Biomarker discovery from large pharmacogenomics datasets 11.1 Instructors: Zhaleh Safikhani (zhaleh.safikhani@utoront.ca) Petr Smirnov (petr.smirnov@mail.utoronto.ca) Benjamin Haib-Kains (benjamin.haibe.kains@utoronto.ca) 11.2 Workshop Description This workshop will focus on the challenges encountered when applying machine learning techniques in complex, high dimensional biological data. In particular, we will focus on biomarker discovery from pharmacogenomic data, which consists of developing predictors of response of cancer cell lines to chemical compounds based on their genomic features. From a methodological viewpoint, biomarker discovery is strongly linked to variable selection, through methods such as Supervised Learning with sparsity inducing norms (e.g., ElasticNet) or techniques accounting for the complex correlation structure of biological features (e.g., mRMR). Yet, the main focus of this talk will be on sound use of such methods in a pharmacogenomics context, their validation and correct interpretation of the produced results. We will discuss how to assess the quality of both the input and output data. We will illustrate the importance of unified analytical platforms, data and code sharing in bioinformatics and biomedical research, as the data generation process becomes increasingly complex and requires high level of replication to achieve robust results. This is particularly relevant as our portfolio of machine learning techniques is ever enlarging, with its set of hyperparameters that can be tuning in a multitude of ways, increasing the risk of overfitting when developing multivariate predictors of drug response. 11.2.1 Pre-requisites Basic knowledge of R syntax Familiarity with the machine learning concept and at least a few approaches Following resources might be useful to read: https://academic.oup.com/bioinformatics/article-lookup/doi/10.1093/bioinformatics/btv723 https://academic.oup.com/nar/article/46/D1/D994/4372597 https://web.stanford.edu/~hastie/Papers/ESLII.pdf 11.2.2 Workshop Participation Participants expected to have the following required packages installed on their machines to be able to run the commands along with the instructors. * PharmacoGx and Biobase from Bioconductor * mRMRe, caret, glmnet, randomForest from cran * bhklab/mci and bhklab/PharmacoGx-ML from github 11.2.3 R / Bioconductor packages used https://bioconductor.org/packages/release/bioc/html/PharmacoGx.html 11.2.4 Time outline An example for a 45-minute workshop: Activity Time Introduction 10m Basic functionalities of PharmacoGx 15m Consistency assessment between datasets 15m Machine learning and biomarker discovery 20m 11.3 Workshop goals and objectives 11.3.1 Learning goals describe the pharmacogenomic datasets and their usefulness learn how to extract information from these datasets and to intersect them over their common features identify functionalities available in PharmacoGx package to work with the high dimensional pharmacogenomics data assess reproducibility and replication of pharmacogenomics studies understand how to handle the biomarker discovery as a pattern recognition problem in the domain of pharmacogenomics studies 11.3.2 Learning objectives list available standardized pharmacogenomic datasets and download them understand the structure of these darasest and how to access the features and response quantifications create drug-dose response plots Measure the consistency across multiple datasets and how to improve such measurements Assess whether known biomarkers are reproduced within these datasets Predict new biomarkers by applying different machine learning methods This course will focus on the challenges encountered when applying machine learning techniques in complex, high dimensional biological data. In particular, we will focus on biomarker discovery from pharmacogenomic data, which consists of developing predictors of response of cancer cell lines to chemical compounds based on their genomic features. From a methodological viewpoint, biomarker discovery is strongly linked to variable selection, through methods such as Supervised Learning with sparsity inducing norms (e.g., ElasticNet) or techniques accounting for the complex correlation structure of biological features (e.g., mRMR). Yet, the main focus of this talk will be on sound use of such methods in a pharmacogenomics context, their validation and correct interpretation of the produced results. We will discuss how to assess the quality of both the input and output data. We will illustrate the importance of unified analytical platforms, data and code sharing in bioinformatics and biomedical research, as the data generation process becomes increasingly complex and requires high level of replication to achieve robust results. This is particularly relevant as our portfolio of machine learning techniques is ever enlarging, with its set of hyperparameters that can be tuning in a multitude of ways, increasing the risk of overfitting when developing multivariate predictors of drug response. Pharmacogenomics holds much potential to aid in discovering drug response biomarkers and developing novel targeted therapies, leading to development of precision medicine and working towards the goal of personalized therapy. Several large experiments have been conducted, both to molecularly characterize drug dose response across many cell lines, and to examine the molecular response to drug administration. However, the experiments lack a standardization of protocols and annotations, hindering meta-analysis across several experiments. PharmacoGx was developed to address these challenges, by providing a unified framework for downloading and analyzing large pharmacogenomic datasets which are extensively curated to ensure maximum overlap and consistency. PharmacoGx is based on a level of abstraction from the raw experimental data, and allows bioinformaticians and biologists to work with data at the level of genes, drugs and cell lines. This provides a more intuitive interface and, in combination with unified curation, simplifies analyses between multiple datasets. Load PharamacoGx into your current workspace: library(PharmacoGx, verbose=FALSE) #&gt; Warning in fun(libname, pkgname): couldn&#39;t connect to display &quot;:0&quot; library(mCI, verbose=FALSE) library(PharmacoGxML, verbose=FALSE) library(Biobase, verbose=FALSE) #&gt; Loading required package: BiocGenerics #&gt; Loading required package: parallel #&gt; #&gt; Attaching package: &#39;BiocGenerics&#39; #&gt; The following objects are masked from &#39;package:parallel&#39;: #&gt; #&gt; clusterApply, clusterApplyLB, clusterCall, clusterEvalQ, #&gt; clusterExport, clusterMap, parApply, parCapply, parLapply, #&gt; parLapplyLB, parRapply, parSapply, parSapplyLB #&gt; The following objects are masked from &#39;package:stats&#39;: #&gt; #&gt; IQR, mad, sd, var, xtabs #&gt; The following objects are masked from &#39;package:base&#39;: #&gt; #&gt; anyDuplicated, append, as.data.frame, basename, cbind, #&gt; colMeans, colnames, colSums, dirname, do.call, duplicated, #&gt; eval, evalq, Filter, Find, get, grep, grepl, intersect, #&gt; is.unsorted, lapply, lengths, Map, mapply, match, mget, order, #&gt; paste, pmax, pmax.int, pmin, pmin.int, Position, rank, rbind, #&gt; Reduce, rowMeans, rownames, rowSums, sapply, setdiff, sort, #&gt; table, tapply, union, unique, unsplit, which, which.max, #&gt; which.min #&gt; Welcome to Bioconductor #&gt; #&gt; Vignettes contain introductory material; view with #&gt; &#39;browseVignettes()&#39;. To cite Bioconductor, see #&gt; &#39;citation(&quot;Biobase&quot;)&#39;, and for packages &#39;citation(&quot;pkgname&quot;)&#39;. We have made the PharmacoSet objects of the curated datasets available for download using functions provided in the package. A table of available PharmacoSet objects can be obtained by using the availablePSets function. Any of the PharmacoSets in the table can then be downloaded by calling downloadPSet, which saves the datasets into a directory of the users choice, and returns the data into the R session. availablePSets(saveDir=file.path(&quot;.&quot;, &quot;Safikhani_Pharmacogenomics&quot;)) GDSC &lt;- downloadPSet(&quot;GDSC&quot;, saveDir=file.path(&quot;.&quot;, &quot;Safikhani_Pharmacogenomics&quot;)) CCLE &lt;- downloadPSet(&quot;CCLE&quot;, saveDir=file.path(&quot;.&quot;, &quot;Safikhani_Pharmacogenomics&quot;)) PharmacoGx can be used to process pharmacogenomic datasets. First we want to check the heterogenity of cell lines in one of the available psets, CCLE. mycol &lt;- c(&quot;#8dd3c7&quot;,&quot;#ffffb3&quot;,&quot;#bebada&quot;,&quot;#fb8072&quot;,&quot;#80b1d3&quot;,&quot;#fdb462&quot;, &quot;#b3de69&quot;,&quot;#fccde5&quot;,&quot;#d9d9d9&quot;,&quot;#bc80bd&quot;,&quot;#ccebc5&quot;,&quot;#ffed6f&quot;, &quot;#a6cee3&quot;,&quot;#1f78b4&quot;,&quot;#b2df8a&quot;,&quot;#33a02c&quot;,&quot;#fb9a99&quot;,&quot;#e31a1c&quot;, &quot;#fdbf6f&quot;,&quot;#ff7f00&quot;,&quot;#cab2d6&quot;,&quot;#6a3d9a&quot;,&quot;#ffff99&quot;,&quot;#b15928&quot;) pie(table(CCLE@cell[,&quot;tissueid&quot;]), col=mycol, main=&quot;Tissue types&quot;, radius=1, cex=0.8) (#fig:pie_chart)Tissue of origin of cell lines in CCLE study Drug-Dose response data included in the PharmacoSet objects can be conviniently plotted using the drugDoseResponseCurve function. Given a list of PharmacoSets, a drug name and a cell name, it will plot the drug dose response curves for the given cell-drug combination in each dataset, allowing direct comparisons of data between datasets. CCLE.auc &lt;- summarizeSensitivityProfiles( pSet=CCLE, sensitivity.measure=&quot;auc_published&quot;, summary.stat=&quot;median&quot;, verbose=FALSE) lapatinib.aac &lt;- CCLE.auc[&quot;lapatinib&quot;,] cells &lt;- names(lapatinib.aac)[ c(which.min(lapatinib.aac), which((lapatinib.aac &gt; 0.2) &amp; (lapatinib.aac &lt; 0.4))[1], which.max(lapatinib.aac))] par(mfrow=c(2, 2)) drugDoseResponseCurve(drug=&quot;lapatinib&quot;, cellline=cells[1], pSets=CCLE, plot.type=&quot;Fitted&quot;, legends.label=&quot;auc_published&quot;) drugDoseResponseCurve(drug=&quot;lapatinib&quot;, cellline=cells[2], pSets=CCLE, plot.type=&quot;Fitted&quot;, legends.label=&quot;auc_published&quot;) drugDoseResponseCurve(drug=&quot;lapatinib&quot;, cellline=cells[3], pSets=CCLE, plot.type=&quot;Fitted&quot;, legends.label=&quot;auc_published&quot;) Figure 11.1: Cells response to lapatinib in CCLE In pharmacogenomic studies Cells were also tested for their response to increasing concentrations of various compounds, and form this the IC50 and AUC were computed. These pharmacological profiles are available for all the psets in PharmacoGx. library(ggplot2, verbose=FALSE) library(reshape2, verbose=FALSE) melted_data &lt;- melt(CCLE.auc) NA_rows &lt;- unique(which(is.na(melted_data), arr.ind=T)[,1]) melted_data &lt;- melted_data[-NA_rows,] ggplot(melted_data, aes(x=Var1,y=value)) + geom_boxplot(fill=&quot;gray&quot;) + theme(axis.text.x=element_text(angle=90,hjust=1)) + xlab(&quot;Drugs&quot;) + ylab(&quot;AAC&quot;) (#fig:ccle_auc)Cells response to drugs in CCLE #hist(CCLE.auc[&quot;lapatinib&quot;,], xlab=&quot;Cells response to lapatinib(AAC)&quot;, # col=&quot;gray&quot;, main=&quot;&quot;) In this section we will investigate the consistency between the GDSC and CCLE datasets. In both CCLE and GDSC, the transcriptome of cells was profiled using an Affymatrix microarray chip. Cells were also tested for their response to increasing concentrations of various compounds, and form this the IC50 and AUC were computed. However, the cell and drugs names used between the two datasets were not consistent. Furthermore, two different microarray platforms were used. However, PharmacoGx allows us to overcome these differences to do a comparative study between these two datasets. GDSC was profiled using the hgu133a platform, while CCLE was profiled with the expanded hgu133plus2 platform. While in this case the hgu133a is almost a strict subset of hgu133plus2 platform, the expression information in PharmacoSet objects is summarized by Ensemble Gene Ids, allowing datasets with different platforms to be directly compared. The probe to gene mapping is done using the BrainArray customCDF for each platform . To begin, you would load the datasets from disk or download them using the downloadPSet function above. We want to investigate the consistency of the data between the two datasets. The common intersection between the datasets can then be found using intersectPSet. We create a summary of the gene expression and drug sensitivity measures for both datasets, so we are left with one gene expression profile and one sensitivity profile per cell line within each dataset. We can then compare the gene expression and sensitivity measures between the datasets using a standard correlation coefficient. common &lt;- intersectPSet(pSets = list(&quot;CCLE&quot;=CCLE, &quot;GDSC&quot;=GDSC), intersectOn = c(&quot;cell.lines&quot;, &quot;drugs&quot;), strictIntersect = TRUE) #&gt; Intersecting large PSets may take a long time ... drugs &lt;- drugNames(common$CCLE) ##Example of concordant and discordant drug curves cases &lt;- rbind( c(&quot;CAL-85-1&quot;, &quot;17-AAG&quot;), c(&quot;HT-29&quot;, &quot;PLX4720&quot;), c(&quot;COLO-320-HSR&quot;, &quot;AZD6244&quot;), c(&quot;HT-1080&quot;, &quot;PD-0332991&quot;)) par(mfrow=c(2, 2)) for (i in 1:nrow(cases)) { drugDoseResponseCurve(pSets=common, drug=cases[i,2], cellline=cases[i,1], legends.label=&quot;ic50_published&quot;, plot.type=&quot;Fitted&quot;, ylim=c(0,130)) } (#fig:Replication_curves)Consistency of drug response curves across studies ##AAC scatter plot GDSC.aac &lt;- summarizeSensitivityProfiles( pSet=common$GDSC, sensitivity.measure=&#39;auc_recomputed&#39;, summary.stat=&quot;median&quot;, verbose=FALSE) CCLE.aac &lt;- summarizeSensitivityProfiles( pSet=common$CCLE, sensitivity.measure=&#39;auc_recomputed&#39;, summary.stat=&quot;median&quot;, verbose=FALSE) GDSC.ic50 &lt;- summarizeSensitivityProfiles( pSet=common$GDSC, sensitivity.measure=&#39;ic50_recomputed&#39;, summary.stat=&quot;median&quot;, verbose=FALSE) CCLE.ic50 &lt;- summarizeSensitivityProfiles( pSet=common$CCLE, sensitivity.measure=&#39;ic50_recomputed&#39;, summary.stat=&quot;median&quot;, verbose=FALSE) drug &lt;- &quot;lapatinib&quot; #par(mfrow=c(1, 2)) myScatterPlot(x=GDSC.aac[drug,], y=CCLE.aac[drug,], method=c(&quot;transparent&quot;), transparency=0.8, pch=16, minp=50, xlim=c(0, max(max(GDSC.aac[drug,], na.rm=T), max(CCLE.aac[drug,], na.rm=T))), ylim=c(0, max(max(GDSC.aac[drug,], na.rm=T), max(CCLE.aac[drug,], na.rm=T))), main=&quot;cells response to lapatinib&quot;, cex.sub=0.7, xlab=&quot;AAC in GDSC&quot;, ylab=&quot;AAC in CCLE&quot;) legend(&quot;topright&quot;, legend=sprintf(&quot;r=%s\\nrs=%s\\nCI=%s&quot;, round(cor(GDSC.aac[drug,], CCLE.aac[drug,], method=&quot;pearson&quot;, use=&quot;pairwise.complete.obs&quot;), digits=2), round(cor(GDSC.aac[drug,], CCLE.aac[drug,], method=&quot;spearman&quot;, use=&quot;pairwise.complete.obs&quot;), digits=2), round(paired.concordance.index(GDSC.aac[drug,], CCLE.aac[drug,], delta.pred=0, delta.obs=0)$cindex, digits=2)), bty=&quot;n&quot;) (#fig:sensitivity_scatter_plots)Concordance of AAC values To better assess the concordance of multiple pharmacogenomic studies we introduced the modified concordance index (mCI). Recognizing that the noise in the drug screening assays is high and may yield to inaccurate sensitive-based ranking of cell lines with close AAC values, the mCI only considers cell line pairs with drug sensitivity (AAC) difference greater than \\(\\delta\\) . c_index &lt;- mc_index &lt;- NULL for(drug in drugs){ tt &lt;- mCI::paired.concordance.index(GDSC.aac[drug,], CCLE.aac[drug,], delta.pred=0, delta.obs=0, alternative=&quot;greater&quot;) c_index &lt;- c(c_index, tt$cindex) tt &lt;- mCI::paired.concordance.index(GDSC.aac[drug,], CCLE.aac[drug,], delta.pred=0.2, delta.obs=0.2, alternative=&quot;greater&quot;, logic.operator=&quot;or&quot;) mc_index &lt;- c(mc_index, tt$cindex) } mp &lt;- barplot(as.vector(rbind(c_index, mc_index)), beside=TRUE, col=c(&quot;blue&quot;, &quot;red&quot;), ylim=c(0, 1), ylab=&quot;concordance index&quot;, space=c(.15,.85), border=NA, main=&quot;mCI&quot;) text(mp, par(&quot;usr&quot;)[3], labels=as.vector(rbind(drugs, rep(&quot;&quot;, 15))), srt=45, adj=c(1.1,1.1), xpd=TRUE, cex=.8) abline(h=.7, lty=2) The association between molecular features and response to a given drug is modelled using a linear regression model adjusted for tissue source: \\[Y = \\beta_{0} + \\beta_{i}G_i + \\beta_{t}T + \\beta_{b}B\\] where \\(Y\\) denotes the drug sensitivity variable, \\(G_i\\), \\(T\\) and \\(B\\) denote the expression of gene \\(i\\), the tissue source and the experimental batch respectively, and \\(\\beta\\)s are the regression coefficients. The strength of gene-drug association is quantified by \\(\\beta_i\\), above and beyond the relationship between drug sensitivity and tissue source. The variables \\(Y\\) and \\(G\\) are scaled (standard deviation equals to 1) to estimate standardized coefficients from the linear model. Significance of the gene-drug association is estimated by the statistical significance of \\(\\beta_i\\) (two-sided t test). P-values are then corrected for multiple testing using the false discovery rate (FDR) approach. As an example of the reproducibility of biomarker discovery across pharmacogenomic studies, we can model the significance of the association between two drugs and their known biomarkers in CCLE and GDSC. We examine the association between drug 17-AAG and gene NQO1, as well as drug PD-0325901 and gene BRAF: features &lt;- PharmacoGx::fNames(CCLE, &quot;rna&quot;)[ which(featureInfo(CCLE, &quot;rna&quot;)$Symbol == &quot;NQO1&quot;)] ccle.sig.rna &lt;- drugSensitivitySig(pSet=CCLE, mDataType=&quot;rna&quot;, drugs=c(&quot;17-AAG&quot;), features=features, sensitivity.measure=&quot;auc_published&quot;, molecular.summary.stat=&quot;median&quot;, sensitivity.summary.stat=&quot;median&quot;, verbose=FALSE) gdsc.sig.rna &lt;- drugSensitivitySig(pSet=GDSC, mDataType=&quot;rna&quot;, drugs=c(&quot;17-AAG&quot;), features=features, sensitivity.measure=&quot;auc_published&quot;, molecular.summary.stat=&quot;median&quot;, sensitivity.summary.stat=&quot;median&quot;, verbose=FALSE) ccle.sig.mut &lt;- drugSensitivitySig(pSet=CCLE, mDataType=&quot;mutation&quot;, drugs=c(&quot;PD-0325901&quot;), features=&quot;BRAF&quot;, sensitivity.measure=&quot;auc_published&quot;, molecular.summary.stat=&quot;and&quot;, sensitivity.summary.stat=&quot;median&quot;, verbose=FALSE) gdsc.sig.mut &lt;- drugSensitivitySig(pSet=GDSC, mDataType=&quot;mutation&quot;, drugs=c(&quot;PD-0325901&quot;), features=&quot;BRAF&quot;, sensitivity.measure=&quot;auc_published&quot;, molecular.summary.stat=&quot;and&quot;, sensitivity.summary.stat=&quot;median&quot;, verbose=FALSE) ccle.sig &lt;- rbind(ccle.sig.rna, ccle.sig.mut) gdsc.sig &lt;- rbind(gdsc.sig.rna, gdsc.sig.mut) known.biomarkers &lt;- cbind(&quot;GDSC effect size&quot;=gdsc.sig[,1], &quot;GDSC pvalue&quot;=gdsc.sig[,6], &quot;CCLE effect size&quot;=ccle.sig[,1], &quot;CCLE pvalue&quot;=ccle.sig[,6]) rownames(known.biomarkers) &lt;- c(&quot;17-AAG + NQO1&quot;,&quot;PD-0325901 + BRAF&quot;) library(xtable, verbose=FALSE) xtable(known.biomarkers, digits=c(0, 2, -1, 2, -1), caption=&#39;Concordance of biomarkers across stuudies&#39;) par(mfrow=c(2, 2)) CCLE_expr &lt;- t(exprs(summarizeMolecularProfiles(CCLE, mDataType=&quot;rna&quot;, fill.missing=FALSE))) CCLE_cells &lt;- intersect(rownames(CCLE_expr), colnames(CCLE.aac)) plot(CCLE.aac[&quot;17-AAG&quot;, CCLE_cells], CCLE_expr[CCLE_cells, features], main=&quot;CCLE + 17-AAG + NQO1&quot;, cex.main=1, ylab=&quot;Predictions&quot;, xlab=&quot;drug sensitivity&quot;, pch=20, col=&quot;gray40&quot;) GDSC_expr &lt;- t(exprs(summarizeMolecularProfiles(GDSC, mDataType=&quot;rna&quot;, fill.missing=FALSE))) #&gt; Summarizing rna molecular data for: GDSC GDSC_cells &lt;- intersect(rownames(GDSC_expr), colnames(GDSC.aac)) plot(GDSC.aac[&quot;17-AAG&quot;, GDSC_cells], GDSC_expr[GDSC_cells, features], main=&quot;GDSC + 17-AAG + NQO1&quot;, cex.main=1, ylab=&quot;Predictions&quot;, xlab=&quot;drug sensitivity&quot;, pch=20, col=&quot;gray40&quot;) CCLE_mut &lt;- t(exprs(summarizeMolecularProfiles(CCLE, mDataType=&quot;mutation&quot;, fill.missing=FALSE, summary.stat=&quot;or&quot;))) CCLE_cells &lt;- intersect(rownames(CCLE_mut), colnames(CCLE.aac)) boxplot(CCLE.aac[&quot;PD-0325901&quot;, CCLE_cells]~ CCLE_mut[CCLE_cells, &quot;BRAF&quot;], col=&quot;gray80&quot;, pch=20, main=&quot;CCLE + PD-0325901 + BRAF&quot;, cex.main=1, xlab=&quot;mutation&quot;, ylab=&quot;drug sensitivity&quot;) GDSC_mut &lt;- t(exprs(summarizeMolecularProfiles(GDSC, mDataType=&quot;mutation&quot;, fill.missing=FALSE, summary.stat=&quot;or&quot;))) GDSC_cells &lt;- intersect(rownames(GDSC_mut), colnames(GDSC.aac)) boxplot(GDSC.aac[&quot;PD-0325901&quot;, GDSC_cells]~ GDSC_mut[GDSC_cells, &quot;BRAF&quot;], col=&quot;gray80&quot;, pch=20, main=&quot;GDSC + PD-0325901 + BRAF&quot;, cex.main=1, xlab=&quot;mutation&quot;, ylab=&quot;drug sensitivity&quot;) Some of the widely used multivariate machine learning methods such as elastic net, Random Forest (RF) and Support Vector Machine (SVM) have been already implemented in the MLWorkshop. It optimizes hyperparameters of these methods in the training phase. To assess the performance of the predictive models, it implements m number of sampling with n-fold cross validations (CV). The performance will then be assessed by multiple metrics including pearson correlation coefficient, concordance index and modified concordance index. library(mRMRe, verbose=FALSE) #&gt; Loading required package: survival #&gt; #&gt; Attaching package: &#39;survival&#39; #&gt; The following object is masked from &#39;package:PharmacoGxML&#39;: #&gt; #&gt; ridge #&gt; Loading required package: igraph #&gt; #&gt; Attaching package: &#39;igraph&#39; #&gt; The following objects are masked from &#39;package:BiocGenerics&#39;: #&gt; #&gt; normalize, path, union #&gt; The following objects are masked from &#39;package:stats&#39;: #&gt; #&gt; decompose, spectrum #&gt; The following object is masked from &#39;package:base&#39;: #&gt; #&gt; union #&gt; #&gt; Attaching package: &#39;mRMRe&#39; #&gt; The following objects are masked from &#39;package:Biobase&#39;: #&gt; #&gt; featureData, featureNames, sampleNames library(Biobase, verbose=FALSE) library(Hmisc, verbose=FALSE) #&gt; Loading required package: lattice #&gt; Loading required package: Formula #&gt; #&gt; Attaching package: &#39;Hmisc&#39; #&gt; The following objects are masked from &#39;package:xtable&#39;: #&gt; #&gt; label, label&lt;- #&gt; The following object is masked from &#39;package:Biobase&#39;: #&gt; #&gt; contents #&gt; The following objects are masked from &#39;package:base&#39;: #&gt; #&gt; format.pval, units library(glmnet, verbose=FALSE) #&gt; Loading required package: Matrix #&gt; Loading required package: foreach #&gt; Loaded glmnet 2.0-16 library(caret, verbose=FALSE) #&gt; #&gt; Attaching package: &#39;caret&#39; #&gt; The following object is masked from &#39;package:survival&#39;: #&gt; #&gt; cluster library(randomForest, verbose=FALSE) #&gt; randomForest 4.6-14 #&gt; Type rfNews() to see new features/changes/bug fixes. #&gt; #&gt; Attaching package: &#39;randomForest&#39; #&gt; The following object is masked from &#39;package:ggplot2&#39;: #&gt; #&gt; margin #&gt; The following object is masked from &#39;package:Biobase&#39;: #&gt; #&gt; combine #&gt; The following object is masked from &#39;package:BiocGenerics&#39;: #&gt; #&gt; combine ##Preparing trainig dataset train_expr &lt;- t(exprs(summarizeMolecularProfiles(GDSC, mDataType=&quot;rna&quot;, fill.missing=FALSE, verbose=FALSE))) aac &lt;- summarizeSensitivityProfiles(GDSC, sensitivity.measure=&quot;auc_recomputed&quot;, drug=&quot;lapatinib&quot;, fill.missing=FALSE, verbose=FALSE) cells &lt;- intersect(rownames(train_expr), names(aac)) df &lt;- as.matrix(cbind(train_expr[cells,], &quot;lapatinib&quot;=aac[cells])) ##Preparing validation dataset validation_expr &lt;- summarizeMolecularProfiles(CCLE, mDataType=&quot;rna&quot;, fill.missing=FALSE, verbose=FALSE) actual_labels &lt;- summarizeSensitivityProfiles(CCLE, sensitivity.measure=&quot;auc_recomputed&quot;, drug=&quot;lapatinib&quot;, fill.missing=FALSE, verbose=FALSE) for(method in c(&quot;ridge&quot;, &quot;lasso&quot;, &quot;random_forest&quot;, &quot;svm&quot;)){ par(mfrow=c(1, 2)) res &lt;- optimization(train=df[, -ncol(df), drop=F], labels=t(df[, ncol(df), drop=F]), method=method, folds.no=5, sampling.no=1, features.no=10, feature.selection=&quot;mRMR&quot;, assessment=c(&quot;corr&quot;, &quot;mCI&quot;)) validation_labels &lt;- validation(model=res$model$lapatinib, validation.set=t(exprs(validation_expr)), validation.labels=actual_labels, method=method, assessment=&quot;mCI&quot;) } This document was generated with the following R version and packages loaded: sessionInfo() #&gt; R version 3.5.0 (2018-04-23) #&gt; Platform: x86_64-pc-linux-gnu (64-bit) #&gt; Running under: Debian GNU/Linux 9 (stretch) #&gt; #&gt; Matrix products: default #&gt; BLAS: /usr/lib/openblas-base/libblas.so.3 #&gt; LAPACK: /usr/lib/libopenblasp-r0.2.19.so #&gt; #&gt; locale: #&gt; [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C #&gt; [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 #&gt; [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=C #&gt; [7] LC_PAPER=en_US.UTF-8 LC_NAME=C #&gt; [9] LC_ADDRESS=C LC_TELEPHONE=C #&gt; [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C #&gt; #&gt; attached base packages: #&gt; [1] parallel stats graphics grDevices utils datasets methods #&gt; [8] base #&gt; #&gt; other attached packages: #&gt; [1] randomForest_4.6-14 caret_6.0-80 glmnet_2.0-16 #&gt; [4] foreach_1.4.4 Matrix_1.2-14 Hmisc_4.1-1 #&gt; [7] Formula_1.2-3 lattice_0.20-35 mRMRe_2.0.7 #&gt; [10] igraph_1.2.1 survival_2.42-6 xtable_1.8-2 #&gt; [13] reshape2_1.4.3 ggplot2_3.0.0 Biobase_2.41.1 #&gt; [16] BiocGenerics_0.27.1 PharmacoGxML_0.1.0 mCI_0.1.0 #&gt; [19] PharmacoGx_1.11.0 #&gt; #&gt; loaded via a namespace (and not attached): #&gt; [1] fgsea_1.7.1 colorspace_1.3-2 class_7.3-14 #&gt; [4] rprojroot_1.3-2 htmlTable_1.12 lsa_0.73.1 #&gt; [7] pls_2.6-0 base64enc_0.1-3 rstudioapi_0.7 #&gt; [10] DRR_0.0.3 SnowballC_0.5.1 lubridate_1.7.4 #&gt; [13] prodlim_2018.04.18 codetools_0.2-15 splines_3.5.0 #&gt; [16] mnormt_1.5-5 robustbase_0.93-1 knitr_1.20 #&gt; [19] RcppRoll_0.3.0 magicaxis_2.0.3 broom_0.4.5 #&gt; [22] ddalpha_1.3.4 kernlab_0.9-26 cluster_2.0.7-1 #&gt; [25] sfsmisc_1.1-2 mapproj_1.2.6 compiler_3.5.0 #&gt; [28] backports_1.1.2 assertthat_0.2.0 lazyeval_0.2.1 #&gt; [31] limma_3.37.3 acepack_1.4.1 htmltools_0.3.6 #&gt; [34] tools_3.5.0 bindrcpp_0.2.2 gtable_0.2.0 #&gt; [37] glue_1.2.0 RANN_2.5.1 dplyr_0.7.6 #&gt; [40] maps_3.3.0 fastmatch_1.1-0 Rcpp_0.12.17 #&gt; [43] slam_0.1-43 gdata_2.18.0 nlme_3.1-137 #&gt; [46] iterators_1.0.10 psych_1.8.4 timeDate_3043.102 #&gt; [49] gower_0.1.2 xfun_0.3 stringr_1.3.1 #&gt; [52] gtools_3.8.1 DEoptimR_1.0-8 MASS_7.3-50 #&gt; [55] scales_0.5.0 ipred_0.9-6 relations_0.6-8 #&gt; [58] RColorBrewer_1.1-2 sets_1.0-18 yaml_2.1.19 #&gt; [61] gridExtra_2.3 downloader_0.4 rpart_4.1-13 #&gt; [64] latticeExtra_0.6-28 stringi_1.2.3 highr_0.7 #&gt; [67] NISTunits_1.0.1 plotrix_3.7-2 checkmate_1.8.5 #&gt; [70] caTools_1.17.1 BiocParallel_1.15.7 lava_1.6.2 #&gt; [73] geometry_0.3-6 rlang_0.2.1 pkgconfig_2.0.1 #&gt; [76] bitops_1.0-6 pracma_2.1.4 evaluate_0.10.1 #&gt; [79] purrr_0.2.5 bindr_0.1.1 recipes_0.1.3 #&gt; [82] htmlwidgets_1.2 labeling_0.3 CVST_0.2-2 #&gt; [85] tidyselect_0.2.4 plyr_1.8.4 magrittr_1.5 #&gt; [88] bookdown_0.7 R6_2.2.2 gplots_3.0.1 #&gt; [91] dimRed_0.1.0 sm_2.2-5.5 pillar_1.3.0 #&gt; [94] foreign_0.8-70 withr_2.1.2 abind_1.4-5 #&gt; [97] nnet_7.3-12 tibble_1.4.2 crayon_1.3.4 #&gt; [100] KernSmooth_2.23-15 rmarkdown_1.10 grid_3.5.0 #&gt; [103] data.table_1.11.4 marray_1.59.0 piano_1.21.0 #&gt; [106] ModelMetrics_1.1.0 digest_0.6.15 tidyr_0.8.1 #&gt; [109] stats4_3.5.0 munsell_0.5.0 celestial_1.4.1 #&gt; [112] magic_1.5-8 tcltk_3.5.0 "],
["maintaining-your-bioconductor-package.html", "12 Maintaining your Bioconductor package 12.1 Instructor name and contact information 12.2 Workshop Description 12.3 Introduction 12.4 Why maintain your package 12.5 Infrastructure used for maintenance 12.6 Outline how to use infrastructure 12.7 Sync package with Github / Bioconductor before every change 12.8 Round up of resources available", " 12 Maintaining your Bioconductor package 12.1 Instructor name and contact information Nitesh Turaga10 (nitesh.turaga@roswellpark.org) 12.2 Workshop Description Once an R package is accepted into Bioconductor, maintaining it is an active responsibility undertaken by the package developers and maintainers. In this short workshop, we will cover how to maintain a Bioconductor package using existing infrastructure. Bioconductor hosts a range of tools which maintainers can use such as daily build reports, landing page badges, RSS feeds, download stats, support site questions, and the bioc-devel mailing list. Some packages have their own continuous integration hook setup on their github pages which would be an additional tool maintainers can use to monitor their package. We will also highlight one particular git practice which need to be done while updating and maintaining your package on out git system. 12.2.1 Pre-requisites Accepted Bioconductor package or plans to contribute a Bioconductor package in the future. 12.2.2 Participation Students will be expected to follow along with their laptops if they choose to, although it is not needed. 12.2.3 Time outline: 50 mins short workshop Introduction: 10 mins Why maintain your package Infrastructure used for maintenance Outline how to use infrastructure: 35 mins Build report Landing page badges RSS feeds Download statistics Support site, Github issues, Bioc-devel mailing list Sync package with Github / Bioconductor before every change GitHub + webhooks Round up of resources available: 5 mins 12.2.4 Workshop goals and objectives Gain knowledge of how to track Bioconductor packages via download statistics, RSS feeds. Understand the importance of supporting their user community and how to do so using the support site and bioc-devel mailing list. Maintain their package and fix bugs using build reports, continuous integration tools. Update their package consistently on both Github and Bioconductor private git server. 12.3 Introduction Maintainer - Who should people contact if they have a problem with this package? You must have someones name and email address here. You must make sure this is up to date and accurate. Maintaining it is an active responsibility undertaken by the package developers and maintainers. Users contact developers for various reasons. Keep your email up to date in the DESCRIPTION file! Maintainer: Who to complain to &lt;your_fault@fix.it&gt; Interchangable terminology Bioconductor maintainers &lt;-&gt; Bioconductor developers &lt;-&gt; Package developer &lt;-&gt; developer 12.4 Why maintain your package It’s good practice that users appreciate. It’ll lead to wide spread usage of your package. It’s required. Poorly maintained packages get deprecated if they fail build and check on Bioconductor during RELEASE cycles. (Bioconductor is fairly serious about this) 12.5 Infrastructure used for maintenance Build machines are dedicated towards building your package daily. As a maintianer it’s useful to check your package build report once a week, both in the current RELEASE and DEVEL cycle. http://bioconductor.org/checkResults/ Build machines cover three platforms (Linux, Windows and OS X) over RELEASE and DEVEL versions of Bioconductor. Version control - Since last year, GIT has been the primary version control system. 12.6 Outline how to use infrastructure Link with most important resources, http://bioconductor.org/developers/ 12.6.1 Build report Bioconductor RELEASE version http://bioconductor.org/checkResults/release/bioc-LATEST/ Bioconductor development version http://bioconductor.org/checkResults/devel/bioc-LATEST/ Six build machines in total at Bioconductor. DEVEL (3 for devel) Linux (malbec1) Windows (tokay1) OS X (merida1) Build machines on DEVEL RELEASE (3 for release) Linux (malbec2) Windows (tokay2) OS X (merida2) What is running on these machines? BUILD – R CMD build INSTALL – R CMD INSTALL CHECK – R CMD check Build machines on DEVEL The build machines display a status for each package. They indicate different things. TIMEOUT - INSTALL, BUILD, CHECK or BUILD BIN of package took more than 40 minutes ERROR - INSTALL, BUILD or BUILD BIN of package failed, or CHECK produced errors WARNINGS - CHECK of package produced warnings OK - INSTALL, BUILD, CHECK or BUILD BIN of package was OK NotNeeded - INSTALL of package was not needed (click on glyph to see why) skipped - CHECK or BUILD BIN of package was skipped because the BUILD step failed NA- BUILD, CHECK or BUILD BIN result is not available because of an anomaly in the Build System 12.6.2 Landing page badges What are badges? BiocGenerics badges Badges indicate the following: platforms availability of the package downloads statistics posts on support.bioconductor.org which are related to that package based on the tag. in Bioc how long the package has been in Bioconductor. build current build status. Where can I find these badges? Landing page to go to RELEASE bioconductor.org/packages/release/BiocGenerics Landing page to go to devel bioconductor.org/packages/devel/BiocGenerics 12.6.3 RSS feeds RSS feeds help developers keep track of the development going on in Bioconductor across all packages. There are multiple ways to use RSS feeds, and you can use the application of your choice to subscribe to the feeds. Blog which shows the 12 best RSS reader apps across all platforms. Links for RSS feeds, http://bioconductor.org/developers/rss-feeds/ Git log published on the website. The git log hosts the last 500 commits to bioconductor across all packages in the development branch of Bioconductor. http://bioconductor.org/developers/gitlog/ Git log on Jul 16th 2018 at 10:30 AM EST 12.6.4 Download statistics The number reported next to each package name is the download score, that is, the average number of distinct IPs that “hit” the package each month for the last 12 months (not counting the current month). http://bioconductor.org/packages/stats/ Example BiocGenerics Download Statistics 12.6.5 Support site, Github issues, Bioc-devel mailing list Support infrastructure set up for Bioconductor users to be in touch with maintainers. 12.6.5.1 Mailing list Mailing list for bioc-devel for all questions related package development, infrastructure, package support. If a question is misplaced, the author will be pointed to the correct location to ask the question. https://stat.ethz.ch/mailman/listinfo/bioc-devel 12.6.5.2 Support site Public support site, with easy to use interface to ask questions among the broader community. Any and all questions are welcome here. http://support.bioconductor.org/ 12.6.5.3 Github issues Github issues are more developer centric than mailing list and support site quetsions. This needs to be posted directly on the development repositories of individual packages. Each package maintainer can choose to do their development on Github giving an interface for issues. The Bioconductor core team manages issues on the repositories maintained under the Bioconductor Organization on Github. The packages maintained by Bioconductor core follow the structure https://github.com/Bioconductor/&lt;PACKAGE_NAME&gt;/issues Eg: https://github.com/Bioconductor/GenomicRanges/issues 12.7 Sync package with Github / Bioconductor before every change Do this everytime there is an update on your package from your end, or, before you start developing. Help with Git. http://bioconductor.org/developers/how-to/git/ Sync package from Bioconductor repo to Github repo http://bioconductor.org/developers/how-to/git/sync-existing-repositories/ 12.7.1 GitHub + webhooks 12.8 Round up of resources available Roswell Park Comprehensive Cancer Center, Buffalo, NY↩ "],
["public-data-resources-and-bioconductor.html", "13 Public Data Resources and Bioconductor 13.1 Instructor name(s) and contact information 13.2 Syllabus 13.3 Overview 13.4 GEOquery 13.5 GenomicDataCommons 13.6 Querying metadata 13.7 Sequence Read Archive 13.8 Accessing The Cancer Genome Atlas (TCGA) 13.9 recount: Reproducible RNA-seq Analysis Using recount2 13.10 curated*Data packages for standardized cancer transcriptomes 13.11 Microbiome data 13.12 Pharmacogenomics 13.13 Bibliography", " 13 Public Data Resources and Bioconductor 13.1 Instructor name(s) and contact information Levi Waldron11 Benjamin Haibe-Kain12 Sean Davis13 13.2 Syllabus 13.2.1 Workshop Description The goal of this workshop is to introduce Bioconductor packages for finding, accessing, and using large-scale public data resources including the Gene Expression Omnibus GEO, Sequence Read Archive SRA, the Genomic Data Commons GDC, and Bioconductor-hosted curated data resources for metagenomics, pharmacogenomics, and The Cancer Genome Atlas. 13.2.2 Pre-requisites Basic knowledge of R syntax Familiarity with the ExpressionSet and SummarizedExperiment classes Basic familiarity with ’omics technologies such as microarray and NGS sequencing Interested students can prepare by reviewing vignettes of the packages listed in “R/Bioconductor packages used” to gain background on aspects of interest to them. Some more general background on these resources is published in Kannan et al. (2016). 13.2.3 Workshop Participation Each component will include runnable examples of typical usage that students are encouraged to run during demonstration of that component. 13.2.4 R/Bioconductor packages used GEOquery: Access to the NCBI Gene Expression Omnibus (GEO), a public repository of gene expression (primarily microarray) data. GenomicDataCommons: Access to the NIH / NCI Genomic Data Commons RESTful service. SRAdb: A compilation of metadata from the NCBI Sequence Read Archive, the largest public repository of sequencing data from the next generation of sequencing platforms, and tools curatedTCGAData: Curated data from The Cancer Genome Atlas (TCGA) as MultiAssayExperiment Objects curatedMetagenomicData: Curated metagenomic data of the human microbiome HMP16SData: Curated metagenomic data of the human microbiome PharmacoGx: Analysis of large-scale pharmacogenomic data 13.2.5 Time outline This is a 1h45m workshop. Activity Time Overview 10m GEOquery 15m GenomicDataCommons 20m Sequence Read Archive 20m curatedTCGAData 10m curatedMetagenomicData and HMP16SData 15m PharmacoGx 20m 13.2.6 workshop goals and objectives Bioconductor provides access to significant amounts of publicly available experimental data. This workshop introduces students to Bioconductor interfaces to the NCBI’s Gene Expression Omnibus, Genomic Data Commons, Sequence Read Archive and PharmacoDB. It additionally introduces curated resources providing The Cancer Genome Atlas, the Human Microbiome Project and other microbiome studies, and major pharmacogenomic studies, as native Bioconductor objects ready for analysis and comparison to in-house datasets. 13.2.7 Learning goals search NCBI resources for publicly available ’omics data quickly use data from the TCGA and the Human Microbiome Project 13.2.8 Learning objectives find and download processed microarray and RNA-seq datasets from the Gene Expression Omnibus find and download ’omics data from the Genomic Data Commons and Sequence Read Archive download and manipulate data from The Cancer Genome Atlas and Human Microbiome Project download and explore pharmacogenomics data 13.3 Overview Before proceeding, ensure that the following packages are installed. required_pkgs = c( &quot;TCGAbiolinks&quot;, &quot;GEOquery&quot;, &quot;GenomicDataCommons&quot;, &quot;limma&quot;, &quot;curatedTCGAData&quot;, &quot;recount&quot;, &quot;curatedMetagenomicData&quot;, &quot;phyloseq&quot;, &quot;HMP16SData&quot;) BiocManager::install(required_pkgs) 13.4 GEOquery (Davis and Meltzer 2007) The NCBI Gene Expression Omnibus (GEO) serves as a public repository for a wide range of high-throughput experimental data. These data include single and dual channel microarray-based experiments measuring mRNA, genomic DNA, and protein abundance, as well as non-array techniques such as serial analysis of gene expression (SAGE), mass spectrometry proteomic data, and high-throughput sequencing data. The GEOquery package (Davis and Meltzer 2007) forms a bridge between this public repository and the analysis capabilities in Bioconductor. 13.4.1 Overview of GEO At the most basic level of organization of GEO, there are four basic entity types. The first three (Sample, Platform, and Series) are supplied by users; the fourth, the dataset, is compiled and curated by GEO staff from the user-submitted data. See the GEO home page for more information. 13.4.1.1 Platforms A Platform record describes the list of elements on the array (e.g., cDNAs, oligonucleotide probesets, ORFs, antibodies) or the list of elements that may be detected and quantified in that experiment (e.g., SAGE tags, peptides). Each Platform record is assigned a unique and stable GEO accession number (GPLxxx). A Platform may reference many Samples that have been submitted by multiple submitters. 13.4.1.2 Samples A Sample record describes the conditions under which an individual Sample was handled, the manipulations it underwent, and the abundance measurement of each element derived from it. Each Sample record is assigned a unique and stable GEO accession number (GSMxxx). A Sample entity must reference only one Platform and may be included in multiple Series. 13.4.1.3 Series A Series record defines a set of related Samples considered to be part of a group, how the Samples are related, and if and how they are ordered. A Series provides a focal point and description of the experiment as a whole. Series records may also contain tables describing extracted data, summary conclusions, or analyses. Each Series record is assigned a unique and stable GEO accession number (GSExxx). Series records are available in a couple of formats which are handled by GEOquery independently. The smaller and new GSEMatrix files are quite fast to parse; a simple flag is used by GEOquery to choose to use GSEMatrix files (see below). 13.4.1.4 Datasets GEO DataSets (GDSxxx) are curated sets of GEO Sample data. There are hundreds of GEO datasets available, but GEO discontinued creating GDS records several years ago. We mention them here for completeness only. 13.4.2 Getting Started using GEOquery Getting data from GEO is really quite easy. There is only one command that is needed, getGEO. This one function interprets its input to determine how to get the data from GEO and then parse the data into useful R data structures. library(GEOquery) With the library loaded, we are free to access any GEO accession. 13.4.3 Use case: MDS plot of cancer data The data we are going to access are from this paper. Background: The tumor microenvironment is an important factor in cancer immunotherapy response. To further understand how a tumor affects the local immune system, we analyzed immune gene expression differences between matching normal and tumor tissue.Methods: We analyzed public and new gene expression data from solid cancers and isolated immune cell populations. We also determined the correlation between CD8, FoxP3 IHC, and our gene signatures.Results: We observed that regulatory T cells (Tregs) were one of the main drivers of immune gene expression differences between normal and tumor tissue. A tumor-specific CD8 signature was slightly lower in tumor tissue compared with normal of most (12 of 16) cancers, whereas a Treg signature was higher in tumor tissue of all cancers except liver. Clustering by Treg signature found two groups in colorectal cancer datasets. The high Treg cluster had more samples that were consensus molecular subtype 1/4, right-sided, and microsatellite-instable, compared with the low Treg cluster. Finally, we found that the correlation between signature and IHC was low in our small dataset, but samples in the high Treg cluster had significantly more CD8+ and FoxP3+ cells compared with the low Treg cluster.Conclusions: Treg gene expression is highly indicative of the overall tumor immune environment.Impact: In comparison with the consensus molecular subtype and microsatellite status, the Treg signature identifies more colorectal tumors with high immune activation that may benefit from cancer immunotherapy. In this little exercise, we will: Access public omics data using the GEOquery package Convert the public omics data to a SummarizedExperiment object. Perform a simple unsupervised analysis to visualize these public data. Use the GEOquery package to fetch data about GSE103512. gse = getGEO(&quot;GSE103512&quot;)[[1]] Note that getGEO, when used to retrieve GSE records, returns a list. The members of the list each represent one GEO Platform, since each GSE record can contain multiple related datasets (eg., gene expression and DNA methylation). In this case, the list is of length one, but it is still necessary to grab the first elment. The first step–a detail–is to convert from the older Bioconductor data structure (GEOquery was written in 2007), the ExpressionSet, to the newer SummarizedExperiment. One line suffices. library(SummarizedExperiment) se = as(gse, &quot;SummarizedExperiment&quot;) Examine two variables of interest, cancer type and tumor/normal status. with(colData(se),table(`cancer.type.ch1`,`normal.ch1`)) #&gt; normal.ch1 #&gt; cancer.type.ch1 no yes #&gt; BC 65 10 #&gt; CRC 57 12 #&gt; NSCLC 60 9 #&gt; PCA 60 7 Filter gene expression by variance to find most informative genes. sds = apply(assay(se, &#39;exprs&#39;),1,sd) dat = assay(se, &#39;exprs&#39;)[order(sds,decreasing = TRUE)[1:500],] Perform multidimensional scaling and prepare for plotting. We will be using ggplot2, so we need to make a data.frame before plotting. mdsvals = cmdscale(dist(t(dat))) mdsvals = as.data.frame(mdsvals) mdsvals$Type=factor(colData(se)[,&#39;cancer.type.ch1&#39;]) mdsvals$Normal = factor(colData(se)[,&#39;normal.ch1&#39;]) head(mdsvals) #&gt; V1 V2 Type Normal #&gt; GSM2772660 8.531331 -18.57115 BC no #&gt; GSM2772661 8.991591 -13.63764 BC no #&gt; GSM2772662 10.788973 -13.48403 BC no #&gt; GSM2772663 3.127105 -19.13529 BC no #&gt; GSM2772664 13.056599 -13.88711 BC no #&gt; GSM2772665 7.903717 -13.24731 BC no And do the plot. library(ggplot2) ggplot(mdsvals, aes(x=V1,y=V2,shape=Normal,color=Type)) + geom_point( alpha=0.6) + theme(text=element_text(size = 18)) 13.4.4 Accessing Raw Data from GEO NCBI GEO accepts (but has not always required) raw data such as .CEL files, .CDF files, images, etc. It is also not uncommon for some RNA-seq or other sequencing datasets to supply only raw data (with accompanying sample information, of course), necessitating Sometimes, it is useful to get quick access to such data. A single function, getGEOSuppFiles, can take as an argument a GEO accession and will download all the raw data associate with that accession. By default, the function will create a directory in the current working directory to store the raw data for the chosen GEO accession. 13.5 GenomicDataCommons From the Genomic Data Commons (GDC) website: The National Cancer Institute’s (NCI’s) Genomic Data Commons (GDC) is a data sharing platform that promotes precision medicine in oncology. It is not just a database or a tool; it is an expandable knowledge network supporting the import and standardization of genomic and clinical data from cancer research programs. The GDC contains NCI-generated data from some of the largest and most comprehensive cancer genomic datasets, including The Cancer Genome Atlas (TCGA) and Therapeutically Applicable Research to Generate Effective Therapies (TARGET). For the first time, these datasets have been harmonized using a common set of bioinformatics pipelines, so that the data can be directly compared. As a growing knowledge system for cancer, the GDC also enables researchers to submit data, and harmonizes these data for import into the GDC. As more researchers add clinical and genomic data to the GDC, it will become an even more powerful tool for making discoveries about the molecular basis of cancer that may lead to better care for patients. The data model for the GDC is complex, but it worth a quick overview and a graphical representation is included here. The data model is encoded as a so-called property graph. Nodes represent entities such as Projects, Cases, Diagnoses, Files (various kinds), and Annotations. The relationships between these entities are maintained as edges. Both nodes and edges may have Properties that supply instance details. The GDC API exposes these nodes and edges in a somewhat simplified set of RESTful endpoints. 13.5.1 Quickstart This quickstart section is just meant to show basic functionality. More details of functionality are included further on in this vignette and in function-specific help. To report bugs or problems, either submit a new issue or submit a bug.report(package='GenomicDataCommons') from within R (which will redirect you to the new issue on GitHub). 13.5.1.1 Installation Installation of the GenomicDataCommons package is identical to installation of other Bioconductor packages. install.packages(&#39;BiocManager&#39;) BiocManager::install(&#39;GenomicDataCommons&#39;) After installation, load the library in order to use it. library(GenomicDataCommons) 13.5.1.2 Check connectivity and status The GenomicDataCommons package relies on having network connectivity. In addition, the NCI GDC API must also be operational and not under maintenance. Checking status can be used to check this connectivity and functionality. GenomicDataCommons::status() #&gt; $commit #&gt; [1] &quot;e9e20d6f97f2bf6dd3b3261e36ead57c56a4c7cc&quot; #&gt; #&gt; $data_release #&gt; [1] &quot;Data Release 12.0 - June 13, 2018&quot; #&gt; #&gt; $status #&gt; [1] &quot;OK&quot; #&gt; #&gt; $tag #&gt; [1] &quot;1.14.1&quot; #&gt; #&gt; $version #&gt; [1] 1 13.5.1.3 Find data The following code builds a manifest that can be used to guide the download of raw data. Here, filtering finds gene expression files quantified as raw counts using HTSeq from ovarian cancer patients. ge_manifest = files() %&gt;% filter( ~ cases.project.project_id == &#39;TCGA-OV&#39; &amp; type == &#39;gene_expression&#39; &amp; analysis.workflow_type == &#39;HTSeq - Counts&#39;) %&gt;% manifest() 13.5.1.4 Download data After the 379 gene expression files specified in the query above. Using multiple processes to do the download very significantly speeds up the transfer in many cases. On a standard 1Gb connection, the following completes in about 30 seconds. The first time the data are downloaded, R will ask to create a cache directory (see ?gdc_cache for details of setting and interacting with the cache). Resulting downloaded files will be stored in the cache directory. Future access to the same files will be directly from the cache, alleviating multiple downloads. fnames = lapply(ge_manifest$id[1:20],gdcdata) If the download had included controlled-access data, the download above would have needed to include a token. Details are available in the authentication section below. 13.5.1.5 Metadata queries The GenomicDataCommons can access the significant clinical, demographic, biospecimen, and annotation information contained in the NCI GDC. expands = c(&quot;diagnoses&quot;,&quot;annotations&quot;, &quot;demographic&quot;,&quot;exposures&quot;) projResults = projects() %&gt;% results(size=10) str(projResults,list.len=5) #&gt; List of 8 #&gt; $ dbgap_accession_number: chr [1:10] &quot;phs001179&quot; &quot;phs000470&quot; NA NA ... #&gt; $ disease_type :List of 10 #&gt; ..$ FM-AD : chr [1:23] &quot;Germ Cell Neoplasms&quot; &quot;Acinar Cell Neoplasms&quot; &quot;Miscellaneous Tumors&quot; &quot;Thymic Epithelial Neoplasms&quot; ... #&gt; ..$ TARGET-RT: chr &quot;Rhabdoid Tumor&quot; #&gt; ..$ TCGA-UCS : chr &quot;Uterine Carcinosarcoma&quot; #&gt; ..$ TCGA-LUSC: chr &quot;Lung Squamous Cell Carcinoma&quot; #&gt; ..$ TCGA-BRCA: chr &quot;Breast Invasive Carcinoma&quot; #&gt; .. [list output truncated] #&gt; $ released : logi [1:10] TRUE TRUE TRUE TRUE TRUE TRUE ... #&gt; $ state : chr [1:10] &quot;open&quot; &quot;open&quot; &quot;open&quot; &quot;open&quot; ... #&gt; $ primary_site :List of 10 #&gt; ..$ FM-AD : chr [1:42] &quot;Kidney&quot; &quot;Testis&quot; &quot;Unknown&quot; &quot;Other and unspecified parts of biliary tract&quot; ... #&gt; ..$ TARGET-RT: chr &quot;Kidney&quot; #&gt; ..$ TCGA-UCS : chr &quot;Uterus&quot; #&gt; ..$ TCGA-LUSC: chr &quot;Lung&quot; #&gt; ..$ TCGA-BRCA: chr &quot;Breast&quot; #&gt; .. [list output truncated] #&gt; [list output truncated] #&gt; - attr(*, &quot;row.names&quot;)= int [1:10] 1 2 3 4 5 6 7 8 9 10 #&gt; - attr(*, &quot;class&quot;)= chr [1:3] &quot;GDCprojectsResults&quot; &quot;GDCResults&quot; &quot;list&quot; names(projResults) #&gt; [1] &quot;dbgap_accession_number&quot; &quot;disease_type&quot; #&gt; [3] &quot;released&quot; &quot;state&quot; #&gt; [5] &quot;primary_site&quot; &quot;project_id&quot; #&gt; [7] &quot;id&quot; &quot;name&quot; # or listviewer::jsonedit(clinResults) 13.5.2 Basic design This package design is meant to have some similarities to the “hadleyverse” approach of dplyr. Roughly, the functionality for finding and accessing files and metadata can be divided into: Simple query constructors based on GDC API endpoints. A set of verbs that when applied, adjust filtering, field selection, and faceting (fields for aggregation) and result in a new query object (an endomorphism) A set of verbs that take a query and return results from the GDC In addition, there are exhiliary functions for asking the GDC API for information about available and default fields, slicing BAM files, and downloading actual data files. Here is an overview of functionality14. Creating a query projects() cases() files() annotations() Manipulating a query filter() facet() select() Introspection on the GDC API fields mapping() available_fields() default_fields() grep_fields() field_picker() available_values() available_expand() Executing an API call to retrieve query results results() count() response() Raw data file downloads gdcdata() transfer() gdc_client() Summarizing and aggregating field values (faceting) aggregations() Authentication gdc_token() BAM file slicing slicing() 13.5.3 Usage There are two main classes of operations when working with the NCI GDC. Querying metadata and finding data files (e.g., finding all gene expression quantifications data files for all colon cancer patients). Transferring raw or processed data from the GDC to another computer (e.g., downloading raw or processed data) Both classes of operation are reviewed in detail in the following sections. 13.6 Querying metadata Vast amounts of metadata about cases (patients, basically), files, projects, and so-called annotations are available via the NCI GDC API. Typically, one will want to query metadata to either focus in on a set of files for download or transfer or to perform so-called aggregations (pivot-tables, facets, similar to the R table() functionality). Querying metadata starts with creating a “blank” query. One will often then want to filter the query to limit results prior to retrieving results. The GenomicDataCommons package has helper functions for listing fields that are available for filtering. In addition to fetching results, the GDC API allows faceting, or aggregating,, useful for compiling reports, generating dashboards, or building user interfaces to GDC data (see GDC web query interface for a non-R-based example). 13.6.0.1 Creating a query The GenomicDataCommons package accesses the same API as the GDC website. Therefore, a useful approach, particularly for beginning users is to examine the filters available on the GDC repository pages to find appropriate filtering criteria. From there, converting those checkboxes to a GenomicDataCommons query() is relatively straightforward. Note that only a small subset of the available_fields() are available by default on the website. A screenshot of an example query of the GDC repository portal. A query of the GDC starts its life in R. Queries follow the four metadata endpoints available at the GDC. In particular, there are four convenience functions that each create GDCQuery objects (actually, specific subclasses of GDCQuery): projects() cases() files() annotations() pquery = projects() The pquery object is now an object of (S3) class, GDCQuery (and gdc_projects and list). The object contains the following elements: fields: This is a character vector of the fields that will be returned when we retrieve data. If no fields are specified to, for example, the projects() function, the default fields from the GDC are used (see default_fields()) filters: This will contain results after calling the filter() method and will be used to filter results on retrieval. facets: A character vector of field names that will be used for aggregating data in a call to aggregations(). archive: One of either “default” or “legacy”. token: A character(1) token from the GDC. See the authentication section for details, but note that, in general, the token is not necessary for metadata query and retrieval, only for actual data download. Looking at the actual object (get used to using str()!), note that the query contains no results. str(pquery) #&gt; List of 5 #&gt; $ fields : chr [1:16] &quot;awg_review&quot; &quot;dbgap_accession_number&quot; &quot;disease_type&quot; &quot;in_review&quot; ... #&gt; $ filters: NULL #&gt; $ facets : NULL #&gt; $ legacy : logi FALSE #&gt; $ expand : NULL #&gt; - attr(*, &quot;class&quot;)= chr [1:3] &quot;gdc_projects&quot; &quot;GDCQuery&quot; &quot;list&quot; 13.6.0.2 Retrieving results [ GDC pagination documentation ] [ GDC sorting documentation ] With a query object available, the next step is to retrieve results from the GDC. The GenomicDataCommons package. The most basic type of results we can get is a simple count() of records available that satisfy the filter criteria. Note that we have not set any filters, so a count() here will represent all the project records publicly available at the GDC in the “default” archive&quot; pcount = count(pquery) # or pcount = pquery %&gt;% count() pcount #&gt; [1] 40 The results() method will fetch actual results. presults = pquery %&gt;% results() These results are returned from the GDC in JSON format and converted into a (potentially nested) list in R. The str() method is useful for taking a quick glimpse of the data. str(presults) #&gt; List of 8 #&gt; $ dbgap_accession_number: chr [1:10] &quot;phs001179&quot; &quot;phs000470&quot; NA NA ... #&gt; $ disease_type :List of 10 #&gt; ..$ FM-AD : chr [1:23] &quot;Germ Cell Neoplasms&quot; &quot;Acinar Cell Neoplasms&quot; &quot;Miscellaneous Tumors&quot; &quot;Thymic Epithelial Neoplasms&quot; ... #&gt; ..$ TARGET-RT: chr &quot;Rhabdoid Tumor&quot; #&gt; ..$ TCGA-UCS : chr &quot;Uterine Carcinosarcoma&quot; #&gt; ..$ TCGA-LUSC: chr &quot;Lung Squamous Cell Carcinoma&quot; #&gt; ..$ TCGA-BRCA: chr &quot;Breast Invasive Carcinoma&quot; #&gt; ..$ TCGA-SKCM: chr &quot;Skin Cutaneous Melanoma&quot; #&gt; ..$ TARGET-OS: chr &quot;Osteosarcoma&quot; #&gt; ..$ TCGA-THYM: chr &quot;Thymoma&quot; #&gt; ..$ TARGET-WT: chr &quot;High-Risk Wilms Tumor&quot; #&gt; ..$ TCGA-ESCA: chr &quot;Esophageal Carcinoma&quot; #&gt; $ released : logi [1:10] TRUE TRUE TRUE TRUE TRUE TRUE ... #&gt; $ state : chr [1:10] &quot;open&quot; &quot;open&quot; &quot;open&quot; &quot;open&quot; ... #&gt; $ primary_site :List of 10 #&gt; ..$ FM-AD : chr [1:42] &quot;Kidney&quot; &quot;Testis&quot; &quot;Unknown&quot; &quot;Other and unspecified parts of biliary tract&quot; ... #&gt; ..$ TARGET-RT: chr &quot;Kidney&quot; #&gt; ..$ TCGA-UCS : chr &quot;Uterus&quot; #&gt; ..$ TCGA-LUSC: chr &quot;Lung&quot; #&gt; ..$ TCGA-BRCA: chr &quot;Breast&quot; #&gt; ..$ TCGA-SKCM: chr &quot;Skin&quot; #&gt; ..$ TARGET-OS: chr &quot;Bone&quot; #&gt; ..$ TCGA-THYM: chr &quot;Thymus&quot; #&gt; ..$ TARGET-WT: chr &quot;Kidney&quot; #&gt; ..$ TCGA-ESCA: chr &quot;Esophagus&quot; #&gt; $ project_id : chr [1:10] &quot;FM-AD&quot; &quot;TARGET-RT&quot; &quot;TCGA-UCS&quot; &quot;TCGA-LUSC&quot; ... #&gt; $ id : chr [1:10] &quot;FM-AD&quot; &quot;TARGET-RT&quot; &quot;TCGA-UCS&quot; &quot;TCGA-LUSC&quot; ... #&gt; $ name : chr [1:10] &quot;Foundation Medicine Adult Cancer Clinical Dataset (FM-AD)&quot; &quot;Rhabdoid Tumor&quot; &quot;Uterine Carcinosarcoma&quot; &quot;Lung Squamous Cell Carcinoma&quot; ... #&gt; - attr(*, &quot;row.names&quot;)= int [1:10] 1 2 3 4 5 6 7 8 9 10 #&gt; - attr(*, &quot;class&quot;)= chr [1:3] &quot;GDCprojectsResults&quot; &quot;GDCResults&quot; &quot;list&quot; A default of only 10 records are returned. We can use the size and from arguments to results() to either page through results or to change the number of results. Finally, there is a convenience method, results_all() that will simply fetch all the available results given a query. Note that results_all() may take a long time and return HUGE result sets if not used carefully. Use of a combination of count() and results() to get a sense of the expected data size is probably warranted before calling results_all() length(ids(presults)) #&gt; [1] 10 presults = pquery %&gt;% results_all() length(ids(presults)) #&gt; [1] 40 # includes all records length(ids(presults)) == count(pquery) #&gt; [1] TRUE Extracting subsets of results or manipulating the results into a more conventional R data structure is not easily generalizable. However, the purrr, rlist, and data.tree packages are all potentially of interest for manipulating complex, nested list structures. For viewing the results in an interactive viewer, consider the listviewer package. 13.6.0.3 Fields and Values [ GDC fields documentation ] Central to querying and retrieving data from the GDC is the ability to specify which fields to return, filtering by fields and values, and faceting or aggregating. The GenomicDataCommons package includes two simple functions, available_fields() and default_fields(). Each can operate on a character(1) endpoint name (“cases”, “files”, “annotations”, or “projects”) or a GDCQuery object. default_fields(&#39;files&#39;) #&gt; [1] &quot;access&quot; &quot;acl&quot; #&gt; [3] &quot;batch_id&quot; &quot;created_datetime&quot; #&gt; [5] &quot;data_category&quot; &quot;data_format&quot; #&gt; [7] &quot;data_type&quot; &quot;error_type&quot; #&gt; [9] &quot;experimental_strategy&quot; &quot;file_autocomplete&quot; #&gt; [11] &quot;file_id&quot; &quot;file_name&quot; #&gt; [13] &quot;file_size&quot; &quot;file_state&quot; #&gt; [15] &quot;imaging_date&quot; &quot;magnification&quot; #&gt; [17] &quot;md5sum&quot; &quot;origin&quot; #&gt; [19] &quot;platform&quot; &quot;read_pair_number&quot; #&gt; [21] &quot;revision&quot; &quot;state&quot; #&gt; [23] &quot;state_comment&quot; &quot;submitter_id&quot; #&gt; [25] &quot;tags&quot; &quot;type&quot; #&gt; [27] &quot;updated_datetime&quot; # The number of fields available for files endpoint length(available_fields(&#39;files&#39;)) #&gt; [1] 703 # The first few fields available for files endpoint head(available_fields(&#39;files&#39;)) #&gt; [1] &quot;access&quot; &quot;acl&quot; #&gt; [3] &quot;analysis.analysis_id&quot; &quot;analysis.analysis_type&quot; #&gt; [5] &quot;analysis.batch_id&quot; &quot;analysis.created_datetime&quot; The fields to be returned by a query can be specified following a similar paradigm to that of the dplyr package. The select() function is a verb that resets the fields slot of a GDCQuery; note that this is not quite analogous to the dplyr select() verb that limits from already-present fields. We completely replace the fields when using select() on a GDCQuery. # Default fields here qcases = cases() qcases$fields #&gt; [1] &quot;aliquot_ids&quot; &quot;analyte_ids&quot; #&gt; [3] &quot;batch_id&quot; &quot;case_autocomplete&quot; #&gt; [5] &quot;case_id&quot; &quot;created_datetime&quot; #&gt; [7] &quot;days_to_index&quot; &quot;days_to_lost_to_followup&quot; #&gt; [9] &quot;disease_type&quot; &quot;index_date&quot; #&gt; [11] &quot;lost_to_followup&quot; &quot;portion_ids&quot; #&gt; [13] &quot;primary_site&quot; &quot;sample_ids&quot; #&gt; [15] &quot;slide_ids&quot; &quot;state&quot; #&gt; [17] &quot;submitter_aliquot_ids&quot; &quot;submitter_analyte_ids&quot; #&gt; [19] &quot;submitter_id&quot; &quot;submitter_portion_ids&quot; #&gt; [21] &quot;submitter_sample_ids&quot; &quot;submitter_slide_ids&quot; #&gt; [23] &quot;updated_datetime&quot; # set up query to use ALL available fields # Note that checking of fields is done by select() qcases = cases() %&gt;% GenomicDataCommons::select(available_fields(&#39;cases&#39;)) head(qcases$fields) #&gt; [1] &quot;case_id&quot; &quot;aliquot_ids&quot; #&gt; [3] &quot;analyte_ids&quot; &quot;annotations.annotation_id&quot; #&gt; [5] &quot;annotations.batch_id&quot; &quot;annotations.case_id&quot; Finding fields of interest is such a common operation that the GenomicDataCommons includes the grep_fields() function and the field_picker() widget. See the appropriate help pages for details. 13.6.0.4 Facets and aggregation [ GDC facet documentation ] The GDC API offers a feature known as aggregation or faceting. By specifying one or more fields (of appropriate type), the GDC can return to us a count of the number of records matching each potential value. This is similar to the R table method. Multiple fields can be returned at once, but the GDC API does not have a cross-tabulation feature; all aggregations are only on one field at a time. Results of aggregation() calls come back as a list of data.frames (actually, tibbles). # total number of files of a specific type res = files() %&gt;% facet(c(&#39;type&#39;,&#39;data_type&#39;)) %&gt;% aggregations() res$type #&gt; key doc_count #&gt; 1 simple_somatic_mutation 64015 #&gt; 2 annotated_somatic_mutation 63580 #&gt; 3 aligned_reads 45985 #&gt; 4 copy_number_segment 44752 #&gt; 5 gene_expression 34713 #&gt; 6 slide_image 30036 #&gt; 7 biospecimen_supplement 25151 #&gt; 8 mirna_expression 22976 #&gt; 9 clinical_supplement 12496 #&gt; 10 methylation_beta_value 12359 #&gt; 11 aggregated_somatic_mutation 186 #&gt; 12 masked_somatic_mutation 132 Using aggregations() is an also easy way to learn the contents of individual fields and forms the basis for faceted search pages. 13.6.0.5 Filtering [ GDC filtering documentation ] The GenomicDataCommons package uses a form of non-standard evaluation to specify R-like queries that are then translated into an R list. That R list is, upon calling a method that fetches results from the GDC API, translated into the appropriate JSON string. The R expression uses the formula interface as suggested by Hadley Wickham in his vignette on non-standard evaluation It’s best to use a formula because a formula captures both the expression to evaluate and the environment where the evaluation occurs. This is important if the expression is a mixture of variables in a data frame and objects in the local environment [for example]. For the user, these details will not be too important except to note that a filter expression must begin with a “~”. qfiles = files() qfiles %&gt;% count() # all files #&gt; [1] 356381 To limit the file type, we can refer back to the section on faceting to see the possible values for the file field “type”. For example, to filter file results to only “gene_expression” files, we simply specify a filter. qfiles = files() %&gt;% filter(~ type == &#39;gene_expression&#39;) # here is what the filter looks like after translation str(get_filter(qfiles)) #&gt; List of 2 #&gt; $ op : &#39;scalar&#39; chr &quot;=&quot; #&gt; $ content:List of 2 #&gt; ..$ field: chr &quot;type&quot; #&gt; ..$ value: chr &quot;gene_expression&quot; What if we want to create a filter based on the project (‘TCGA-OVCA’, for example)? Well, we have a couple of possible ways to discover available fields. The first is based on base R functionality and some intuition. grep(&#39;pro&#39;,available_fields(&#39;files&#39;),value=TRUE) #&gt; [1] &quot;cases.diagnoses.progression_free_survival&quot; #&gt; [2] &quot;cases.diagnoses.progression_free_survival_event&quot; #&gt; [3] &quot;cases.diagnoses.progression_or_recurrence&quot; #&gt; [4] &quot;cases.project.awg_review&quot; #&gt; [5] &quot;cases.project.dbgap_accession_number&quot; #&gt; [6] &quot;cases.project.disease_type&quot; #&gt; [7] &quot;cases.project.in_review&quot; #&gt; [8] &quot;cases.project.intended_release_date&quot; #&gt; [9] &quot;cases.project.is_legacy&quot; #&gt; [10] &quot;cases.project.name&quot; #&gt; [11] &quot;cases.project.primary_site&quot; #&gt; [12] &quot;cases.project.program.dbgap_accession_number&quot; #&gt; [13] &quot;cases.project.program.name&quot; #&gt; [14] &quot;cases.project.program.program_id&quot; #&gt; [15] &quot;cases.project.project_id&quot; #&gt; [16] &quot;cases.project.releasable&quot; #&gt; [17] &quot;cases.project.release_requested&quot; #&gt; [18] &quot;cases.project.released&quot; #&gt; [19] &quot;cases.project.request_submission&quot; #&gt; [20] &quot;cases.project.state&quot; #&gt; [21] &quot;cases.project.submission_enabled&quot; #&gt; [22] &quot;cases.samples.days_to_sample_procurement&quot; #&gt; [23] &quot;cases.samples.method_of_sample_procurement&quot; #&gt; [24] &quot;cases.samples.portions.slides.number_proliferating_cells&quot; #&gt; [25] &quot;cases.tissue_source_site.project&quot; Interestingly, the project information is “nested” inside the case. We don’t need to know that detail other than to know that we now have a few potential guesses for where our information might be in the files records. We need to know where because we need to construct the appropriate filter. files() %&gt;% facet(&#39;cases.project.project_id&#39;) %&gt;% aggregations() #&gt; $cases.project.project_id #&gt; key doc_count #&gt; 1 FM-AD 36134 #&gt; 2 TCGA-BRCA 31511 #&gt; 3 TCGA-LUAD 17051 #&gt; 4 TCGA-UCEC 16130 #&gt; 5 TCGA-HNSC 15266 #&gt; 6 TCGA-OV 15057 #&gt; 7 TCGA-THCA 14420 #&gt; 8 TCGA-LUSC 15323 #&gt; 9 TCGA-LGG 14723 #&gt; 10 TCGA-KIRC 15082 #&gt; 11 TCGA-PRAD 14287 #&gt; 12 TCGA-COAD 14270 #&gt; 13 TCGA-GBM 11973 #&gt; 14 TCGA-SKCM 12724 #&gt; 15 TCGA-STAD 12845 #&gt; 16 TCGA-BLCA 11710 #&gt; 17 TCGA-LIHC 10814 #&gt; 18 TCGA-CESC 8593 #&gt; 19 TCGA-KIRP 8506 #&gt; 20 TCGA-SARC 7493 #&gt; 21 TCGA-PAAD 5306 #&gt; 22 TCGA-ESCA 5270 #&gt; 23 TCGA-PCPG 5032 #&gt; 24 TCGA-READ 4918 #&gt; 25 TCGA-TGCT 4217 #&gt; 26 TCGA-THYM 3444 #&gt; 27 TCGA-LAML 3960 #&gt; 28 TARGET-NBL 2795 #&gt; 29 TCGA-ACC 2546 #&gt; 30 TCGA-KICH 2324 #&gt; 31 TCGA-MESO 2330 #&gt; 32 TARGET-AML 2170 #&gt; 33 TCGA-UVM 2179 #&gt; 34 TCGA-UCS 1658 #&gt; 35 TARGET-WT 1406 #&gt; 36 TCGA-DLBC 1330 #&gt; 37 TCGA-CHOL 1348 #&gt; 38 TARGET-OS 47 #&gt; 39 TARGET-RT 174 #&gt; 40 TARGET-CCSK 15 We note that cases.project.project_id looks like it is a good fit. We also note that TCGA-OV is the correct project_id, not TCGA-OVCA. Note that unlike with dplyr and friends, the filter() method here replaces the filter and does not build on any previous filters. qfiles = files() %&gt;% filter( ~ cases.project.project_id == &#39;TCGA-OV&#39; &amp; type == &#39;gene_expression&#39;) str(get_filter(qfiles)) #&gt; List of 2 #&gt; $ op : &#39;scalar&#39; chr &quot;and&quot; #&gt; $ content:List of 2 #&gt; ..$ :List of 2 #&gt; .. ..$ op : &#39;scalar&#39; chr &quot;=&quot; #&gt; .. ..$ content:List of 2 #&gt; .. .. ..$ field: chr &quot;cases.project.project_id&quot; #&gt; .. .. ..$ value: chr &quot;TCGA-OV&quot; #&gt; ..$ :List of 2 #&gt; .. ..$ op : &#39;scalar&#39; chr &quot;=&quot; #&gt; .. ..$ content:List of 2 #&gt; .. .. ..$ field: chr &quot;type&quot; #&gt; .. .. ..$ value: chr &quot;gene_expression&quot; qfiles %&gt;% count() #&gt; [1] 1137 Asking for a count() of results given these new filter criteria gives r qfiles %&gt;% count() results. Generating a manifest for bulk downloads is as simple as asking for the manifest from the current query. manifest_df = qfiles %&gt;% manifest() head(manifest_df) #&gt; # A tibble: 6 x 5 #&gt; id filename md5 size state #&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; #&gt; 1 567ced20-00cf-46… b2552f6f-dd15-410f-a621-… 9af0d993c40aec… 258324 live #&gt; 2 05692746-1770-47… 701b8c71-6c05-4e5b-ac10-… 8e9816f4d9b871… 526537 live #&gt; 3 e2d47640-8565-43… b2552f6f-dd15-410f-a621-… e05190ed65c8a8… 543367 live #&gt; 4 bc6dab72-dc5a-4c… a1c4f19e-079e-47e7-8939-… 110d8cda0ccdf6… 253059 live #&gt; 5 0a176c20-f3f3-4b… 01eac123-1e21-440d-9495-… b40921f17128a9… 540592 live #&gt; 6 2ae73487-7acf-42… 12c8b289-b9d0-4697-b3a6-… 4d3c2b951d94f0… 549437 live Note that we might still not be quite there. Looking at filenames, there are suspiciously named files that might include “FPKM”, “FPKM-UQ”, or “counts”. Another round of grep and available_fields, looking for “type” turned up that the field “analysis.workflow_type” has the appropriate filter criteria. qfiles = files() %&gt;% filter( ~ cases.project.project_id == &#39;TCGA-OV&#39; &amp; type == &#39;gene_expression&#39; &amp; analysis.workflow_type == &#39;HTSeq - Counts&#39;) manifest_df = qfiles %&gt;% manifest() nrow(manifest_df) #&gt; [1] 379 The GDC Data Transfer Tool can be used (from R, transfer() or from the command-line) to orchestrate high-performance, restartable transfers of all the files in the manifest. See the bulk downloads section for details. 13.6.1 Authentication [ GDC authentication documentation ] The GDC offers both “controlled-access” and “open” data. As of this writing, only data stored as files is “controlled-access”; that is, metadata accessible via the GDC is all “open” data and some files are “open” and some are “controlled-access”. Controlled-access data are only available after going through the process of obtaining access. After controlled-access to one or more datasets has been granted, logging into the GDC web portal will allow you to access a GDC authentication token, which can be downloaded and then used to access available controlled-access data via the GenomicDataCommons package. The GenomicDataCommons uses authentication tokens only for downloading data (see transfer and gdcdata documentation). The package includes a helper function, gdc_token, that looks for the token to be stored in one of three ways (resolved in this order): As a string stored in the environment variable, GDC_TOKEN As a file, stored in the file named by the environment variable, GDC_TOKEN_FILE In a file in the user home directory, called .gdc_token As a concrete example: token = gdc_token() transfer(...,token=token) # or transfer(...,token=get_token()) 13.6.2 Datafile access and download The gdcdata function takes a character vector of one or more file ids. A simple way of producing such a vector is to produce a manifest data frame and then pass in the first column, which will contain file ids. fnames = gdcdata(manifest_df$id[1:2],progress=FALSE) Note that for controlled-access data, a GDC authentication token is required. Using the BiocParallel package may be useful for downloading in parallel, particularly for large numbers of smallish files. The bulk download functionality is only efficient (as of v1.2.0 of the GDC Data Transfer Tool) for relatively large files, so use this approach only when transferring BAM files or larger VCF files, for example. Otherwise, consider using the approach shown above, perhaps in parallel. fnames = gdcdata(manifest_df$id[3:10], access_method = &#39;client&#39;) 13.7 Sequence Read Archive 13.8 Accessing The Cancer Genome Atlas (TCGA) We summarize two approaches to accessing TCGA data: 1. TCGAbiolinks: a. data access through GenomicDataCommons b. provides data both from the legacy Firehose pipeline used by the TCGA publications (alignments based on hg18 and hg19 builds15), and the GDC harmonized GRCh38 pipeline16. c. downloads files from the Genomic Data Commons, and provides conversion to (Ranged)SummarizedExperiment where possible 2. curatedTCGAData: a. data access through ExperimentHub b. provides data from the legacy Firehose pipeline17 c. provides individual assays as (Ranged)SummarizedExperiment and RaggedExperiment, integrates multiple assays within and across cancer types using MultiAssayExperiment 13.8.1 TCGAbiolinks We demonstrate here generating a RangedSummarizedExperiment for RNA-seq data from adrenocortical carcinoma (ACC). For additional information and options, see the TCGAbiolinks vignettes18. Load packages: Search for matching data: library(TCGAbiolinks) library(SummarizedExperiment) query &lt;- GDCquery(project = &quot;TCGA-ACC&quot;, data.category = &quot;Gene expression&quot;, data.type = &quot;Gene expression quantification&quot;, platform = &quot;Illumina HiSeq&quot;, file.type = &quot;normalized_results&quot;, experimental.strategy = &quot;RNA-Seq&quot;, legacy = TRUE) Download data and convert it to RangedSummarizedExperiment: gdcdir &lt;- file.path(&quot;Waldron_PublicData&quot;, &quot;GDCdata&quot;) GDCdownload(query, method = &quot;api&quot;, files.per.chunk = 10, directory = gdcdir) ACCse &lt;- GDCprepare(query, directory = gdcdir) ACCse 13.8.2 curatedTCGAData: Curated Data From The Cancer Genome Atlas as MultiAssayExperiment Objects curatedTCGAData does not interface with the Genomic Data Commons, but downloads data from Bioconductor’s ExperimentHub. By default, the curatedTCGAData() function will only show available datasets, and not download anything. The arguments are shown here only for demonstration, the same result is obtained with no arguments: library(curatedTCGAData) library(MultiAssayExperiment) curatedTCGAData(diseaseCode = &quot;*&quot;, assays = &quot;*&quot;) #&gt; Please see the list below for available cohorts and assays #&gt; Available Cancer codes: #&gt; ACC BLCA BRCA CESC CHOL COAD DLBC ESCA GBM HNSC KICH #&gt; KIRC KIRP LAML LGG LIHC LUAD LUSC MESO OV PAAD PCPG #&gt; PRAD READ SARC SKCM STAD TGCT THCA THYM UCEC UCS UVM #&gt; Available Data Types: #&gt; CNACGH CNASeq CNASNP CNVSNP GISTICA GISTICT #&gt; Methylation miRNAArray miRNASeqGene mRNAArray #&gt; Mutation RNASeq2GeneNorm RNASeqGene RPPAArray Check potential files to be downloaded for adrenocortical carcinoma (ACC): curatedTCGAData(diseaseCode = &quot;ACC&quot;) #&gt; ACC_CNASNP #&gt; &quot;ACC_CNASNP-20160128.rda&quot; #&gt; ACC_CNVSNP #&gt; &quot;ACC_CNVSNP-20160128.rda&quot; #&gt; ACC_GISTIC_AllByGene #&gt; &quot;ACC_GISTIC_AllByGene-20160128.rda&quot; #&gt; ACC_GISTIC_ThresholdedByGene #&gt; &quot;ACC_GISTIC_ThresholdedByGene-20160128.rda&quot; #&gt; ACC_Methylation #&gt; &quot;ACC_Methylation-20160128.rda&quot; #&gt; ACC_miRNASeqGene #&gt; &quot;ACC_miRNASeqGene-20160128.rda&quot; #&gt; ACC_Mutation #&gt; &quot;ACC_Mutation-20160128.rda&quot; #&gt; ACC_RNASeq2GeneNorm #&gt; &quot;ACC_RNASeq2GeneNorm-20160128.rda&quot; #&gt; ACC_RPPAArray #&gt; &quot;ACC_RPPAArray-20160128.rda&quot; Actually download the reverse phase protein array (RPPA) and RNA-seq data for ACC ACCmae &lt;- curatedTCGAData(&quot;ACC&quot;, c(&quot;RPPAArray&quot;, &quot;RNASeq2GeneNorm&quot;), dry.run=FALSE) ACCmae #&gt; A MultiAssayExperiment object of 2 listed #&gt; experiments with user-defined names and respective classes. #&gt; Containing an ExperimentList class object of length 2: #&gt; [1] ACC_RNASeq2GeneNorm-20160128: SummarizedExperiment with 20501 rows and 79 columns #&gt; [2] ACC_RPPAArray-20160128: SummarizedExperiment with 192 rows and 46 columns #&gt; Features: #&gt; experiments() - obtain the ExperimentList instance #&gt; colData() - the primary/phenotype DataFrame #&gt; sampleMap() - the sample availability DataFrame #&gt; `$`, `[`, `[[` - extract colData columns, subset, or experiment #&gt; *Format() - convert into a long or wide DataFrame #&gt; assays() - convert ExperimentList to a SimpleList of matrices Note. Data will be downloaded the first time the above command is run; subsequent times it will be loaded from local cache. This object contains 822 columns of clinical, pathological, specimen, and subtypes data in its colData, merged from all available data levels (1-4) of the Firehose pipeline: dim(colData(ACCmae)) #&gt; [1] 79 822 head(colnames(colData(ACCmae))) #&gt; [1] &quot;patientID&quot; &quot;years_to_birth&quot; &quot;vital_status&quot; #&gt; [4] &quot;days_to_death&quot; &quot;days_to_last_followup&quot; &quot;tumor_tissue_site&quot; See the MultiAssayExperiment vignette (Ramos et al. 2017) and the Workflow for Multi-omics Analysis with MultiAssayExperiment workshop for details on using this object. 13.8.2.1 Subtype information Some cancer datasets contain associated subtype information within the clinical datasets provided. This subtype information is included in the metadata of colData of the MultiAssayExperiment object. To obtain these variable names, run the metadata function on the colData of the object such as: head(metadata(colData(ACCmae))[[&quot;subtypes&quot;]]) #&gt; ACC_annotations ACC_subtype #&gt; 1 Patient_ID SAMPLE #&gt; 2 histological_subtypes Histology #&gt; 3 mrna_subtypes C1A/C1B #&gt; 4 mrna_subtypes mRNA_K4 #&gt; 5 cimp MethyLevel #&gt; 6 microrna_subtypes miRNA cluster 13.9 recount: Reproducible RNA-seq Analysis Using recount2 The recount(Collado-Torres et al. 2017) package provides uniformly processed RangedSummarizedExperiment objects at the gene, exon, or exon-exon junctions level, the raw counts, the phenotype metadata used, the urls to sample coverage bigWig files and mean coverage bigWig file, for every study available. The RangedSummarizedExperiment objects can be used for differential expression analysis. These are also accessible through a web interface.19 #&gt; No methods found in package &#39;IRanges&#39; for request: &#39;subset&#39; when loading &#39;derfinder&#39; recount provides a search function: library(recount) project_info &lt;- abstract_search(&#39;GSE32465&#39;) It is not an ExperimentHub package, so downloading and serializing is slightly more involved in involves two steps: first, download the gene-level RangedSummarizedExperiment data: download_study(project_info$project) #&gt; 2018-07-16 15:58:26 downloading file rse_gene.Rdata to SRP009615 followed by loading the data load(file.path(project_info$project, &#39;rse_gene.Rdata&#39;)) 13.10 curated*Data packages for standardized cancer transcriptomes There are focused databases of cancer microarray data for several cancer types, which can be useful for researchers of those cancer types or for methodological development: * curatedOvarianData(Ganzfried et al. 2013): Clinically Annotated Data for the Ovarian Cancer Transcriptome (data available with additional options through the MetaGxOvarian package). * curatedBladderData: Clinically Annotated Data for the Bladder Cancer Transcriptome * curatedCRCData: Clinically Annotated Data for the Colorectal Cancer Transcriptome These provide data from the Gene Expression Omnibus and other sources, but use a formally vocabulary for clinicopathological data and use a common pipeline for preprocessing of microarray data (for Affymetrix, other for other platforms the processed data are provided as processed by original study authors), merging probesets, and mapping to gene symbols. The pipeline is described by Ganzfried et al. (2013). 13.11 Microbiome data Bioconductor provides curated resources of microbiome data. Most microbiome data are generated either by targeted amplicon sequencing (usually of variable regions of the 16S ribosomal RNA gene) or by metagenomic shotgun sequencing (MGX). These two approaches are analyzed by different sequence analysis tools, but downstream statistical and ecological analysis can involve any of the following types of data: * taxonomic abundance at different levels of the taxonomic hierarchy * phylogenetic distances and the phylogenetic tree of life * metabolic potential of the microbiome * abundance of microbial genes and gene families A review of types and properties of microbiome data is provided by (Morgan and Huttenhower 2012). 13.11.1 curatedMetagenomicData: Curated and processed metagenomic data through ExperimentHub curatedMetagenomicData(Pasolli et al. 2017) provides 6 types of processed data for &gt;30 publicly available whole-metagenome shotgun sequencing datasets (obtained from the Sequence Read Archive): Species-level taxonomic profiles, expressed as relative abundance from kingdom to strain level Presence of unique, clade-specific markers Abundance of unique, clade-specific markers Abundance of gene families Metabolic pathway coverage Metabolic pathway abundance Types 1-3 are generated by MetaPhlAn2; 4-6 are generated by HUMAnN2. Currently, curatedMetagenomicData provides: 6386 samples from 31 datasets, primarily of the human gut but including body sites profiled in the Human Microbiome Project Processed data from whole-metagenome shotgun metagenomics, with manually-curated metadata, as integrated and documented Bioconductor ExpressionSet objects ~80 fields of specimen metadata from original papers, supplementary files, and websites, with manual curation to standardize annotations Processing of data through the MetaPhlAn2 pipeline for taxonomic abundance, and HUMAnN2 pipeline for metabolic analysis These represent ~100TB of raw sequencing data, but the processed data provided are much smaller. These datasets are documented in the reference manual. This is an ExperimentHub package, and its main workhorse function is curatedMetagenomicData(): The manually curated metadata for all available samples are provided in a single table combined_metadata: library(curatedMetagenomicData) ?combined_metadata View(data.frame(combined_metadata)) The main function provides a list of ExpressionSet objects: oral &lt;- c(&quot;BritoIL_2016.metaphlan_bugs_list.oralcavity&quot;, &quot;Castro-NallarE_2015.metaphlan_bugs_list.oralcavity&quot;) esl &lt;- curatedMetagenomicData(oral, dryrun = FALSE) #&gt; Working on BritoIL_2016.metaphlan_bugs_list.oralcavity #&gt; snapshotDate(): 2018-07-16 #&gt; see ?curatedMetagenomicData and browseVignettes(&#39;curatedMetagenomicData&#39;) for documentation #&gt; downloading 1 resources #&gt; retrieving 1 resource #&gt; loading from cache #&gt; &#39;/home/mramos//.ExperimentHub/1179&#39; #&gt; Working on Castro-NallarE_2015.metaphlan_bugs_list.oralcavity #&gt; snapshotDate(): 2018-07-16 #&gt; see ?curatedMetagenomicData and browseVignettes(&#39;curatedMetagenomicData&#39;) for documentation #&gt; downloading 1 resources #&gt; retrieving 1 resource #&gt; loading from cache #&gt; &#39;/home/mramos//.ExperimentHub/391&#39; esl #&gt; List of length 2 #&gt; names(2): BritoIL_2016.metaphlan_bugs_list.oralcavity ... These ExpressionSet objects can also be converted to phyloseq object for ecological analysis and differential abundance analysis using the DESeq2 package, using the ExpressionSet2phyloseq() function: ExpressionSet2phyloseq( esl[[1]], phylogenetictree = TRUE) #&gt; Loading required namespace: phyloseq #&gt; phyloseq-class experiment-level object #&gt; otu_table() OTU Table: [ 535 taxa and 140 samples ] #&gt; sample_data() Sample Data: [ 140 samples by 17 sample variables ] #&gt; tax_table() Taxonomy Table: [ 535 taxa by 8 taxonomic ranks ] #&gt; phy_tree() Phylogenetic Tree: [ 535 tips and 534 internal nodes ] See the documentation of phyloseq for more on ecological and differential abundance analysis of the microbiome. 13.11.2 HMP16SData: 16S rRNA Sequencing Data from the Human Microbiome Project suppressPackageStartupMessages(library(HMP16SData)) #&gt; snapshotDate(): 2018-07-16 HMP16SData(Schiffer et al. 2018) is a Bioconductor ExperimentData package of the Human Microbiome Project (HMP) 16S rRNA sequencing data. Taxonomic count data files are provided as downloaded from the HMP Data Analysis and Coordination Center from its QIIME pipeline. Processed data is provided as SummarizedExperiment class objects via ExperimentHub. Like other ExperimentHub-based packages, a convenience function does downloading, automatic local caching, and serializing of a Bioconductor data class. This returns taxonomic counts from the V1-3 variable region of the 16S rRNA gene, along with the unrestricted participant data and phylogenetic tree. V13() #&gt; snapshotDate(): 2018-07-16 #&gt; see ?HMP16SData and browseVignettes(&#39;HMP16SData&#39;) for documentation #&gt; downloading 1 resources #&gt; retrieving 1 resource #&gt; loading from cache #&gt; &#39;/home/mramos//.ExperimentHub/1117&#39; #&gt; class: SummarizedExperiment #&gt; dim: 43140 2898 #&gt; metadata(2): experimentData phylogeneticTree #&gt; assays(1): 16SrRNA #&gt; rownames(43140): OTU_97.1 OTU_97.10 ... OTU_97.9997 OTU_97.9999 #&gt; rowData names(7): CONSENSUS_LINEAGE SUPERKINGDOM ... FAMILY GENUS #&gt; colnames(2898): 700013549 700014386 ... 700114963 700114965 #&gt; colData names(7): RSID VISITNO ... HMP_BODY_SUBSITE SRS_SAMPLE_ID This can also be converted to phyloseq for ecological and differential abundance analysis; see the HMP16SData vignette for details. 13.12 Pharmacogenomics 13.13 Bibliography "]
]
